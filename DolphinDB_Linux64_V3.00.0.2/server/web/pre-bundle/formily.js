/******/ var __webpack_modules__ = ({

/***/ 35:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var reactIs = __webpack_require__(959);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ 843:
/***/ ((__unused_webpack_module, exports) => {

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),

/***/ 959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



if (true) {
  module.exports = __webpack_require__(843);
} else {}


/***/ }),

/***/ 280:
/***/ ((module) => {

module.exports = globalThis["ReactDOM"];

/***/ }),

/***/ 500:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = '';

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (arg) {
				classes = appendClass(classes, parseValue(arg));
			}
		}

		return classes;
	}

	function parseValue (arg) {
		if (typeof arg === 'string' || typeof arg === 'number') {
			return arg;
		}

		if (typeof arg !== 'object') {
			return '';
		}

		if (Array.isArray(arg)) {
			return classNames.apply(null, arg);
		}

		if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
			return arg.toString();
		}

		var classes = '';

		for (var key in arg) {
			if (hasOwn.call(arg, key) && arg[key]) {
				classes = appendClass(classes, key);
			}
		}

		return classes;
	}

	function appendClass (value, newClass) {
		if (!newClass) {
			return value;
		}
	
		if (value) {
			return value + ' ' + newClass;
		}
	
		return value + newClass;
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/create fake namespace object */
/******/ (() => {
/******/ 	var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 	var leafPrototypes;
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 16: return value when it's Promise-like
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = this(value);
/******/ 		if(mode & 8) return value;
/******/ 		if(typeof value === 'object' && value) {
/******/ 			if((mode & 4) && value.__esModule) return value;
/******/ 			if((mode & 16) && typeof value.then === 'function') return value;
/******/ 		}
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		var def = {};
/******/ 		leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 		for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 			Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 		}
/******/ 		def['default'] = () => (value);
/******/ 		__webpack_require__.d(ns, def);
/******/ 		return ns;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  JV: () => (/* reexport */ antd_v5_esm_namespaceObject),
  iJ: () => (/* reexport */ core_esm_namespaceObject),
  q_: () => (/* reexport */ react_esm_namespaceObject)
});

// NAMESPACE OBJECT: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/index.js
var core_esm_namespaceObject = {};
__webpack_require__.r(core_esm_namespaceObject);
__webpack_require__.d(core_esm_namespaceObject, {
  FormPath: () => (Path),
  LifeCycleTypes: () => (LifeCycleTypes),
  createEffectContext: () => (createEffectContext),
  createEffectHook: () => (createEffectHook),
  createForm: () => (createForm),
  getLocaleByPath: () => (getLocaleByPath),
  getValidateLocaleIOSCode: () => (getValidateLocaleIOSCode),
  isArrayField: () => (isArrayField),
  isArrayFieldState: () => (isArrayFieldState),
  isDataField: () => (isDataField),
  isDataFieldState: () => (isDataFieldState),
  isField: () => (isField),
  isFieldState: () => (isFieldState),
  isForm: () => (isForm),
  isFormState: () => (isFormState),
  isGeneralField: () => (isGeneralField),
  isGeneralFieldState: () => (isGeneralFieldState),
  isObjectField: () => (isObjectField),
  isObjectFieldState: () => (isObjectFieldState),
  isQuery: () => (isQuery),
  isVoidField: () => (isVoidField),
  isVoidFieldState: () => (isVoidFieldState),
  onFieldChange: () => (onFieldChange),
  onFieldInit: () => (onFieldInit),
  onFieldInitialValueChange: () => (onFieldInitialValueChange),
  onFieldInputValueChange: () => (onFieldInputValueChange),
  onFieldLoading: () => (onFieldLoading),
  onFieldMount: () => (onFieldMount),
  onFieldReact: () => (onFieldReact),
  onFieldReset: () => (onFieldReset),
  onFieldSubmit: () => (onFieldSubmit),
  onFieldSubmitEnd: () => (onFieldSubmitEnd),
  onFieldSubmitFailed: () => (onFieldSubmitFailed),
  onFieldSubmitStart: () => (onFieldSubmitStart),
  onFieldSubmitSuccess: () => (onFieldSubmitSuccess),
  onFieldSubmitValidateEnd: () => (onFieldSubmitValidateEnd),
  onFieldSubmitValidateFailed: () => (onFieldSubmitValidateFailed),
  onFieldSubmitValidateStart: () => (onFieldSubmitValidateStart),
  onFieldSubmitValidateSuccess: () => (onFieldSubmitValidateSuccess),
  onFieldUnmount: () => (onFieldUnmount),
  onFieldValidateEnd: () => (onFieldValidateEnd),
  onFieldValidateFailed: () => (onFieldValidateFailed),
  onFieldValidateStart: () => (onFieldValidateStart),
  onFieldValidateSuccess: () => (onFieldValidateSuccess),
  onFieldValidating: () => (onFieldValidating),
  onFieldValueChange: () => (onFieldValueChange),
  onFormGraphChange: () => (onFormGraphChange),
  onFormInit: () => (onFormInit),
  onFormInitialValuesChange: () => (onFormInitialValuesChange),
  onFormInputChange: () => (onFormInputChange),
  onFormLoading: () => (onFormLoading),
  onFormMount: () => (onFormMount),
  onFormReact: () => (onFormReact),
  onFormReset: () => (onFormReset),
  onFormSubmit: () => (onFormSubmit),
  onFormSubmitEnd: () => (onFormSubmitEnd),
  onFormSubmitFailed: () => (onFormSubmitFailed),
  onFormSubmitStart: () => (onFormSubmitStart),
  onFormSubmitSuccess: () => (onFormSubmitSuccess),
  onFormSubmitValidateEnd: () => (onFormSubmitValidateEnd),
  onFormSubmitValidateFailed: () => (onFormSubmitValidateFailed),
  onFormSubmitValidateStart: () => (onFormSubmitValidateStart),
  onFormSubmitValidateSuccess: () => (onFormSubmitValidateSuccess),
  onFormUnmount: () => (onFormUnmount),
  onFormValidateEnd: () => (onFormValidateEnd),
  onFormValidateFailed: () => (onFormValidateFailed),
  onFormValidateStart: () => (onFormValidateStart),
  onFormValidateSuccess: () => (onFormValidateSuccess),
  onFormValuesChange: () => (onFormValuesChange),
  registerValidateFormats: () => (registerValidateFormats),
  registerValidateLocale: () => (registerValidateLocale),
  registerValidateMessageTemplateEngine: () => (registerValidateMessageTemplateEngine),
  registerValidateRules: () => (registerValidateRules),
  setValidateLanguage: () => (setValidateLanguage),
  useEffectForm: () => (useEffectForm)
});

// NAMESPACE OBJECT: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/index.js
var react_esm_namespaceObject = {};
__webpack_require__.r(react_esm_namespaceObject);
__webpack_require__.d(react_esm_namespaceObject, {
  ArrayField: () => (ArrayField_ArrayField),
  ContextCleaner: () => (ContextCleaner),
  ExpressionScope: () => (ExpressionScope),
  Field: () => (Field_Field),
  FieldContext: () => (FieldContext),
  FormConsumer: () => (FormConsumer),
  FormContext: () => (FormContext),
  FormProvider: () => (FormProvider),
  ObjectField: () => (ObjectField_ObjectField),
  Observer: () => (Observer),
  RecordScope: () => (RecordScope),
  RecordsScope: () => (RecordsScope),
  RecursionField: () => (RecursionField),
  Schema: () => (Schema),
  SchemaComponentsContext: () => (SchemaComponentsContext),
  SchemaContext: () => (SchemaContext),
  SchemaExpressionScopeContext: () => (SchemaExpressionScopeContext),
  SchemaMarkupContext: () => (SchemaMarkupContext),
  SchemaOptionsContext: () => (SchemaOptionsContext),
  VoidField: () => (VoidField_VoidField),
  connect: () => (connect),
  createSchemaField: () => (createSchemaField),
  mapProps: () => (mapProps),
  mapReadPretty: () => (mapReadPretty),
  observer: () => (observer),
  useExpressionScope: () => (useExpressionScope),
  useField: () => (useField),
  useFieldSchema: () => (useFieldSchema),
  useForm: () => (useForm),
  useFormEffects: () => (useFormEffects),
  useParentForm: () => (useParentForm)
});

// NAMESPACE OBJECT: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/index.js
var antd_v5_esm_namespaceObject = {};
__webpack_require__.r(antd_v5_esm_namespaceObject);
__webpack_require__.d(antd_v5_esm_namespaceObject, {
  ArrayBase: () => (ArrayBase),
  ArrayCards: () => (ArrayCards),
  ArrayCollapse: () => (ArrayCollapse),
  ArrayItems: () => (ArrayItems),
  ArrayTable: () => (ArrayTable),
  ArrayTabs: () => (ArrayTabs),
  BaseItem: () => (BaseItem),
  Cascader: () => (cascader_Cascader),
  Checkbox: () => (Checkbox),
  DatePicker: () => (date_picker_DatePicker),
  Editable: () => (Editable),
  Form: () => (form_Form),
  FormButtonGroup: () => (FormButtonGroup),
  FormCollapse: () => (FormCollapse),
  FormDialog: () => (FormDialog),
  FormDrawer: () => (FormDrawer),
  FormGrid: () => (FormGrid),
  FormItem: () => (FormItem),
  FormLayout: () => (FormLayout),
  FormLayoutDeepContext: () => (FormLayoutDeepContext),
  FormLayoutShallowContext: () => (FormLayoutShallowContext),
  FormStep: () => (FormStep),
  FormTab: () => (FormTab),
  GridColumn: () => (GridColumn),
  Input: () => (input_Input),
  InternalArrayCards: () => (InternalArrayCards),
  InternalRadio: () => (InternalRadio),
  NumberPicker: () => (number_picker_NumberPicker),
  Password: () => (Password),
  Placeholder: () => (Placeholder),
  PlaceholderContext: () => (PlaceholderContext),
  PreviewText: () => (PreviewText),
  Radio: () => (Radio),
  Reset: () => (Reset),
  Select: () => (select_Select),
  SelectTable: () => (SelectTable),
  Space: () => (Space),
  Submit: () => (Submit),
  Switch: () => (Switch),
  TimePicker: () => (time_picker_TimePicker),
  Transfer: () => (Transfer),
  TreeSelect: () => (tree_select_TreeSelect),
  Upload: () => (Upload),
  createFormGrid: () => (createFormGrid),
  useFormDeepLayout: () => (useFormDeepLayout),
  useFormGrid: () => (useFormGrid),
  useFormItemLayout: () => (useFormItemLayout),
  useFormLayout: () => (useFormLayout),
  useFormShallowLayout: () => (useFormShallowLayout),
  useOverflow: () => (useOverflow),
  usePlaceholder: () => (usePlaceholder)
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/checkers.js
var checkers_toString = Object.prototype.toString;
var isType = function (type) {
    return function (obj) {
        return checkers_getType(obj) === "[object ".concat(type, "]");
    };
};
var checkers_getType = function (obj) { return checkers_toString.call(obj); };
var checkers_isFn = function (val) { return typeof val === 'function'; };
var checkers_isArr = Array.isArray;
var checkers_isPlainObj = isType('Object');
var checkers_isStr = isType('String');
var isBool = isType('Boolean');
var isNum = isType('Number');
var isMap = function (val) {
    return val && val instanceof Map;
};
var isSet = function (val) { return val && val instanceof Set; };
var isWeakMap = function (val) {
    return val && val instanceof WeakMap;
};
var isWeakSet = function (val) {
    return val && val instanceof WeakSet;
};
var isNumberLike = function (index) {
    return isNum(index) || /^\d+$/.test(index);
};
var isObj = function (val) { return typeof val === 'object'; };
var isRegExp = isType('RegExp');
var isReactElement = function (obj) {
    return obj && obj['$$typeof'] && obj['_owner'];
};
var isHTMLElement = function (target) {
    return Object.prototype.toString.call(target).indexOf('HTML') > -1;
};
//# sourceMappingURL=checkers.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/array.js

var toArr = function (val) { return (checkers_isArr(val) ? val : val ? [val] : []); };
function array_each(val, iterator, revert) {
    if (checkers_isArr(val) || checkers_isStr(val)) {
        if (revert) {
            for (var i = val.length - 1; i >= 0; i--) {
                if (iterator(val[i], i) === false) {
                    return;
                }
            }
        }
        else {
            for (var i = 0; i < val.length; i++) {
                if (iterator(val[i], i) === false) {
                    return;
                }
            }
        }
    }
    else if (isObj(val)) {
        var key = void 0;
        for (key in val) {
            if (Object.hasOwnProperty.call(val, key)) {
                if (iterator(val[key], key) === false) {
                    return;
                }
            }
        }
    }
}
function map(val, iterator, revert) {
    var res = checkers_isArr(val) || checkers_isStr(val) ? [] : {};
    array_each(val, function (item, key) {
        var value = iterator(item, key);
        if (checkers_isArr(res)) {
            ;
            res.push(value);
        }
        else {
            res[key] = value;
        }
    }, revert);
    return res;
}
function reduce(val, iterator, accumulator, revert) {
    var result = accumulator;
    array_each(val, function (item, key) {
        result = iterator(result, item, key);
    }, revert);
    return result;
}
function every(val, iterator, revert) {
    var res = true;
    array_each(val, function (item, key) {
        if (!iterator(item, key)) {
            res = false;
            return false;
        }
    }, revert);
    return res;
}
function some(val, iterator, revert) {
    var res = false;
    array_each(val, function (item, key) {
        if (iterator(item, key)) {
            res = true;
            return false;
        }
    }, revert);
    return res;
}
function findIndex(val, iterator, revert) {
    var res = -1;
    array_each(val, function (item, key) {
        if (iterator(item, key)) {
            res = key;
            return false;
        }
    }, revert);
    return res;
}
function find(val, iterator, revert) {
    var res;
    array_each(val, function (item, key) {
        if (iterator(item, key)) {
            res = item;
            return false;
        }
    }, revert);
    return res;
}
function includes(val, searchElement, revert) {
    if (isStr(val))
        return val.includes(searchElement);
    return some(val, function (item) { return item === searchElement; }, revert);
}
function move(array, fromIndex, toIndex) {
    if (fromIndex === toIndex)
        return array;
    if (toIndex < 0 ||
        fromIndex < 0 ||
        toIndex > array.length - 1 ||
        fromIndex > array.length - 1) {
        return array;
    }
    if (fromIndex < toIndex) {
        var fromItem = array[fromIndex];
        for (var index = fromIndex; index < toIndex; index++) {
            array[index] = array[index + 1];
        }
        array[toIndex] = fromItem;
    }
    else {
        var fromItem = array[fromIndex];
        for (var index = fromIndex; index > toIndex; index--) {
            array[index] = array[index - 1];
        }
        array[toIndex] = fromItem;
    }
    return array;
}
//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/global.js
/* istanbul ignore next */
function globalSelf() {
    try {
        if (typeof self !== 'undefined') {
            return self;
        }
    }
    catch (e) { }
    try {
        if (typeof window !== 'undefined') {
            return window;
        }
    }
    catch (e) { }
    try {
        if (typeof __webpack_require__.g !== 'undefined') {
            return __webpack_require__.g;
        }
    }
    catch (e) { }
    return Function('return this')();
}
var globalThisPolyfill = globalSelf();
//# sourceMappingURL=global.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/instanceof.js


var instOf = function (value, cls) {
    if (checkers_isFn(cls))
        return value instanceof cls;
    if (checkers_isStr(cls)) {
        return globalThisPolyfill[cls]
            ? value instanceof globalThisPolyfill[cls]
            : false;
    }
    return false;
};
//# sourceMappingURL=instanceof.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/compare.js


var isArray = checkers_isArr;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
/* eslint-disable */
function equal(a, b) {
    // fast-deep-equal index.js 2.0.1
    if (a === b) {
        return true;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        var arrA = isArray(a);
        var arrB = isArray(b);
        var i = void 0;
        var length_1;
        var key = void 0;
        if (arrA && arrB) {
            length_1 = a.length;
            if (length_1 !== b.length) {
                return false;
            }
            for (i = length_1; i-- !== 0;) {
                if (!equal(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        if (arrA !== arrB) {
            return false;
        }
        var momentA = a && a._isAMomentObject;
        var momentB = b && b._isAMomentObject;
        if (momentA !== momentB)
            return false;
        if (momentA && momentB)
            return a.isSame(b);
        var immutableA = a && a.toJS;
        var immutableB = b && b.toJS;
        if (immutableA !== immutableB)
            return false;
        if (immutableA)
            return a.is ? a.is(b) : a === b;
        var dateA = instOf(a, 'Date');
        var dateB = instOf(b, 'Date');
        if (dateA !== dateB) {
            return false;
        }
        if (dateA && dateB) {
            return a.getTime() === b.getTime();
        }
        var regexpA = instOf(a, 'RegExp');
        var regexpB = instOf(b, 'RegExp');
        if (regexpA !== regexpB) {
            return false;
        }
        if (regexpA && regexpB) {
            return a.toString() === b.toString();
        }
        var urlA = instOf(a, 'URL');
        var urlB = instOf(b, 'URL');
        if (urlA !== urlB) {
            return false;
        }
        if (urlA && urlB) {
            return a.href === b.href;
        }
        var schemaA = a && a.toJSON;
        var schemaB = b && b.toJSON;
        if (schemaA !== schemaB)
            return false;
        if (schemaA && schemaB)
            return equal(a.toJSON(), b.toJSON());
        var keys = keyList(a);
        length_1 = keys.length;
        if (length_1 !== keyList(b).length) {
            return false;
        }
        for (i = length_1; i-- !== 0;) {
            if (!hasProp.call(b, keys[i])) {
                return false;
            }
        }
        // end fast-deep-equal
        // Custom handling for React
        for (i = length_1; i-- !== 0;) {
            key = keys[i];
            if (key === '_owner' && a.$$typeof) {
                // React-specific: avoid traversing React elements' _owner.
                //  _owner contains circular references
                // and is not needed when comparing the actual elements (and not their owners)
                // .$$typeof and ._store on just reasonable markers of a react element
                continue;
            }
            else {
                // all other properties should be traversed as usual
                if (!equal(a[key], b[key])) {
                    return false;
                }
            }
        }
        // fast-deep-equal index.js 2.0.1
        return true;
    }
    return a !== a && b !== b;
}
// end fast-deep-equal
var compare_isEqual = function exportedEqual(a, b) {
    try {
        return equal(a, b);
    }
    catch (error) {
        /* istanbul ignore next */
        if ((error.message && error.message.match(/stack|recursion/i)) ||
            error.number === -2146828260) {
            // warn on circular references, don't crash
            // browsers give this different errors name and messages:
            // chrome/safari: "RangeError", "Maximum call stack size exceeded"
            // firefox: "InternalError", too much recursion"
            // edge: "Error", "Out of stack space"
            console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);
            return false;
        }
        // some other error. we should definitely know about these
        /* istanbul ignore next */
        throw error;
    }
};
//# sourceMappingURL=compare.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/clone.js
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var shallowClone = function (values) {
    if (Array.isArray(values)) {
        return values.slice(0);
    }
    else if (isPlainObj(values)) {
        if ('$$typeof' in values && '_owner' in values) {
            return values;
        }
        if (values['_isAMomentObject']) {
            return values;
        }
        if (values['_isJSONSchemaObject']) {
            return values;
        }
        if (isFn(values['toJS'])) {
            return values;
        }
        if (isFn(values['toJSON'])) {
            return values;
        }
        return __assign({}, values);
    }
    else if (typeof values === 'object') {
        return new values.constructor(values);
    }
    return values;
};
var clone = function (values) {
    if (Array.isArray(values)) {
        var res_1 = [];
        values.forEach(function (item) {
            res_1.push(clone(item));
        });
        return res_1;
    }
    else if (checkers_isPlainObj(values)) {
        if ('$$typeof' in values && '_owner' in values) {
            return values;
        }
        if (values['_isAMomentObject']) {
            return values;
        }
        if (values['_isJSONSchemaObject']) {
            return values;
        }
        if (checkers_isFn(values['toJS'])) {
            return values['toJS']();
        }
        if (checkers_isFn(values['toJSON'])) {
            return values['toJSON']();
        }
        var res = {};
        for (var key in values) {
            if (Object.hasOwnProperty.call(values, key)) {
                res[key] = clone(values[key]);
            }
        }
        return res;
    }
    else {
        return values;
    }
};
//# sourceMappingURL=clone.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/isEmpty.js

var has = Object.prototype.hasOwnProperty;
var isEmpty_toString = Object.prototype.toString;
var isUndef = function (val) { return val === undefined; };
var isEmpty_isValid = function (val) { return val !== undefined && val !== null; };
function isEmpty_isEmpty(val, strict) {
    if (strict === void 0) { strict = false; }
    // Null and Undefined...
    if (val == null) {
        return true;
    }
    // Booleans...
    if (typeof val === 'boolean') {
        return false;
    }
    // Numbers...
    if (typeof val === 'number') {
        return false;
    }
    // Strings...
    if (typeof val === 'string') {
        return val.length === 0;
    }
    // Functions...
    if (typeof val === 'function') {
        return val.length === 0;
    }
    // Arrays...
    if (Array.isArray(val)) {
        if (val.length === 0) {
            return true;
        }
        for (var i = 0; i < val.length; i++) {
            if (strict) {
                if (val[i] !== undefined && val[i] !== null) {
                    return false;
                }
            }
            else {
                if (val[i] !== undefined &&
                    val[i] !== null &&
                    val[i] !== '' &&
                    val[i] !== 0) {
                    return false;
                }
            }
        }
        return true;
    }
    // Errors...
    if (instOf(val, 'Error')) {
        return val.message === '';
    }
    // Objects...
    if (val.toString === isEmpty_toString) {
        switch (val.toString()) {
            // Maps, Sets, Files and Errors...
            case '[object File]':
            case '[object Map]':
            case '[object Set]': {
                return val.size === 0;
            }
            // Plain objects...
            case '[object Object]': {
                for (var key in val) {
                    if (has.call(val, key)) {
                        return false;
                    }
                }
                return true;
            }
        }
    }
    // Anything else...
    return false;
}
//# sourceMappingURL=isEmpty.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/tslib@2.6.2/node_modules/tslib/tslib.es6.mjs
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var tslib_es6_assign = function() {
  tslib_es6_assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return tslib_es6_assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
      }
      catch (e) {
          fail(e);
      }
    }
    if (env.hasError) throw env.error;
  }
  return next();
}

/* harmony default export */ const tslib_es6 = ({
  __extends,
  __assign: tslib_es6_assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
});

;// CONCATENATED MODULE: ./node_modules/.pnpm/lower-case@2.0.2/node_modules/lower-case/dist.es2015/index.js
/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
var SUPPORTED_LOCALE = {
    tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
            İ: "\u0069",
            I: "\u0131",
            İ: "\u0069",
        },
    },
    az: {
        regexp: /\u0130/g,
        map: {
            İ: "\u0069",
            I: "\u0131",
            İ: "\u0069",
        },
    },
    lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
            I: "\u0069\u0307",
            J: "\u006A\u0307",
            Į: "\u012F\u0307",
            Ì: "\u0069\u0307\u0300",
            Í: "\u0069\u0307\u0301",
            Ĩ: "\u0069\u0307\u0303",
        },
    },
};
/**
 * Localized lower case.
 */
function localeLowerCase(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));
    return lowerCase(str);
}
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist.es2015/index.js

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/pascal-case@3.1.2/node_modules/pascal-case/dist.es2015/index.js


function pascalCaseTransform(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCaseTransformMerge(input) {
    return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
}
function pascalCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, tslib_es6_assign({ delimiter: "", transform: pascalCaseTransform }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/case.js






//# sourceMappingURL=case.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/string.js
// ansiRegex
var ansiRegex = function () {
    var pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))',
    ].join('|');
    return new RegExp(pattern, 'g');
};
// astralRegex
var regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';
var astralRegex = function (opts) {
    return opts && opts.exact ? new RegExp("^".concat(regex, "$")) : new RegExp(regex, 'g');
};
// stripAnsi
var stripAnsi = function (input) {
    return typeof input === 'string' ? input.replace(ansiRegex(), '') : input;
};
var stringLength = function (input) {
    return stripAnsi(input).replace(astralRegex(), ' ').length;
};
//# sourceMappingURL=string.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/contexts.js
var contexts_assign = (undefined && undefined.__assign) || function () {
    contexts_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return contexts_assign.apply(this, arguments);
};
var ContextType = function (flag, props) {
    return contexts_assign({ flag: flag }, props);
};
var bracketContext = ContextType('[]');
var bracketArrayContext = ContextType('[\\d]');
var bracketDContext = ContextType('[[]]');
var parenContext = ContextType('()');
var braceContext = ContextType('{}');
var destructorContext = ContextType('{x}');
//# sourceMappingURL=contexts.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/tokens.js
var tokens_assign = (undefined && undefined.__assign) || function () {
    tokens_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return tokens_assign.apply(this, arguments);
};

var TokenType = function (flag, props) {
    return tokens_assign({ flag: flag }, props);
};
var nameTok = TokenType('name', {
    expectNext: function (next) {
        if (this.includesContext(destructorContext)) {
            return (next === nameTok ||
                next === commaTok ||
                next === bracketRTok ||
                next === braceRTok ||
                next === colonTok);
        }
        return (next === dotTok ||
            next === commaTok ||
            next === eofTok ||
            next === bracketRTok ||
            next === parenRTok ||
            next === colonTok ||
            next === expandTok ||
            next === bracketLTok);
    },
});
var starTok = TokenType('*', {
    expectNext: function (next) {
        return (next === dotTok ||
            next === parenLTok ||
            next === bracketLTok ||
            next === eofTok ||
            next === commaTok ||
            next === parenRTok);
    },
});
var dbStarTok = TokenType('**', {
    expectNext: function (next) {
        return (next === dotTok ||
            next === bracketLTok ||
            next === eofTok ||
            next === commaTok ||
            next === parenRTok);
    },
});
var dotTok = TokenType('.', {
    expectNext: function (next) {
        return (next === dotTok ||
            next === nameTok ||
            next === bracketDLTok ||
            next === starTok ||
            next === dbStarTok ||
            next === bracketLTok ||
            next === braceLTok ||
            next === eofTok);
    },
    expectPrev: function (prev) {
        return (prev === dotTok ||
            prev === nameTok ||
            prev === bracketDRTok ||
            prev === starTok ||
            prev === parenRTok ||
            prev === bracketRTok ||
            prev === expandTok ||
            prev === braceRTok);
    },
});
var bangTok = TokenType('!', {
    expectNext: function (next) {
        return next === nameTok || next === bracketDLTok;
    },
});
var colonTok = TokenType(':', {
    expectNext: function (next) {
        if (this.includesContext(destructorContext)) {
            return next === nameTok || next === braceLTok || next === bracketLTok;
        }
        return next === nameTok || next === bracketDLTok || next === bracketRTok;
    },
});
var braceLTok = TokenType('{', {
    expectNext: function (next) {
        return next === nameTok;
    },
    expectPrev: function (prev) {
        if (this.includesContext(destructorContext)) {
            return prev === colonTok || prev === commaTok || prev === bracketLTok;
        }
        return prev === dotTok || prev === colonTok || prev === parenLTok;
    },
    updateContext: function () {
        this.state.context.push(braceContext);
    },
});
var braceRTok = TokenType('}', {
    expectNext: function (next) {
        if (this.includesContext(destructorContext)) {
            return (next === commaTok ||
                next === braceRTok ||
                next === eofTok ||
                next === bracketRTok);
        }
        return next === dotTok || next === eofTok || next === commaTok;
    },
    expectPrev: function (prev) {
        return prev === nameTok || prev === braceRTok || prev === bracketRTok;
    },
    updateContext: function () {
        this.state.context.pop(braceContext);
    },
});
var bracketLTok = TokenType('[', {
    expectNext: function (next) {
        if (this.includesContext(destructorContext)) {
            return (next === nameTok ||
                next === bracketLTok ||
                next === braceLTok ||
                next === bracketRTok);
        }
        return (next === nameTok ||
            next === bracketDLTok ||
            next === colonTok ||
            next === bracketLTok ||
            next === ignoreTok ||
            next === bracketRTok);
    },
    expectPrev: function (prev) {
        if (this.includesContext(destructorContext)) {
            return prev === colonTok || prev === commaTok || prev === bracketLTok;
        }
        return (prev === starTok ||
            prev === bracketLTok ||
            prev === dotTok ||
            prev === nameTok ||
            prev === parenLTok ||
            // never reach
            prev == commaTok);
    },
    updateContext: function () {
        this.state.context.push(bracketContext);
    },
});
var bracketRTok = TokenType(']', {
    expectNext: function (next) {
        if (this.includesContext(destructorContext)) {
            return (next === commaTok ||
                next === braceRTok ||
                next === bracketRTok ||
                next === eofTok);
        }
        return (next === dotTok ||
            next === eofTok ||
            next === commaTok ||
            next === parenRTok ||
            next === bracketRTok);
    },
    updateContext: function () {
        if (this.includesContext(bracketArrayContext))
            return;
        if (!this.includesContext(bracketContext))
            throw this.unexpect();
        this.state.context.pop();
    },
});
var bracketDLTok = TokenType('[[', {
    updateContext: function () {
        this.state.context.push(bracketDContext);
    },
});
var bracketDRTok = TokenType(']]', {
    updateContext: function () {
        if (this.curContext() !== bracketDContext)
            throw this.unexpect();
        this.state.context.pop();
    },
});
var parenLTok = TokenType('(', {
    expectNext: function (next) {
        return (next === nameTok ||
            next === bracketDLTok ||
            next === braceLTok ||
            next === bangTok ||
            next === bracketLTok);
    },
    expectPrev: function (prev) {
        return prev === starTok;
    },
    updateContext: function () {
        this.state.context.push(parenContext);
    },
});
var parenRTok = TokenType(')', {
    expectNext: function (next) {
        return (next === dotTok ||
            next === eofTok ||
            next === commaTok ||
            next === parenRTok);
    },
    updateContext: function () {
        if (this.curContext() !== parenContext)
            throw this.unexpect();
        this.state.context.pop();
    },
});
var commaTok = TokenType(',', {
    expectNext: function (next) {
        return (next === nameTok ||
            next === bracketDLTok ||
            next === bracketLTok ||
            next === braceLTok);
    },
});
var ignoreTok = TokenType('ignore', {
    expectNext: function (next) {
        return next === bracketDRTok;
    },
    expectPrev: function (prev) {
        return prev == bracketDLTok;
    },
});
var expandTok = TokenType('expandTok', {
    expectNext: function (next) {
        return (next === dotTok ||
            next === eofTok ||
            next === commaTok ||
            next === parenRTok);
    },
});
var eofTok = TokenType('eof');
//# sourceMappingURL=tokens.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/tokenizer.js


var nonASCIIWhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var fullCharCodeAtPos = function (input, pos) {
    if (String.fromCharCode)
        return input.codePointAt(pos);
    var code = input.charCodeAt(pos);
    if (code <= 0xd7ff || code >= 0xe000)
        return code;
    var next = input.charCodeAt(pos + 1);
    return (code << 10) + next - 0x35fdc00;
};
var isRewordCode = function (code) {
    return code === 42 ||
        code === 46 ||
        code === 33 ||
        code === 91 ||
        code === 93 ||
        code === 40 ||
        code === 41 ||
        code === 44 ||
        code === 58 ||
        code === 126 ||
        code === 123 ||
        code === 125;
};
var getError = function (message, props) {
    var err = new Error(message);
    Object.assign(err, props);
    return err;
};
var slice = function (string, start, end) {
    var str = '';
    for (var i = start; i < end; i++) {
        var ch = string.charAt(i);
        if (ch !== '\\') {
            str += ch;
        }
    }
    return str;
};
var Tokenizer = /** @class */ (function () {
    function Tokenizer(input) {
        this.input = input;
        this.state = {
            context: [],
            type: null,
            pos: 0,
        };
        this.type_ = null;
    }
    Tokenizer.prototype.curContext = function () {
        return this.state.context[this.state.context.length - 1];
    };
    Tokenizer.prototype.includesContext = function (context) {
        for (var len = this.state.context.length - 1; len >= 0; len--) {
            if (this.state.context[len] === context) {
                return true;
            }
        }
        return false;
    };
    Tokenizer.prototype.unexpect = function (type) {
        type = type || this.state.type;
        return getError("Unexpect token \"".concat(type.flag, "\" in ").concat(this.state.pos, " char."), {
            pos: this.state.pos,
        });
    };
    Tokenizer.prototype.expectNext = function (type, next) {
        if (type && type.expectNext) {
            if (next && !type.expectNext.call(this, next)) {
                throw getError("Unexpect token \"".concat(next.flag, "\" token should not be behind \"").concat(type.flag, "\" token.(").concat(this.state.pos, "th char)"), {
                    pos: this.state.pos,
                });
            }
        }
    };
    Tokenizer.prototype.expectPrev = function (type, prev) {
        if (type && type.expectPrev) {
            if (prev && !type.expectPrev.call(this, prev)) {
                throw getError("Unexpect token \"".concat(type.flag, "\" should not be behind \"").concat(prev.flag, "\"(").concat(this.state.pos, "th char)."), {
                    pos: this.state.pos,
                });
            }
        }
    };
    Tokenizer.prototype.match = function (type) {
        return this.state.type === type;
    };
    Tokenizer.prototype.skipSpace = function () {
        if (this.curContext() === bracketDContext)
            return;
        loop: while (this.state.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.state.pos);
            switch (ch) {
                case 32:
                case 160:
                    ++this.state.pos;
                    break;
                case 13:
                    if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                        ++this.state.pos;
                    }
                case 10:
                case 8232:
                case 8233:
                    ++this.state.pos;
                    break;
                default:
                    if ((ch > 8 && ch < 14) ||
                        (ch >= 5760 && nonASCIIWhitespace.test(String.fromCharCode(ch)))) {
                        ++this.state.pos;
                    }
                    else {
                        break loop;
                    }
            }
        }
    };
    Tokenizer.prototype.next = function () {
        this.type_ = this.state.type;
        if (this.input.length <= this.state.pos) {
            return this.finishToken(eofTok);
        }
        this.skipSpace();
        this.readToken(this.getCode(), this.state.pos > 0 ? this.getCode(this.state.pos - 1) : -Infinity);
    };
    Tokenizer.prototype.getCode = function (pos) {
        if (pos === void 0) { pos = this.state.pos; }
        return fullCharCodeAtPos(this.input, pos);
    };
    Tokenizer.prototype.eat = function (type) {
        if (this.match(type)) {
            this.next();
            return true;
        }
        else {
            return false;
        }
    };
    Tokenizer.prototype.readKeyWord = function () {
        var startPos = this.state.pos, string = '';
        while (true) {
            var code = this.getCode();
            var prevCode = this.getCode(this.state.pos - 1);
            if (this.input.length === this.state.pos) {
                string = slice(this.input, startPos, this.state.pos + 1);
                break;
            }
            if (!isRewordCode(code) || prevCode === 92) {
                if (code === 32 ||
                    code === 160 ||
                    code === 10 ||
                    code === 8232 ||
                    code === 8233) {
                    string = slice(this.input, startPos, this.state.pos);
                    break;
                }
                if (code === 13 && this.input.charCodeAt(this.state.pos + 1) === 10) {
                    string = slice(this.input, startPos, this.state.pos);
                    break;
                }
                if ((code > 8 && code < 14) ||
                    (code >= 5760 && nonASCIIWhitespace.test(String.fromCharCode(code)))) {
                    string = slice(this.input, startPos, this.state.pos);
                    break;
                }
                this.state.pos++;
            }
            else {
                string = slice(this.input, startPos, this.state.pos);
                break;
            }
        }
        this.finishToken(nameTok, string);
    };
    Tokenizer.prototype.readIgnoreString = function () {
        var startPos = this.state.pos, prevCode, string = '';
        while (true) {
            var code = this.getCode();
            if (this.state.pos >= this.input.length)
                break;
            if ((code === 91 || code === 93) && prevCode === 92) {
                this.state.pos++;
                prevCode = '';
            }
            else if (code == 93 && prevCode === 93) {
                string = this.input
                    .slice(startPos, this.state.pos - 1)
                    .replace(/\\([\[\]])/g, '$1');
                this.state.pos++;
                break;
            }
            else {
                this.state.pos++;
                prevCode = code;
            }
        }
        this.finishToken(ignoreTok, string);
        this.finishToken(bracketDRTok);
    };
    Tokenizer.prototype.finishToken = function (type, value) {
        var preType = this.state.type;
        this.state.type = type;
        if (value !== undefined)
            this.state.value = value;
        this.expectNext(preType, type);
        this.expectPrev(type, preType);
        if (type.updateContext) {
            type.updateContext.call(this, preType);
        }
    };
    Tokenizer.prototype.readToken = function (code, prevCode) {
        if (prevCode === 92) {
            return this.readKeyWord();
        }
        if (this.input.length <= this.state.pos) {
            this.finishToken(eofTok);
        }
        else if (this.curContext() === bracketDContext) {
            this.readIgnoreString();
        }
        else if (code === 123) {
            this.state.pos++;
            this.finishToken(braceLTok);
        }
        else if (code === 125) {
            this.state.pos++;
            this.finishToken(braceRTok);
        }
        else if (code === 42) {
            this.state.pos++;
            if (this.getCode() === 42) {
                this.state.pos++;
                return this.finishToken(dbStarTok);
            }
            this.finishToken(starTok);
        }
        else if (code === 33) {
            this.state.pos++;
            this.finishToken(bangTok);
        }
        else if (code === 46) {
            this.state.pos++;
            this.finishToken(dotTok);
        }
        else if (code === 91) {
            this.state.pos++;
            if (this.getCode() === 91) {
                this.state.pos++;
                return this.finishToken(bracketDLTok);
            }
            this.finishToken(bracketLTok);
        }
        else if (code === 126) {
            this.state.pos++;
            this.finishToken(expandTok);
        }
        else if (code === 93) {
            this.state.pos++;
            this.finishToken(bracketRTok);
        }
        else if (code === 40) {
            this.state.pos++;
            this.finishToken(parenLTok);
        }
        else if (code === 41) {
            this.state.pos++;
            this.finishToken(parenRTok);
        }
        else if (code === 44) {
            this.state.pos++;
            this.finishToken(commaTok);
        }
        else if (code === 58) {
            this.state.pos++;
            this.finishToken(colonTok);
        }
        else {
            this.readKeyWord();
        }
    };
    return Tokenizer;
}());

//# sourceMappingURL=tokenizer.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/types.js
var types_isType = function (type) {
    return function (obj) {
        return obj && obj.type === type;
    };
};
var isIdentifier = types_isType('Identifier');
var isIgnoreExpression = types_isType('IgnoreExpression');
var isDotOperator = types_isType('DotOperator');
var isWildcardOperator = types_isType('WildcardOperator');
var isExpandOperator = types_isType('ExpandOperator');
var isGroupExpression = types_isType('GroupExpression');
var isRangeExpression = types_isType('RangeExpression');
var isDestructorExpression = types_isType('DestructorExpression');
var isObjectPattern = types_isType('ObjectPattern');
var isObjectPatternProperty = types_isType('ObjectPatternProperty');
var isArrayPattern = types_isType('ArrayPattern');
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/shared.js
var shared_toString = Object.prototype.toString;
var shared_isType = function (type) {
    return function (obj) {
        return shared_toString.call(obj) === "[object ".concat(type, "]");
    };
};
var shared_isFn = shared_isType('Function');
var shared_isArr = Array.isArray || shared_isType('Array');
var shared_isPlainObj = shared_isType('Object');
var shared_isStr = shared_isType('String');
var shared_isBool = shared_isType('Boolean');
var shared_isNum = shared_isType('Number');
var shared_isObj = function (val) { return typeof val === 'object'; };
var shared_isRegExp = shared_isType('RegExp');
var shared_isNumberLike = function (t) {
    return shared_isNum(t) || /^(\d+)(\.\d+)?$/.test(t);
};
var shared_isArray = shared_isArr;
var shared_keyList = Object.keys;
var shared_hasProp = Object.prototype.hasOwnProperty;
var shared_toArr = function (val) {
    return Array.isArray(val) ? val : val !== undefined ? [val] : [];
};
var isAssignable = function (val) {
    return typeof val === 'object' || typeof val === 'function';
};
var shared_isEqual = function (a, b) {
    if (a === b) {
        return true;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        var arrA = shared_isArray(a);
        var arrB = shared_isArray(b);
        var i = void 0;
        var length = void 0;
        var key = void 0;
        if (arrA && arrB) {
            length = a.length;
            if (length !== b.length) {
                return false;
            }
            for (i = length; i-- !== 0;) {
                if (!shared_isEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        if (arrA !== arrB) {
            return false;
        }
        var keys = shared_keyList(a);
        length = keys.length;
        if (length !== shared_keyList(b).length) {
            return false;
        }
        for (i = length; i-- !== 0;) {
            if (!shared_hasProp.call(b, keys[i])) {
                return false;
            }
        }
        for (i = length; i-- !== 0;) {
            key = keys[i];
            if (!shared_isEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    return a !== a && b !== b;
};
var isSegmentEqual = function (a, b) {
    a = typeof a === 'symbol' ? a : "".concat(a);
    b = typeof b === 'symbol' ? b : "".concat(b);
    return a === b;
};
//# sourceMappingURL=shared.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/destructor.js


var DestructorCache = new Map();
var destructor_isValid = function (val) { return val !== undefined && val !== null; };
var getDestructor = function (source) {
    return DestructorCache.get(source);
};
var setDestructor = function (source, rules) {
    DestructorCache.set(source, rules);
};
var parseDestructorRules = function (node) {
    var rules = [];
    if (isObjectPattern(node)) {
        var index_1 = 0;
        node.properties.forEach(function (child) {
            rules[index_1] = {
                path: [],
            };
            rules[index_1].key = child.key.value;
            rules[index_1].path.push(child.key.value);
            if (isIdentifier(child.value)) {
                rules[index_1].key = child.value.value;
            }
            var basePath = rules[index_1].path;
            var childRules = parseDestructorRules(child.value);
            var k = index_1;
            childRules.forEach(function (rule) {
                if (rules[k]) {
                    rules[k].key = rule.key;
                    rules[k].path = basePath.concat(rule.path);
                }
                else {
                    rules[k] = {
                        key: rule.key,
                        path: basePath.concat(rule.path),
                    };
                }
                k++;
            });
            if (k > index_1) {
                index_1 = k;
            }
            else {
                index_1++;
            }
        });
        return rules;
    }
    else if (isArrayPattern(node)) {
        var index_2 = 0;
        node.elements.forEach(function (child, key) {
            rules[index_2] = {
                path: [],
            };
            rules[index_2].key = key;
            rules[index_2].path.push(key);
            if (isIdentifier(child)) {
                rules[index_2].key = child.value;
            }
            var basePath = rules[index_2].path;
            var childRules = parseDestructorRules(child);
            var k = index_2;
            childRules.forEach(function (rule) {
                if (rules[k]) {
                    rules[k].key = rule.key;
                    rules[k].path = basePath.concat(rule.path);
                }
                else {
                    rules[k] = {
                        key: rule.key,
                        path: basePath.concat(rule.path),
                    };
                }
                k++;
            });
            if (k > index_2) {
                index_2 = k;
            }
            else {
                index_2++;
            }
        });
        return rules;
    }
    if (isDestructorExpression(node)) {
        return parseDestructorRules(node.value);
    }
    return rules;
};
var setInByDestructor = function (source, rules, value, mutators) {
    rules.forEach(function (_a) {
        var key = _a.key, path = _a.path;
        mutators.setIn([key], source, mutators.getIn(path, value));
    });
};
var getInByDestructor = function (source, rules, mutators) {
    var response = {};
    if (rules.length) {
        if (shared_isNum(rules[0].path[0])) {
            response = [];
        }
    }
    source = destructor_isValid(source) ? source : {};
    rules.forEach(function (_a) {
        var key = _a.key, path = _a.path;
        mutators.setIn(path, response, source[key]);
    });
    return response;
};
var deleteInByDestructor = function (source, rules, mutators) {
    rules.forEach(function (_a) {
        var key = _a.key;
        mutators.deleteIn([key], source);
    });
};
var existInByDestructor = function (source, rules, start, mutators) {
    return rules.every(function (_a) {
        var key = _a.key;
        return mutators.existIn([key], source, start);
    });
};
//# sourceMappingURL=destructor.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/parser.js
var parser_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var createTreeBySegments = function (segments, afterNode) {
    if (segments === void 0) { segments = []; }
    var segLen = segments.length;
    var build = function (start) {
        if (start === void 0) { start = 0; }
        var after = start < segLen - 1 ? build(start + 1) : afterNode;
        var dot = after && {
            type: 'DotOperator',
            after: after,
        };
        return {
            type: 'Identifier',
            value: segments[start],
            after: dot,
        };
    };
    return build();
};
var calculate = function (a, b, operator) {
    if (shared_isNumberLike(a) && shared_isNumberLike(b)) {
        if (operator === '+')
            return String(Number(a) + Number(b));
        if (operator === '-')
            return String(Number(a) - Number(b));
        if (operator === '*')
            return String(Number(a) * Number(b));
        if (operator === '/')
            return String(Number(a) / Number(b));
    }
    else {
        if (operator === '+')
            return String(a) + String(b);
        if (operator === '-')
            return 'NaN';
        if (operator === '*')
            return 'NaN';
        if (operator === '/')
            return 'NaN';
    }
    return String(Number(b));
};
var Parser = /** @class */ (function (_super) {
    parser_extends(Parser, _super);
    function Parser(input, base) {
        var _this = _super.call(this, input) || this;
        _this.isMatchPattern = false;
        _this.isWildMatchPattern = false;
        _this.haveExcludePattern = false;
        _this.haveRelativePattern = false;
        _this.base = base;
        return _this;
    }
    Parser.prototype.parse = function () {
        var node;
        this.data = {
            segments: [],
        };
        if (!this.eat(eofTok)) {
            this.next();
            node = this.parseAtom(this.state.type);
        }
        this.data.tree = node;
        return node;
    };
    Parser.prototype.append = function (parent, node) {
        if (parent && node) {
            parent.after = node;
        }
    };
    Parser.prototype.parseAtom = function (type) {
        switch (type) {
            case braceLTok:
            case bracketLTok:
                if (this.includesContext(destructorContext)) {
                    if (type === braceLTok) {
                        return this.parseObjectPattern();
                    }
                    else {
                        return this.parseArrayPattern();
                    }
                }
                return this.parseDestructorExpression();
            case nameTok:
                return this.parseIdentifier();
            case expandTok:
                return this.parseExpandOperator();
            case dbStarTok:
            case starTok:
                return this.parseWildcardOperator();
            case bracketDLTok:
                return this.parseIgnoreExpression();
            case dotTok:
                return this.parseDotOperator();
        }
    };
    Parser.prototype.pushSegments = function (key) {
        this.data.segments.push(key);
    };
    Parser.prototype.parseIdentifier = function () {
        var node = {
            type: 'Identifier',
            value: this.state.value,
        };
        var hasNotInDestructor = !this.includesContext(destructorContext) &&
            !this.isMatchPattern &&
            !this.isWildMatchPattern;
        this.next();
        if (this.includesContext(bracketArrayContext)) {
            if (this.state.type !== bracketRTok) {
                throw this.unexpect();
            }
            else {
                this.state.context.pop();
                this.next();
            }
        }
        else if (hasNotInDestructor) {
            this.pushSegments(node.value);
        }
        if (this.state.type === bracketLTok) {
            this.next();
            if (this.state.type !== nameTok) {
                throw this.unexpect();
            }
            this.state.context.push(bracketArrayContext);
            var isNumberKey = false;
            if (/^\d+$/.test(this.state.value)) {
                isNumberKey = true;
            }
            var value = this.state.value;
            this.pushSegments(isNumberKey ? Number(value) : value);
            var after = this.parseAtom(this.state.type);
            if (isNumberKey) {
                after.arrayIndex = true;
            }
            this.append(node, after);
        }
        else {
            this.append(node, this.parseAtom(this.state.type));
        }
        return node;
    };
    Parser.prototype.parseExpandOperator = function () {
        var node = {
            type: 'ExpandOperator',
        };
        this.isMatchPattern = true;
        this.isWildMatchPattern = true;
        this.data.segments = [];
        this.next();
        this.append(node, this.parseAtom(this.state.type));
        return node;
    };
    Parser.prototype.parseWildcardOperator = function () {
        var node = {
            type: 'WildcardOperator',
        };
        if (this.state.type === dbStarTok) {
            node.optional = true;
        }
        this.isMatchPattern = true;
        this.isWildMatchPattern = true;
        this.data.segments = [];
        this.next();
        if (this.state.type === parenLTok) {
            node.filter = this.parseGroupExpression(node);
        }
        else if (this.state.type === bracketLTok) {
            node.filter = this.parseRangeExpression(node);
        }
        this.append(node, this.parseAtom(this.state.type));
        return node;
    };
    Parser.prototype.parseDestructorExpression = function () {
        var _this = this;
        var node = {
            type: 'DestructorExpression',
        };
        this.state.context.push(destructorContext);
        var startPos = this.state.pos - 1;
        node.value =
            this.state.type === braceLTok
                ? this.parseObjectPattern()
                : this.parseArrayPattern();
        var endPos = this.state.pos;
        this.state.context.pop();
        node.source = this.input
            .substring(startPos, endPos)
            .replace(/\[\s*([\+\-\*\/])?\s*([^,\]\s]*)\s*\]/, function (match, operator, target) {
            if (_this.relative !== undefined) {
                if (operator) {
                    if (target) {
                        return calculate(_this.relative, target, operator);
                    }
                    else {
                        return calculate(_this.relative, 1, operator);
                    }
                }
                else {
                    if (target) {
                        return calculate(_this.relative, target, '+');
                    }
                    else {
                        return String(_this.relative);
                    }
                }
            }
            return match;
        })
            .replace(/\s*\.\s*/g, '')
            .replace(/\s*/g, '');
        if (this.relative === undefined) {
            setDestructor(node.source, parseDestructorRules(node));
        }
        this.relative = undefined;
        this.pushSegments(node.source);
        this.next();
        this.append(node, this.parseAtom(this.state.type));
        return node;
    };
    Parser.prototype.parseArrayPattern = function () {
        var node = {
            type: 'ArrayPattern',
            elements: [],
        };
        this.next();
        node.elements = this.parseArrayPatternElements();
        return node;
    };
    Parser.prototype.parseArrayPatternElements = function () {
        var nodes = [];
        while (this.state.type !== bracketRTok && this.state.type !== eofTok) {
            nodes.push(this.parseAtom(this.state.type));
            if (this.state.type === bracketRTok) {
                if (this.includesContext(destructorContext)) {
                    this.next();
                }
                return nodes;
            }
            this.next();
        }
        return nodes;
    };
    Parser.prototype.parseObjectPattern = function () {
        var node = {
            type: 'ObjectPattern',
            properties: [],
        };
        this.next();
        node.properties = this.parseObjectProperties();
        return node;
    };
    Parser.prototype.parseObjectProperties = function () {
        var nodes = [];
        while (this.state.type !== braceRTok && this.state.type !== eofTok) {
            var node = {
                type: 'ObjectPatternProperty',
                key: this.parseAtom(this.state.type),
            };
            nodes.push(node);
            if (this.state.type === colonTok) {
                this.next();
                node.value = this.parseAtom(this.state.type);
            }
            if (this.state.type === braceRTok) {
                if (this.includesContext(destructorContext)) {
                    this.next();
                }
                return nodes;
            }
            this.next();
        }
        return nodes;
    };
    Parser.prototype.parseDotOperator = function () {
        var node = {
            type: 'DotOperator',
        };
        var prevToken = this.type_;
        if (!prevToken && this.base) {
            if (this.base.isMatchPattern) {
                throw new Error('Base path must be an absolute path.');
            }
            this.data.segments = this.base.toArr();
            while (this.state.type === dotTok) {
                this.relative = this.data.segments.pop();
                this.haveRelativePattern = true;
                this.next();
            }
            return createTreeBySegments(this.data.segments.slice(), this.parseAtom(this.state.type));
        }
        else {
            this.next();
        }
        this.append(node, this.parseAtom(this.state.type));
        return node;
    };
    Parser.prototype.parseIgnoreExpression = function () {
        this.next();
        var value = String(this.state.value).replace(/\s*/g, '');
        var node = {
            type: 'IgnoreExpression',
            value: value,
        };
        this.pushSegments(value);
        this.next();
        this.append(node, this.parseAtom(this.state.type));
        this.next();
        return node;
    };
    Parser.prototype.parseGroupExpression = function (parent) {
        var node = {
            type: 'GroupExpression',
            value: [],
        };
        this.isMatchPattern = true;
        this.data.segments = [];
        this.next();
        loop: while (true) {
            switch (this.state.type) {
                case commaTok:
                    this.next();
                    break;
                case bangTok:
                    node.isExclude = true;
                    this.haveExcludePattern = true;
                    this.next();
                    break;
                case eofTok:
                    break loop;
                case parenRTok:
                    break loop;
                default:
                    node.value.push(this.parseAtom(this.state.type));
            }
        }
        this.next();
        this.append(parent, this.parseAtom(this.state.type));
        return node;
    };
    Parser.prototype.parseRangeExpression = function (parent) {
        var node = {
            type: 'RangeExpression',
        };
        this.next();
        this.isMatchPattern = true;
        this.data.segments = [];
        var start = false, hasColon = false;
        loop: while (true) {
            switch (this.state.type) {
                case colonTok:
                    hasColon = true;
                    start = true;
                    this.next();
                    break;
                case bracketRTok:
                    if (!hasColon && !node.end) {
                        node.end = node.start;
                    }
                    break loop;
                case commaTok:
                    // never reach
                    throw this.unexpect();
                case eofTok:
                    // never reach
                    break loop;
                default:
                    if (!start) {
                        node.start = this.parseAtom(this.state.type);
                    }
                    else {
                        node.end = this.parseAtom(this.state.type);
                    }
            }
        }
        this.next();
        this.append(parent, this.parseAtom(this.state.type));
        return node;
    };
    return Parser;
}(Tokenizer));

//# sourceMappingURL=parser.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/matcher.js


var Matcher = /** @class */ (function () {
    function Matcher(tree, record) {
        this.tree = tree;
        this.stack = [];
        this.excluding = false;
        this.wildcards = [];
        this.record = record;
    }
    Matcher.prototype.next = function (node, pos) {
        //  const isOverToken = pos > this.path.length
        if (node.after) {
            // if (isOverToken) {
            //   return false
            // }
            return this.matchNode(node.after, pos);
        }
        if (isWildcardOperator(node) && !node.filter) {
            if (this.excluding) {
                return false;
            }
            else {
                if (pos === 0 || node.optional)
                    return true;
                return !!this.take(pos);
            }
        }
        var isLastToken = pos === this.path.length - 1;
        if (isLastToken) {
            return !!this.take(pos);
        }
        else {
            var wildcard = this.wildcards.pop();
            if (wildcard && wildcard.after) {
                return this.next(wildcard, pos);
            }
        }
        return false;
    };
    Matcher.prototype.shot = function () {
        var _a;
        if (((_a = this.record) === null || _a === void 0 ? void 0 : _a.score) >= 0) {
            this.record.score++;
        }
    };
    Matcher.prototype.take = function (pos) {
        var _a;
        return String((_a = this.path[pos]) !== null && _a !== void 0 ? _a : '');
    };
    Matcher.prototype.matchExcludeIdentifier = function (matched, node, pos) {
        var isLastToken = pos === this.path.length - 1;
        var isContainToken = pos < this.path.length;
        if (!node.after) {
            this.excluding = false;
        }
        if (matched) {
            if (node.after) {
                return this.next(node, pos);
            }
            if (isLastToken) {
                return false;
            }
        }
        if (isLastToken) {
            return true;
        }
        return isContainToken;
    };
    Matcher.prototype.matchIdentifier = function (node, pos) {
        var current = this.take(pos);
        var matched = false;
        if (isExpandOperator(node.after)) {
            if (current.indexOf(node.value) === 0) {
                this.shot();
                matched = true;
            }
            if (this.excluding) {
                return this.matchExcludeIdentifier(matched, node.after, pos);
            }
            else {
                return matched && this.next(node.after, pos);
            }
        }
        else if (current === node.value) {
            this.shot();
            matched = true;
        }
        if (this.excluding) {
            return this.matchExcludeIdentifier(matched, node, pos);
        }
        else {
            return matched && this.next(node, pos);
        }
    };
    Matcher.prototype.matchIgnoreExpression = function (node, pos) {
        return shared_isEqual(node.value, this.take(pos)) && this.next(node, pos);
    };
    Matcher.prototype.matchDestructorExpression = function (node, pos) {
        return shared_isEqual(node.source, this.take(pos)) && this.next(node, pos);
    };
    Matcher.prototype.matchExpandOperator = function (node, pos) {
        return this.next(node, pos);
    };
    Matcher.prototype.matchWildcardOperator = function (node, pos) {
        var matched = false;
        if (node.filter) {
            this.stack.push(node);
            matched = this.matchNode(node.filter, pos);
            this.stack.pop();
        }
        else {
            matched = this.next(node, pos);
        }
        return matched;
    };
    Matcher.prototype.matchGroupExpression = function (node, pos) {
        var _this = this;
        var excluding = false;
        if (node.isExclude) {
            excluding = !this.excluding;
        }
        return shared_toArr(node.value)[excluding ? 'every' : 'some'](function (item) {
            _this.wildcards = _this.stack.slice();
            _this.excluding = excluding;
            return _this.matchNode(item, pos);
        });
    };
    Matcher.prototype.matchRangeExpression = function (node, pos) {
        var current = Number(this.take(pos));
        if (node.start) {
            if (node.end) {
                return (current >= Number(node.start.value) &&
                    current <= Number(node.end.value));
            }
            else {
                return current >= Number(node.start.value);
            }
        }
        else {
            if (node.end) {
                return current <= Number(node.end.value);
            }
            else {
                this.wildcards = this.stack.slice();
                return this.next(node, pos);
            }
        }
    };
    Matcher.prototype.matchNode = function (node, pos) {
        if (pos === void 0) { pos = 0; }
        if (isDotOperator(node)) {
            return this.next(node, pos + 1);
        }
        else if (isIdentifier(node)) {
            return this.matchIdentifier(node, pos);
        }
        else if (isIgnoreExpression(node)) {
            return this.matchIgnoreExpression(node, pos);
        }
        else if (isDestructorExpression(node)) {
            return this.matchDestructorExpression(node, pos);
        }
        else if (isExpandOperator(node)) {
            return this.matchExpandOperator(node, pos);
        }
        else if (isWildcardOperator(node)) {
            return this.matchWildcardOperator(node, pos);
        }
        else if (isGroupExpression(node)) {
            return this.matchGroupExpression(node, pos);
        }
        else if (isRangeExpression(node)) {
            return this.matchRangeExpression(node, pos);
        }
        return false;
    };
    Matcher.prototype.match = function (path) {
        this.path = path;
        return { matched: this.matchNode(this.tree), record: this.record };
    };
    Matcher.matchSegments = function (source, target, record) {
        if (source.length !== target.length)
            return { matched: false, record: record };
        var match = function (pos) {
            if (pos === void 0) { pos = 0; }
            var current = isSegmentEqual(source[pos], target[pos]);
            if ((record === null || record === void 0 ? void 0 : record.score) >= 0) {
                record.score++;
            }
            return current && (pos < source.length - 1 ? match(pos + 1) : true);
        };
        return { matched: match(), record: record };
    };
    return Matcher;
}());

//# sourceMappingURL=matcher.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+path@2.3.1/node_modules/@formily/path/esm/index.js
var esm_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var esm_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




var pathCache = new Map();
var isMatcher = Symbol('PATH_MATCHER');
var esm_isValid = function (val) { return val !== undefined && val !== null; };
var isSimplePath = function (val) {
    return val.indexOf('*') === -1 &&
        val.indexOf('~') === -1 &&
        val.indexOf('[') === -1 &&
        val.indexOf(']') === -1 &&
        val.indexOf(',') === -1 &&
        val.indexOf(':') === -1 &&
        val.indexOf(' ') === -1 &&
        val[0] !== '.';
};
var esm_isAssignable = function (val) {
    return typeof val === 'object' || typeof val === 'function';
};
var isNumberIndex = function (val) {
    return shared_isStr(val) ? /^\d+$/.test(val) : shared_isNum(val);
};
var getIn = function (segments, source) {
    for (var i = 0; i < segments.length; i++) {
        var index = segments[i];
        var rules = getDestructor(index);
        if (!rules) {
            if (!esm_isValid(source))
                return;
            source = source[index];
        }
        else {
            source = getInByDestructor(source, rules, { setIn: setIn, getIn: getIn });
            break;
        }
    }
    return source;
};
var setIn = function (segments, source, value) {
    for (var i = 0; i < segments.length; i++) {
        var index = segments[i];
        var rules = getDestructor(index);
        if (!rules) {
            if (!esm_isValid(source) || !esm_isAssignable(source))
                return;
            if (shared_isArr(source) && !isNumberIndex(index)) {
                return;
            }
            if (!esm_isValid(source[index])) {
                if (value === undefined) {
                    if (source[index] === null)
                        source[index] = value;
                    return;
                }
                if (i < segments.length - 1) {
                    source[index] = shared_isNum(segments[i + 1]) ? [] : {};
                }
            }
            if (i === segments.length - 1) {
                source[index] = value;
            }
            source = source[index];
        }
        else {
            setInByDestructor(source, rules, value, { setIn: setIn, getIn: getIn });
            break;
        }
    }
};
var deleteIn = function (segments, source) {
    for (var i = 0; i < segments.length; i++) {
        var index = segments[i];
        var rules = getDestructor(index);
        if (!rules) {
            if (i === segments.length - 1 && esm_isValid(source)) {
                delete source[index];
                return;
            }
            if (!esm_isValid(source) || !esm_isAssignable(source))
                return;
            source = source[index];
            if (!shared_isObj(source)) {
                return;
            }
        }
        else {
            deleteInByDestructor(source, rules, {
                setIn: setIn,
                getIn: getIn,
                deleteIn: deleteIn,
            });
            break;
        }
    }
};
var esm_hasOwnProperty = Object.prototype.hasOwnProperty;
var existIn = function (segments, source, start) {
    if (start instanceof Path) {
        start = start.length;
    }
    for (var i = start; i < segments.length; i++) {
        var index = segments[i];
        var rules = getDestructor(index);
        if (!rules) {
            if (i === segments.length - 1) {
                return esm_hasOwnProperty.call(source, index);
            }
            if (!esm_isValid(source) || !esm_isAssignable(source))
                return false;
            source = source[index];
            if (!shared_isObj(source)) {
                return false;
            }
        }
        else {
            return existInByDestructor(source, rules, start, {
                setIn: setIn,
                getIn: getIn,
                deleteIn: deleteIn,
                existIn: existIn,
            });
        }
    }
};
var parse = function (pattern, base) {
    if (pattern instanceof Path) {
        return {
            entire: pattern.entire,
            segments: pattern.segments.slice(),
            isRegExp: false,
            haveRelativePattern: pattern.haveRelativePattern,
            isWildMatchPattern: pattern.isWildMatchPattern,
            isMatchPattern: pattern.isMatchPattern,
            haveExcludePattern: pattern.haveExcludePattern,
            tree: pattern.tree,
        };
    }
    else if (shared_isStr(pattern)) {
        if (!pattern) {
            return {
                entire: '',
                segments: [],
                isRegExp: false,
                isWildMatchPattern: false,
                haveExcludePattern: false,
                isMatchPattern: false,
            };
        }
        if (isSimplePath(pattern)) {
            return {
                entire: pattern,
                segments: pattern.split('.'),
                isRegExp: false,
                isWildMatchPattern: false,
                haveExcludePattern: false,
                isMatchPattern: false,
            };
        }
        var parser = new Parser(pattern, Path.parse(base));
        var tree = parser.parse();
        if (!parser.isMatchPattern) {
            var segments = parser.data.segments;
            return {
                entire: segments.join('.'),
                segments: segments,
                tree: tree,
                isRegExp: false,
                haveRelativePattern: parser.haveRelativePattern,
                isWildMatchPattern: false,
                haveExcludePattern: false,
                isMatchPattern: false,
            };
        }
        else {
            return {
                entire: pattern,
                segments: [],
                isRegExp: false,
                haveRelativePattern: false,
                isWildMatchPattern: parser.isWildMatchPattern,
                haveExcludePattern: parser.haveExcludePattern,
                isMatchPattern: true,
                tree: tree,
            };
        }
    }
    else if (shared_isFn(pattern) && pattern[isMatcher]) {
        return parse(pattern['path']);
    }
    else if (shared_isArr(pattern)) {
        return {
            entire: pattern.join('.'),
            segments: pattern.reduce(function (buf, key) {
                return buf.concat(parseString(key));
            }, []),
            isRegExp: false,
            haveRelativePattern: false,
            isWildMatchPattern: false,
            haveExcludePattern: false,
            isMatchPattern: false,
        };
    }
    else if (shared_isRegExp(pattern)) {
        return {
            entire: pattern,
            segments: [],
            isRegExp: true,
            haveRelativePattern: false,
            isWildMatchPattern: false,
            haveExcludePattern: false,
            isMatchPattern: true,
        };
    }
    else {
        return {
            entire: '',
            isRegExp: false,
            segments: pattern !== undefined ? [pattern] : [],
            haveRelativePattern: false,
            isWildMatchPattern: false,
            haveExcludePattern: false,
            isMatchPattern: false,
        };
    }
};
var parseString = function (source) {
    if (shared_isStr(source)) {
        source = source.replace(/\s*/g, '');
        try {
            var _a = parse(source), segments = _a.segments, isMatchPattern = _a.isMatchPattern;
            return !isMatchPattern ? segments : source;
        }
        catch (e) {
            return source;
        }
    }
    else if (source instanceof Path) {
        return source.segments;
    }
    return source;
};
var Path = /** @class */ (function () {
    function Path(input, base) {
        var _this = this;
        this.concat = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be concat"));
            }
            var path = new Path('');
            path.segments = (_a = _this.segments).concat.apply(_a, esm_spreadArray([], esm_read(args.map(function (s) { return parseString(s); })), false));
            path.entire = path.segments.join('.');
            return path;
        };
        this.slice = function (start, end) {
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be slice"));
            }
            var path = new Path('');
            path.segments = _this.segments.slice(start, end);
            path.entire = path.segments.join('.');
            return path;
        };
        this.push = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return _this.concat.apply(_this, esm_spreadArray([], esm_read(items), false));
        };
        this.pop = function () {
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be pop"));
            }
            return new Path(_this.segments.slice(0, _this.segments.length - 1));
        };
        this.splice = function (start, deleteCount) {
            var items = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                items[_i - 2] = arguments[_i];
            }
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be splice"));
            }
            items = items.reduce(function (buf, item) { return buf.concat(parseString(item)); }, []);
            var segments_ = _this.segments.slice();
            segments_.splice.apply(segments_, esm_spreadArray([start, deleteCount], esm_read(items), false));
            return new Path(segments_);
        };
        this.forEach = function (callback) {
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be each"));
            }
            _this.segments.forEach(callback);
        };
        this.map = function (callback) {
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be map"));
            }
            return _this.segments.map(callback);
        };
        this.reduce = function (callback, initial) {
            if (_this.isMatchPattern || _this.isRegExp) {
                throw new Error("".concat(_this.entire, " cannot be reduce"));
            }
            return _this.segments.reduce(callback, initial);
        };
        this.parent = function () {
            return _this.slice(0, _this.length - 1);
        };
        this.includes = function (pattern) {
            var _a = Path.parse(pattern), entire = _a.entire, segments = _a.segments, isMatchPattern = _a.isMatchPattern;
            var cache = _this.includesCache.get(entire);
            if (cache !== undefined)
                return cache;
            var cacheWith = function (value) {
                _this.includesCache.set(entire, value);
                return value;
            };
            if (_this.isMatchPattern) {
                if (!isMatchPattern) {
                    return cacheWith(_this.match(segments));
                }
                else {
                    throw new Error("".concat(_this.entire, " cannot be used to match ").concat(entire));
                }
            }
            if (isMatchPattern) {
                throw new Error("".concat(_this.entire, " cannot be used to match ").concat(entire));
            }
            if (segments.length > _this.segments.length)
                return cacheWith(false);
            for (var i = 0; i < segments.length; i++) {
                if (!shared_isEqual(String(segments[i]), String(_this.segments[i]))) {
                    return cacheWith(false);
                }
            }
            return cacheWith(true);
        };
        this.transform = function (regexp, callback) {
            if (!shared_isFn(callback))
                return '';
            if (_this.isMatchPattern) {
                throw new Error("".concat(_this.entire, " cannot be transformed"));
            }
            var reg = new RegExp(regexp);
            var args = _this.segments.filter(function (key) {
                return reg.test(key);
            });
            return callback.apply(void 0, esm_spreadArray([], esm_read(args), false));
        };
        this.match = function (pattern) {
            var _a, _b;
            var path = Path.parse(pattern);
            var cache = _this.matchCache.get(path.entire);
            if (cache !== undefined) {
                if (cache.record && cache.record.score !== undefined) {
                    _this.matchScore = cache.record.score;
                }
                return cache.matched;
            }
            var cacheWith = function (value) {
                _this.matchCache.set(path.entire, value);
                return value;
            };
            if (path.isMatchPattern) {
                if (_this.isMatchPattern) {
                    throw new Error("".concat(path.entire, " cannot match ").concat(_this.entire));
                }
                else {
                    _this.matchScore = 0;
                    return cacheWith(path.match(_this.segments));
                }
            }
            else {
                if (_this.isMatchPattern) {
                    if (_this.isRegExp) {
                        try {
                            return (_b = (_a = _this['entire']) === null || _a === void 0 ? void 0 : _a['test']) === null || _b === void 0 ? void 0 : _b.call(_a, path.entire);
                        }
                        finally {
                            ;
                            _this.entire.lastIndex = 0;
                        }
                    }
                    var record = {
                        score: 0,
                    };
                    var result = cacheWith(new Matcher(_this.tree, record).match(path.segments));
                    _this.matchScore = record.score;
                    return result.matched;
                }
                else {
                    var record = {
                        score: 0,
                    };
                    var result = cacheWith(Matcher.matchSegments(_this.segments, path.segments, record));
                    _this.matchScore = record.score;
                    return result.matched;
                }
            }
        };
        //别名组匹配
        this.matchAliasGroup = function (name, alias) {
            var namePath = Path.parse(name);
            var aliasPath = Path.parse(alias);
            var nameMatched = _this.match(namePath);
            var nameMatchedScore = _this.matchScore;
            var aliasMatched = _this.match(aliasPath);
            var aliasMatchedScore = _this.matchScore;
            if (_this.haveExcludePattern) {
                if (nameMatchedScore >= aliasMatchedScore) {
                    return nameMatched;
                }
                else {
                    return aliasMatched;
                }
            }
            else {
                return nameMatched || aliasMatched;
            }
        };
        this.existIn = function (source, start) {
            if (start === void 0) { start = 0; }
            return existIn(_this.segments, source, start);
        };
        this.getIn = function (source) {
            return getIn(_this.segments, source);
        };
        this.setIn = function (source, value) {
            setIn(_this.segments, source, value);
            return source;
        };
        this.deleteIn = function (source) {
            deleteIn(_this.segments, source);
            return source;
        };
        this.ensureIn = function (source, defaults) {
            var results = _this.getIn(source);
            if (results === undefined) {
                _this.setIn(source, defaults);
                return _this.getIn(source);
            }
            return results;
        };
        var _a = parse(input, base), tree = _a.tree, segments = _a.segments, entire = _a.entire, isRegExp = _a.isRegExp, isMatchPattern = _a.isMatchPattern, isWildMatchPattern = _a.isWildMatchPattern, haveRelativePattern = _a.haveRelativePattern, haveExcludePattern = _a.haveExcludePattern;
        this.entire = entire;
        this.segments = segments;
        this.isMatchPattern = isMatchPattern;
        this.isWildMatchPattern = isWildMatchPattern;
        this.haveRelativePattern = haveRelativePattern;
        this.isRegExp = isRegExp;
        this.haveExcludePattern = haveExcludePattern;
        this.tree = tree;
        this.matchCache = new Map();
        this.includesCache = new Map();
    }
    Path.prototype.toString = function () {
        var _a;
        return (_a = this.entire) === null || _a === void 0 ? void 0 : _a.toString();
    };
    Path.prototype.toArr = function () {
        var _a;
        return (_a = this.segments) === null || _a === void 0 ? void 0 : _a.slice();
    };
    Object.defineProperty(Path.prototype, "length", {
        get: function () {
            return this.segments.length;
        },
        enumerable: false,
        configurable: true
    });
    Path.match = function (pattern) {
        var path = Path.parse(pattern);
        var matcher = function (target) {
            return path.match(target);
        };
        matcher[isMatcher] = true;
        matcher.path = path;
        return matcher;
    };
    Path.isPathPattern = function (target) {
        return !!(shared_isStr(target) ||
            shared_isArr(target) ||
            shared_isRegExp(target) ||
            (shared_isFn(target) && target[isMatcher]));
    };
    Path.transform = function (pattern, regexp, callback) {
        return Path.parse(pattern).transform(regexp, callback);
    };
    Path.parse = function (path, base) {
        if (path === void 0) { path = ''; }
        if (path instanceof Path) {
            var found = pathCache.get(path.entire);
            if (found) {
                return found;
            }
            else {
                pathCache.set(path.entire, path);
                return path;
            }
        }
        else if (path && path[isMatcher]) {
            return Path.parse(path['path']);
        }
        else {
            var key_ = base ? Path.parse(base) : '';
            var key = "".concat(path, ":").concat(key_);
            var found = pathCache.get(key);
            if (found) {
                return found;
            }
            else {
                path = new Path(path, base);
                pathCache.set(key, path);
                return path;
            }
        }
    };
    Path.getIn = function (source, pattern) {
        var path = Path.parse(pattern);
        return path.getIn(source);
    };
    Path.setIn = function (source, pattern, value) {
        var path = Path.parse(pattern);
        return path.setIn(source, value);
    };
    Path.deleteIn = function (source, pattern) {
        var path = Path.parse(pattern);
        return path.deleteIn(source);
    };
    Path.existIn = function (source, pattern, start) {
        var path = Path.parse(pattern);
        return path.existIn(source, start);
    };
    Path.ensureIn = function (source, pattern, defaultValue) {
        var path = Path.parse(pattern);
        return path.ensureIn(source, defaultValue);
    };
    return Path;
}());

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/path.js


//# sourceMappingURL=path.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/deprecate.js

var caches = {};
function deprecate(method, message, help) {
    if (isFn(method)) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        return function (p1, p2, p3, p4, p5) {
            deprecate(message, help);
            return method.apply(this, arguments);
        };
    }
    if (isStr(method) && !caches[method]) {
        caches[method] = true;
        console.warn(new Error("".concat(method, " has been deprecated. Do not continue to use this api.").concat(message || '')));
    }
}
//# sourceMappingURL=deprecate.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/subscribable.js


var Subscribable = /** @class */ (function () {
    function Subscribable() {
        var _this = this;
        this.subscribers = {
            index: 0,
        };
        this.subscribe = function (callback) {
            if (checkers_isFn(callback)) {
                var index = _this.subscribers.index + 1;
                _this.subscribers[index] = callback;
                _this.subscribers.index++;
                return index;
            }
        };
        this.unsubscribe = function (index) {
            if (_this.subscribers[index]) {
                delete _this.subscribers[index];
            }
            else if (!index) {
                _this.subscribers = {
                    index: 0,
                };
            }
        };
        this.notify = function (payload, silent) {
            if (_this.subscription) {
                if (_this.subscription && checkers_isFn(_this.subscription.notify)) {
                    if (_this.subscription.notify.call(_this, payload) === false) {
                        return;
                    }
                }
            }
            if (silent)
                return;
            var filter = function (payload) {
                if (_this.subscription && checkers_isFn(_this.subscription.filter)) {
                    return _this.subscription.filter.call(_this, payload);
                }
                return payload;
            };
            array_each(_this.subscribers, function (callback) {
                if (checkers_isFn(callback))
                    callback(filter(payload));
            });
        };
    }
    return Subscribable;
}());

//# sourceMappingURL=subscribable.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/middleware.js
var applyMiddleware = function (payload, fns) {
    if (fns === void 0) { fns = []; }
    var compose = function (payload, fns) {
        var prevPayload = payload;
        return Promise.resolve(fns[0](payload, function (payload) {
            return compose(payload !== null && payload !== void 0 ? payload : prevPayload, fns.slice(1));
        }));
    };
    return new Promise(function (resolve, reject) {
        compose(payload, fns.concat(function (payload) {
            resolve(payload);
        })).catch(reject);
    });
};
//# sourceMappingURL=middleware.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/merge.js


function defaultIsMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
}
function isNonNullObject(value) {
    // TODO: value !== null && typeof value === 'object'
    return Boolean(value) && typeof value === 'object';
}
function isSpecial(value) {
    // TODO: use isComplexObject()
    if ('$$typeof' in value && '_owner' in value) {
        return true;
    }
    if (value._isAMomentObject) {
        return true;
    }
    if (value._isJSONSchemaObject) {
        return true;
    }
    if (checkers_isFn(value.toJS)) {
        return true;
    }
    if (checkers_isFn(value.toJSON)) {
        return true;
    }
    return !checkers_isPlainObj(value);
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
// @ts-ignore
function cloneUnlessOtherwiseSpecified(value, options) {
    var _a;
    if (options.clone !== false && ((_a = options.isMergeableObject) === null || _a === void 0 ? void 0 : _a.call(options, value))) {
        return deepmerge(emptyTarget(value), value, options);
    }
    return value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) {
        return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols
        ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
            return target.propertyIsEnumerable(symbol);
        })
        : [];
}
function getKeys(target) {
    if (!isEmpty_isValid(target))
        return [];
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    /* istanbul ignore next */
    try {
        return property in object;
    }
    catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return (propertyIsOnObject(target, key) && // Properties are safe to merge if they don't exist in the target yet,
        !(Object.hasOwnProperty.call(target, key) && // unsafe if they exist up the prototype chain,
            Object.propertyIsEnumerable.call(target, key))); // and also unsafe if they're nonenumerable.
}
function mergeObject(target, source, options) {
    var destination = options.assign ? target || {} : {};
    if (!options.isMergeableObject(target))
        return target;
    if (!options.assign) {
        getKeys(target).forEach(function (key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
    }
    getKeys(source).forEach(function (key) {
        /* istanbul ignore next */
        if (propertyIsUnsafe(target, key)) {
            return;
        }
        if (isEmpty_isEmpty(target[key])) {
            destination[key] = source[key];
        }
        else if (propertyIsOnObject(target, key) &&
            // @ts-ignore
            options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        }
        else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
    });
    return destination;
}
// @ts-ignore
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject =
        options.isMergeableObject || defaultIsMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
    }
    else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
    }
    else {
        return mergeObject(target, source, options);
    }
}
var lazyMerge = function (target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var _lazyMerge = function (target, source) {
        if (!isEmpty_isValid(source))
            return target;
        if (!isEmpty_isValid(target))
            return source;
        var isTargetObject = typeof target === 'object';
        var isSourceObject = typeof source === 'object';
        var isTargetFn = typeof target === 'function';
        var isSourceFn = typeof source === 'function';
        if (!isTargetObject && !isTargetFn)
            return source;
        if (!isSourceObject && !isSourceFn)
            return target;
        var getTarget = function () { return (isTargetFn ? target() : target); };
        var getSource = function () { return (isSourceFn ? source() : source); };
        var set = function (_, key, value) {
            var source = getSource();
            var target = getTarget();
            if (key in source) {
                // @ts-ignore
                source[key] = value;
            }
            else if (key in target) {
                // @ts-ignore
                target[key] = value;
            }
            else {
                source[key] = value;
            }
            return true;
        };
        var get = function (_, key) {
            var source = getSource();
            // @ts-ignore
            if (key in source) {
                return source[key];
            }
            // @ts-ignore
            return getTarget()[key];
        };
        var ownKeys = function () {
            var source = getSource();
            var target = getTarget();
            var keys = Object.keys(target);
            for (var key in source) {
                if (!(key in target)) {
                    keys.push(key);
                }
            }
            return keys;
        };
        var getOwnPropertyDescriptor = function (_, key) { return ({
            value: get(_, key),
            enumerable: true,
            configurable: true,
        }); };
        var has = function (_, key) {
            if (key in getSource() || key in getTarget())
                return true;
            return false;
        };
        var getPrototypeOf = function () { return Object.getPrototypeOf({}); };
        return new Proxy(Object.create(null), {
            set: set,
            get: get,
            ownKeys: ownKeys,
            getPrototypeOf: getPrototypeOf,
            getOwnPropertyDescriptor: getOwnPropertyDescriptor,
            has: has,
        });
    };
    return args.reduce(function (buf, arg) { return _lazyMerge(buf, arg); }, target);
};
var merge = deepmerge;
//# sourceMappingURL=merge.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/defaults.js



var isUnNormalObject = function (value) {
    if ((value === null || value === void 0 ? void 0 : value._owner) && (value === null || value === void 0 ? void 0 : value.$$typeof)) {
        return true;
    }
    if ((value === null || value === void 0 ? void 0 : value._isAMomentObject) || (value === null || value === void 0 ? void 0 : value._isJSONSchemaObject)) {
        return true;
    }
    if ((value === null || value === void 0 ? void 0 : value.toJS) || (value === null || value === void 0 ? void 0 : value.toJSON)) {
        return true;
    }
};
var isEnumerableObject = function (val) {
    if (isUnNormalObject(val)) {
        return false;
    }
    return typeof val === 'object';
};
/**
 *
 * @param defaults
 * @param targets
 */
var defaults = function (defaults_, targets) {
    if (getType(defaults_) !== getType(targets) ||
        !isEnumerableObject(defaults_) ||
        !isEnumerableObject(targets)) {
        return !isEmpty(targets) ? targets : defaults_;
    }
    else {
        var results_1 = isArr(defaults_)
            ? []
            : isPlainObj(defaults_)
                ? {}
                : defaults_;
        each(targets, function (value, key) {
            results_1[key] = defaults(defaults_[key], value);
        });
        each(defaults_, function (value, key) {
            if (!isValid(results_1[key])) {
                results_1[key] = value;
            }
        });
        return results_1;
    }
};
//# sourceMappingURL=defaults.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/uid.js
var IDX = 36, HEX = '';
while (IDX--)
    HEX += IDX.toString(36);
function uid(len) {
    var str = '', num = len || 11;
    while (num--)
        str += HEX[(Math.random() * 36) | 0];
    return str;
}
//# sourceMappingURL=uid.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+shared@2.3.1/node_modules/@formily/shared/esm/index.js
















//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/LifeCycle.js

var LifeCycle = /** @class */ (function () {
    function LifeCycle() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _this = this;
        this.buildListener = function (params) {
            return function (payload, ctx) {
                var _this = this;
                for (var index = 0; index < params.length; index++) {
                    var item = params[index];
                    if (checkers_isFn(item)) {
                        item.call(this, payload, ctx);
                    }
                    else if (checkers_isStr(item) && checkers_isFn(params[index + 1])) {
                        if (item === payload.type) {
                            params[index + 1].call(this, payload.payload, ctx);
                        }
                        index++;
                    }
                    else {
                        array_each(item, function (handler, type) {
                            if (checkers_isFn(handler) && checkers_isStr(type)) {
                                if (type === payload.type) {
                                    handler.call(_this, payload.payload, ctx);
                                    return false;
                                }
                            }
                        });
                    }
                }
            };
        };
        this.notify = function (type, payload, ctx) {
            if (checkers_isStr(type)) {
                _this.listener.call(ctx, { type: type, payload: payload }, ctx);
            }
        };
        this.listener = this.buildListener(params);
    }
    return LifeCycle;
}());

//# sourceMappingURL=LifeCycle.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/Heart.js
var Heart_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Heart = /** @class */ (function (_super) {
    Heart_extends(Heart, _super);
    function Heart(_a) {
        var _b = _a === void 0 ? {} : _a, lifecycles = _b.lifecycles, context = _b.context;
        var _this = _super.call(this) || this;
        _this.lifecycles = [];
        _this.outerLifecycles = new Map();
        _this.buildLifeCycles = function (lifecycles) {
            return lifecycles.reduce(function (buf, item) {
                if (item instanceof LifeCycle) {
                    return buf.concat(item);
                }
                else {
                    if (checkers_isArr(item)) {
                        return _this.buildLifeCycles(item);
                    }
                    else if (typeof item === 'object') {
                        _this.context = item;
                        return buf;
                    }
                    return buf;
                }
            }, []);
        };
        _this.addLifeCycles = function (id, lifecycles) {
            if (lifecycles === void 0) { lifecycles = []; }
            var observers = _this.buildLifeCycles(lifecycles);
            if (observers.length) {
                _this.outerLifecycles.set(id, observers);
            }
        };
        _this.hasLifeCycles = function (id) {
            return _this.outerLifecycles.has(id);
        };
        _this.removeLifeCycles = function (id) {
            _this.outerLifecycles.delete(id);
        };
        _this.setLifeCycles = function (lifecycles) {
            if (lifecycles === void 0) { lifecycles = []; }
            _this.lifecycles = _this.buildLifeCycles(lifecycles);
        };
        _this.publish = function (type, payload, context) {
            if (checkers_isStr(type)) {
                _this.lifecycles.forEach(function (lifecycle) {
                    lifecycle.notify(type, payload, context || _this.context);
                });
                _this.outerLifecycles.forEach(function (lifecycles) {
                    lifecycles.forEach(function (lifecycle) {
                        lifecycle.notify(type, payload, context || _this.context);
                    });
                });
                _this.notify({
                    type: type,
                    payload: payload,
                });
            }
        };
        _this.clear = function () {
            _this.lifecycles = [];
            _this.outerLifecycles.clear();
            _this.unsubscribe();
        };
        _this.lifecycles = _this.buildLifeCycles(lifecycles || []);
        _this.context = context;
        return _this;
    }
    return Heart;
}(Subscribable));

//# sourceMappingURL=Heart.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/checkers.js
var esm_checkers_toString = Object.prototype.toString;
var checkers_isMap = function (val) {
    return val && val instanceof Map;
};
var checkers_isSet = function (val) { return val && val instanceof Set; };
var checkers_isWeakMap = function (val) {
    return val && val instanceof WeakMap;
};
var checkers_isWeakSet = function (val) {
    return val && val instanceof WeakSet;
};
var esm_checkers_isFn = function (val) { return typeof val === 'function'; };
var esm_checkers_isArr = Array.isArray;
var esm_checkers_isPlainObj = function (val) {
    return esm_checkers_toString.call(val) === '[object Object]';
};
var checkers_isValid = function (val) { return val !== null && val !== undefined; };
var isCollectionType = function (target) {
    return (checkers_isMap(target) || checkers_isWeakMap(target) || checkers_isSet(target) || checkers_isWeakSet(target));
};
var isNormalType = function (target) {
    return esm_checkers_isPlainObj(target) || esm_checkers_isArr(target);
};
//# sourceMappingURL=checkers.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/array.js
var toArray = function (value) {
    return Array.isArray(value)
        ? value
        : value !== undefined && value !== null
            ? [value]
            : [];
};
var ArraySet = /** @class */ (function () {
    function ArraySet(value) {
        if (value === void 0) { value = []; }
        this.forEachIndex = 0;
        this.value = value;
    }
    ArraySet.prototype.add = function (item) {
        if (!this.has(item)) {
            this.value.push(item);
        }
    };
    ArraySet.prototype.has = function (item) {
        return this.value.indexOf(item) > -1;
    };
    ArraySet.prototype.delete = function (item) {
        var len = this.value.length;
        if (len === 0)
            return;
        if (len === 1 && this.value[0] === item) {
            this.value = [];
            return;
        }
        var findIndex = this.value.indexOf(item);
        if (findIndex > -1) {
            this.value.splice(findIndex, 1);
            if (findIndex <= this.forEachIndex) {
                this.forEachIndex -= 1;
            }
        }
    };
    ArraySet.prototype.forEach = function (callback) {
        if (this.value.length === 0)
            return;
        this.forEachIndex = 0;
        for (; this.forEachIndex < this.value.length; this.forEachIndex++) {
            callback(this.value[this.forEachIndex]);
        }
    };
    ArraySet.prototype.batchDelete = function (callback) {
        if (this.value.length === 0)
            return;
        this.forEachIndex = 0;
        for (; this.forEachIndex < this.value.length; this.forEachIndex++) {
            var value = this.value[this.forEachIndex];
            this.value.splice(this.forEachIndex, 1);
            this.forEachIndex--;
            callback(value);
        }
    };
    ArraySet.prototype.clear = function () {
        this.value.length = 0;
    };
    return ArraySet;
}());

//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/environment.js

var ProxyRaw = new WeakMap();
var RawProxy = new WeakMap();
var RawShallowProxy = new WeakMap();
var RawNode = new WeakMap();
var RawReactionsMap = new WeakMap();
var ReactionStack = [];
var BatchCount = { value: 0 };
var UntrackCount = { value: 0 };
var BatchScope = { value: false };
var environment_DependencyCollected = { value: false };
var PendingReactions = new ArraySet();
var PendingScopeReactions = new ArraySet();
var BatchEndpoints = new ArraySet();
var environment_ObserverListeners = new ArraySet();
var MakeObModelSymbol = Symbol('MakeObModelSymbol');
var ObModelSymbol = Symbol('ObModelSymbol');
var ObModelNodeSymbol = Symbol('ObModelNodeSymbol');
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/reaction.js



var ITERATION_KEY = Symbol('iteration key');
var addRawReactionsMap = function (target, key, reaction) {
    var reactionsMap = RawReactionsMap.get(target);
    if (reactionsMap) {
        var reactions = reactionsMap.get(key);
        if (reactions) {
            reactions.add(reaction);
        }
        else {
            reactionsMap.set(key, new ArraySet([reaction]));
        }
        return reactionsMap;
    }
    else {
        var reactionsMap_1 = new Map([
            [key, new ArraySet([reaction])],
        ]);
        RawReactionsMap.set(target, reactionsMap_1);
        return reactionsMap_1;
    }
};
var addReactionsMapToReaction = function (reaction, reactionsMap) {
    var bindSet = reaction._reactionsSet;
    if (bindSet) {
        bindSet.add(reactionsMap);
    }
    else {
        reaction._reactionsSet = new ArraySet([reactionsMap]);
    }
    return bindSet;
};
var getReactionsFromTargetKey = function (target, key) {
    var reactionsMap = RawReactionsMap.get(target);
    var reactions = [];
    if (reactionsMap) {
        var map = reactionsMap.get(key);
        if (map) {
            map.forEach(function (reaction) {
                if (reactions.indexOf(reaction) === -1) {
                    reactions.push(reaction);
                }
            });
        }
    }
    return reactions;
};
var runReactions = function (target, key) {
    var reactions = getReactionsFromTargetKey(target, key);
    var prevUntrackCount = UntrackCount.value;
    UntrackCount.value = 0;
    for (var i = 0, len = reactions.length; i < len; i++) {
        var reaction = reactions[i];
        if (reaction._isComputed) {
            reaction._scheduler(reaction);
        }
        else if (isScopeBatching()) {
            PendingScopeReactions.add(reaction);
        }
        else if (isBatching()) {
            PendingReactions.add(reaction);
        }
        else {
            // never reach
            if (esm_checkers_isFn(reaction._scheduler)) {
                reaction._scheduler(reaction);
            }
            else {
                reaction();
            }
        }
    }
    UntrackCount.value = prevUntrackCount;
};
var notifyObservers = function (operation) {
    environment_ObserverListeners.forEach(function (fn) { return fn(operation); });
};
var bindTargetKeyWithCurrentReaction = function (operation) {
    var key = operation.key, type = operation.type, target = operation.target;
    if (type === 'iterate') {
        key = ITERATION_KEY;
    }
    var reactionLen = ReactionStack.length;
    if (reactionLen === 0)
        return;
    var current = ReactionStack[reactionLen - 1];
    if (isUntracking())
        return;
    if (current) {
        environment_DependencyCollected.value = true;
        addReactionsMapToReaction(current, addRawReactionsMap(target, key, current));
    }
};
var bindComputedReactions = function (reaction) {
    if (esm_checkers_isFn(reaction)) {
        var current = ReactionStack[ReactionStack.length - 1];
        if (current) {
            var computes = current._computesSet;
            if (computes) {
                computes.add(reaction);
            }
            else {
                current._computesSet = new ArraySet([reaction]);
            }
        }
    }
};
var runReactionsFromTargetKey = function (operation) {
    var key = operation.key, type = operation.type, target = operation.target, oldTarget = operation.oldTarget;
    batchStart();
    notifyObservers(operation);
    if (type === 'clear') {
        oldTarget.forEach(function (_, key) {
            runReactions(target, key);
        });
    }
    else {
        runReactions(target, key);
    }
    if (type === 'add' || type === 'delete' || type === 'clear') {
        var newKey = Array.isArray(target) ? 'length' : ITERATION_KEY;
        runReactions(target, newKey);
    }
    batchEnd();
};
var hasRunningReaction = function () {
    return ReactionStack.length > 0;
};
var releaseBindingReactions = function (reaction) {
    var _a;
    (_a = reaction._reactionsSet) === null || _a === void 0 ? void 0 : _a.forEach(function (reactionsMap) {
        reactionsMap.forEach(function (reactions) {
            reactions.delete(reaction);
        });
    });
    PendingReactions.delete(reaction);
    PendingScopeReactions.delete(reaction);
    delete reaction._reactionsSet;
};
var suspendComputedReactions = function (current) {
    var _a;
    (_a = current._computesSet) === null || _a === void 0 ? void 0 : _a.forEach(function (reaction) {
        var reactions = getReactionsFromTargetKey(reaction._context, reaction._property);
        if (reactions.length === 0) {
            disposeBindingReactions(reaction);
            reaction._dirty = true;
        }
    });
};
var disposeBindingReactions = function (reaction) {
    reaction._disposed = true;
    releaseBindingReactions(reaction);
    suspendComputedReactions(reaction);
};
var batchStart = function () {
    BatchCount.value++;
};
var batchEnd = function () {
    BatchCount.value--;
    if (BatchCount.value === 0) {
        var prevUntrackCount = UntrackCount.value;
        UntrackCount.value = 0;
        executePendingReactions();
        executeBatchEndpoints();
        UntrackCount.value = prevUntrackCount;
    }
};
var batchScopeStart = function () {
    BatchScope.value = true;
};
var batchScopeEnd = function () {
    var prevUntrackCount = UntrackCount.value;
    BatchScope.value = false;
    UntrackCount.value = 0;
    PendingScopeReactions.batchDelete(function (reaction) {
        if (esm_checkers_isFn(reaction._scheduler)) {
            reaction._scheduler(reaction);
        }
        else {
            reaction();
        }
    });
    UntrackCount.value = prevUntrackCount;
};
var untrackStart = function () {
    UntrackCount.value++;
};
var untrackEnd = function () {
    UntrackCount.value--;
};
var isBatching = function () { return BatchCount.value > 0; };
var isScopeBatching = function () { return BatchScope.value; };
var isUntracking = function () { return UntrackCount.value > 0; };
var executePendingReactions = function () {
    PendingReactions.batchDelete(function (reaction) {
        if (esm_checkers_isFn(reaction._scheduler)) {
            reaction._scheduler(reaction);
        }
        else {
            reaction();
        }
    });
};
var executeBatchEndpoints = function () {
    BatchEndpoints.batchDelete(function (callback) {
        callback();
    });
};
var hasDepsChange = function (newDeps, oldDeps) {
    if (newDeps === oldDeps)
        return false;
    if (newDeps.length !== oldDeps.length)
        return true;
    if (newDeps.some(function (value, index) { return value !== oldDeps[index]; }))
        return true;
    return false;
};
var disposeEffects = function (reaction) {
    if (reaction._effects) {
        try {
            batchStart();
            reaction._effects.queue.forEach(function (item) {
                if (!item || !item.dispose)
                    return;
                item.dispose();
            });
        }
        finally {
            batchEnd();
        }
    }
};
//# sourceMappingURL=reaction.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/tree.js


var tree_DataChange = /** @class */ (function () {
    function DataChange(operation, node) {
        this.node = node;
        this.key = operation.key;
        this.type = operation.type;
        this.object = operation.target;
        this.value = operation.value;
        this.oldValue = operation.oldValue;
    }
    Object.defineProperty(DataChange.prototype, "path", {
        get: function () {
            return this.node.path.concat(this.key);
        },
        enumerable: false,
        configurable: true
    });
    return DataChange;
}());

var DataNode = /** @class */ (function () {
    function DataNode(target, key, value) {
        this.target = target;
        this.key = key;
        this.value = value;
    }
    Object.defineProperty(DataNode.prototype, "path", {
        get: function () {
            if (!this.parent)
                return this.key ? [this.key] : [];
            return this.parent.path.concat(this.key);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataNode.prototype, "targetRaw", {
        get: function () {
            return externals_raw(this.target);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataNode.prototype, "parent", {
        get: function () {
            if (!this.target)
                return;
            return tree_getDataNode(this.targetRaw);
        },
        enumerable: false,
        configurable: true
    });
    DataNode.prototype.isEqual = function (node) {
        if (this.key) {
            return node.targetRaw === this.targetRaw && node.key === this.key;
        }
        return node.value === this.value;
    };
    DataNode.prototype.contains = function (node) {
        if (node === this)
            return true;
        var parent = node.parent;
        while (!!parent) {
            if (this.isEqual(parent))
                return true;
            parent = parent.parent;
        }
        return false;
    };
    return DataNode;
}());

var tree_getDataNode = function (raw) {
    if (raw === null || raw === void 0 ? void 0 : raw[ObModelNodeSymbol]) {
        return raw[ObModelNodeSymbol];
    }
    return RawNode.get(raw);
};
var setDataNode = function (raw, node) {
    if (raw === null || raw === void 0 ? void 0 : raw[ObModelSymbol]) {
        raw[ObModelNodeSymbol] = node;
        return;
    }
    RawNode.set(raw, node);
};
var buildDataTree = function (target, key, value) {
    var raw = externals_raw(value);
    var currentNode = tree_getDataNode(raw);
    if (currentNode)
        return currentNode;
    setDataNode(raw, new DataNode(target, key, value));
};
//# sourceMappingURL=tree.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/externals.js



var RAW_TYPE = Symbol('RAW_TYPE');
var OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE');
var externals_hasOwnProperty = Object.prototype.hasOwnProperty;
var isObservable = function (target) {
    return ProxyRaw.has(target) || !!(target === null || target === void 0 ? void 0 : target[ObModelSymbol]);
};
var isAnnotation = function (target) {
    return target && !!target[MakeObModelSymbol];
};
var isSupportObservable = function (target) {
    if (!checkers_isValid(target))
        return false;
    if (esm_checkers_isArr(target))
        return true;
    if (esm_checkers_isPlainObj(target)) {
        if (target[RAW_TYPE]) {
            return false;
        }
        if (target[OBSERVABLE_TYPE]) {
            return true;
        }
        if ('$$typeof' in target && '_owner' in target) {
            return false;
        }
        if (target['_isAMomentObject']) {
            return false;
        }
        if (target['_isJSONSchemaObject']) {
            return false;
        }
        if (esm_checkers_isFn(target['toJS'])) {
            return false;
        }
        if (esm_checkers_isFn(target['toJSON'])) {
            return false;
        }
        return true;
    }
    if (checkers_isMap(target) || checkers_isWeakMap(target) || checkers_isSet(target) || checkers_isWeakSet(target))
        return true;
    return false;
};
var markRaw = function (target) {
    if (!target)
        return;
    if (esm_checkers_isFn(target)) {
        target.prototype[RAW_TYPE] = true;
    }
    else {
        target[RAW_TYPE] = true;
    }
    return target;
};
var markObservable = function (target) {
    if (!target)
        return;
    if (isFn(target)) {
        target.prototype[OBSERVABLE_TYPE] = true;
    }
    else {
        target[OBSERVABLE_TYPE] = true;
    }
    return target;
};
var externals_raw = function (target) {
    if (target === null || target === void 0 ? void 0 : target[ObModelSymbol])
        return target[ObModelSymbol];
    return ProxyRaw.get(target) || target;
};
var toJS = function (values) {
    var visited = new WeakSet();
    var _toJS = function (values) {
        if (visited.has(values)) {
            return values;
        }
        if (values && values[RAW_TYPE])
            return values;
        if (esm_checkers_isArr(values)) {
            if (isObservable(values)) {
                visited.add(values);
                var res_1 = [];
                values.forEach(function (item) {
                    res_1.push(_toJS(item));
                });
                visited.delete(values);
                return res_1;
            }
        }
        else if (esm_checkers_isPlainObj(values)) {
            if (isObservable(values)) {
                visited.add(values);
                var res = {};
                for (var key in values) {
                    if (externals_hasOwnProperty.call(values, key)) {
                        res[key] = _toJS(values[key]);
                    }
                }
                visited.delete(values);
                return res;
            }
        }
        return values;
    };
    return _toJS(values);
};
var contains = function (target, property) {
    var targetRaw = externals_raw(target);
    var propertyRaw = externals_raw(property);
    if (targetRaw === propertyRaw)
        return true;
    var targetNode = tree_getDataNode(targetRaw);
    var propertyNode = tree_getDataNode(propertyRaw);
    if (!targetNode)
        return false;
    if (!propertyNode)
        return false;
    return targetNode.contains(propertyNode);
};
var hasCollected = function (callback) {
    environment_DependencyCollected.value = false;
    callback === null || callback === void 0 ? void 0 : callback();
    return environment_DependencyCollected.value;
};
//# sourceMappingURL=externals.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/handlers.js
var handlers_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var handlers_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;




var wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol).reduce(function (buf, key) {
    if (key === 'arguments' || key === 'caller')
        return buf;
    var value = Symbol[key];
    if (typeof value === 'symbol')
        return buf.concat(value);
    return buf;
}, []));
var handlers_hasOwnProperty = Object.prototype.hasOwnProperty;
function findObservable(target, key, value) {
    var observableObj = RawProxy.get(value);
    if (observableObj) {
        return observableObj;
    }
    if (!isObservable(value) && isSupportObservable(value)) {
        return createObservable(target, key, value);
    }
    return value;
}
function patchIterator(target, key, iterator, isEntries) {
    var originalNext = iterator.next;
    iterator.next = function () {
        var _a = originalNext.call(iterator), done = _a.done, value = _a.value;
        if (!done) {
            if (isEntries) {
                value[1] = findObservable(target, key, value[1]);
            }
            else {
                value = findObservable(target, key, value);
            }
        }
        return { done: done, value: value };
    };
    return iterator;
}
var instrumentations = (_a = {
        has: function (key) {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'has' });
            return proto.has.apply(target, arguments);
        },
        get: function (key) {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'get' });
            return findObservable(target, key, proto.get.apply(target, arguments));
        },
        add: function (key) {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadKey = proto.has.call(target, key);
            // forward the operation before queueing reactions
            var result = proto.add.apply(target, arguments);
            if (!hadKey) {
                runReactionsFromTargetKey({ target: target, key: key, value: key, type: 'add' });
            }
            return result;
        },
        set: function (key, value) {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadKey = proto.has.call(target, key);
            var oldValue = proto.get.call(target, key);
            // forward the operation before queueing reactions
            var result = proto.set.apply(target, arguments);
            if (!hadKey) {
                runReactionsFromTargetKey({ target: target, key: key, value: value, type: 'add' });
            }
            else if (value !== oldValue) {
                runReactionsFromTargetKey({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });
            }
            return result;
        },
        delete: function (key) {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadKey = proto.has.call(target, key);
            var oldValue = proto.get ? proto.get.call(target, key) : undefined;
            // forward the operation before queueing reactions
            var result = proto.delete.apply(target, arguments);
            if (hadKey) {
                runReactionsFromTargetKey({ target: target, key: key, oldValue: oldValue, type: 'delete' });
            }
            return result;
        },
        clear: function () {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadItems = target.size !== 0;
            var oldTarget = target instanceof Map ? new Map(target) : new Set(target);
            // forward the operation before queueing reactions
            var result = proto.clear.apply(target, arguments);
            if (hadItems) {
                runReactionsFromTargetKey({ target: target, oldTarget: oldTarget, type: 'clear' });
            }
            return result;
        },
        forEach: function (cb) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            // swap out the raw values with their observable pairs
            // before passing them to the callback
            var wrappedCb = function (value, key) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                return cb.apply(void 0, handlers_spreadArray([findObservable(target, key, value), key], handlers_read(args), false));
            };
            return (_a = proto.forEach).call.apply(_a, handlers_spreadArray([target, wrappedCb], handlers_read(args), false));
        },
        keys: function () {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            return proto.keys.apply(target, arguments);
        },
        values: function () {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            var iterator = proto.values.apply(target, arguments);
            return patchIterator(target, '', iterator, false);
        },
        entries: function () {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            var iterator = proto.entries.apply(target, arguments);
            return patchIterator(target, '', iterator, true);
        }
    },
    _a[Symbol.iterator] = function () {
        var target = ProxyRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
        var iterator = proto[Symbol.iterator].apply(target, arguments);
        return patchIterator(target, '', iterator, target instanceof Map);
    },
    Object.defineProperty(_a, "size", {
        get: function () {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            return Reflect.get(proto, 'size', target);
        },
        enumerable: false,
        configurable: true
    }),
    _a);
var collectionHandlers = {
    get: function (target, key, receiver) {
        // instrument methods and property accessors to be reactive
        target = handlers_hasOwnProperty.call(instrumentations, key)
            ? instrumentations
            : target;
        return Reflect.get(target, key, receiver);
    },
};
var baseHandlers = {
    get: function (target, key, receiver) {
        if (!key)
            return;
        var result = target[key]; // use Reflect.get is too slow
        if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {
            return result;
        }
        bindTargetKeyWithCurrentReaction({ target: target, key: key, receiver: receiver, type: 'get' });
        var observableResult = RawProxy.get(result);
        if (observableResult) {
            return observableResult;
        }
        if (!isObservable(result) && isSupportObservable(result)) {
            var descriptor = Reflect.getOwnPropertyDescriptor(target, key);
            if (!descriptor ||
                !(descriptor.writable === false && descriptor.configurable === false)) {
                return createObservable(target, key, result);
            }
        }
        return result;
    },
    has: function (target, key) {
        var result = Reflect.has(target, key);
        bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'has' });
        return result;
    },
    ownKeys: function (target) {
        var keys = Reflect.ownKeys(target);
        bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
        return keys;
    },
    set: function (target, key, value, receiver) {
        // vue2中有对数组原型重写，因此需去除此处proxy
        if (key === '__proto__') {
            target[key] = value;
            return true;
        }
        var hadKey = handlers_hasOwnProperty.call(target, key);
        var newValue = createObservable(target, key, value);
        var oldValue = target[key];
        target[key] = newValue; // use Reflect.set is too slow
        if (!hadKey) {
            runReactionsFromTargetKey({
                target: target,
                key: key,
                value: newValue,
                oldValue: oldValue,
                receiver: receiver,
                type: 'add',
            });
        }
        else if (value !== oldValue) {
            runReactionsFromTargetKey({
                target: target,
                key: key,
                value: newValue,
                oldValue: oldValue,
                receiver: receiver,
                type: 'set',
            });
        }
        return true;
    },
    deleteProperty: function (target, key) {
        var oldValue = target[key];
        delete target[key];
        runReactionsFromTargetKey({
            target: target,
            key: key,
            oldValue: oldValue,
            type: 'delete',
        });
        return true;
    },
};
//# sourceMappingURL=handlers.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/internals.js





var createNormalProxy = function (target, shallow) {
    var proxy = new Proxy(target, baseHandlers);
    ProxyRaw.set(proxy, target);
    if (shallow) {
        RawShallowProxy.set(target, proxy);
    }
    else {
        RawProxy.set(target, proxy);
    }
    return proxy;
};
var createCollectionProxy = function (target, shallow) {
    var proxy = new Proxy(target, collectionHandlers);
    ProxyRaw.set(proxy, target);
    if (shallow) {
        RawShallowProxy.set(target, proxy);
    }
    else {
        RawProxy.set(target, proxy);
    }
    return proxy;
};
var createShallowProxy = function (target) {
    if (isNormalType(target))
        return createNormalProxy(target, true);
    if (isCollectionType(target))
        return createCollectionProxy(target, true);
    // never reach
    return target;
};
var createObservable = function (target, key, value, shallow) {
    if (typeof value !== 'object')
        return value;
    var raw = ProxyRaw.get(value);
    if (!!raw) {
        var node = tree_getDataNode(raw);
        if (!node.target)
            node.target = target;
        node.key = key;
        return value;
    }
    if (!isSupportObservable(value))
        return value;
    if (target) {
        var parentRaw = ProxyRaw.get(target) || target;
        var isShallowParent = RawShallowProxy.get(parentRaw);
        if (isShallowParent)
            return value;
    }
    buildDataTree(target, key, value);
    if (shallow)
        return createShallowProxy(value);
    if (isNormalType(value))
        return createNormalProxy(value);
    if (isCollectionType(value))
        return createCollectionProxy(value);
    // never reach
    return value;
};
var createAnnotation = function (maker) {
    var annotation = function (target) {
        return maker({ value: target });
    };
    if (esm_checkers_isFn(maker)) {
        annotation[MakeObModelSymbol] = maker;
    }
    return annotation;
};
var getObservableMaker = function (target) {
    if (target[MakeObModelSymbol]) {
        if (!target[MakeObModelSymbol][MakeObModelSymbol]) {
            return target[MakeObModelSymbol];
        }
        return getObservableMaker(target[MakeObModelSymbol]);
    }
};
var createBoundaryFunction = function (start, end) {
    function boundary(fn) {
        var results;
        try {
            start();
            if (esm_checkers_isFn(fn)) {
                results = fn();
            }
        }
        finally {
            end();
        }
        return results;
    }
    boundary.bound = createBindFunction(boundary);
    return boundary;
};
var createBindFunction = function (boundary) {
    function bind(callback, context) {
        return (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return boundary(function () { return callback.apply(context, args); });
        });
    }
    return bind;
};
var createBoundaryAnnotation = function (start, end) {
    var boundary = createBoundaryFunction(start, end);
    var annotation = createAnnotation(function (_a) {
        var target = _a.target, key = _a.key;
        target[key] = boundary.bound(target[key], target);
        return target;
    });
    boundary[MakeObModelSymbol] = annotation;
    boundary.bound[MakeObModelSymbol] = annotation;
    return boundary;
};
//# sourceMappingURL=internals.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/batch.js




var batch = createBoundaryAnnotation(batchStart, batchEnd);
batch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd);
batch.endpoint = function (callback) {
    if (!esm_checkers_isFn(callback))
        return;
    if (BatchCount.value === 0) {
        callback();
    }
    else {
        BatchEndpoints.add(callback);
    }
};
//# sourceMappingURL=batch.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/action.js


var action_action = createBoundaryAnnotation(function () {
    batchStart();
    untrackStart();
}, function () {
    untrackEnd();
    batchEnd();
});
action_action.scope = createBoundaryAnnotation(function () {
    batchScopeStart();
    untrackStart();
}, function () {
    untrackEnd();
    batchScopeEnd();
});
//# sourceMappingURL=action.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/untracked.js


var untracked = createBoundaryFunction(untrackStart, untrackEnd);
//# sourceMappingURL=untracked.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/annotations/observable.js


var observable_observable = createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: createObservable(target, key, target ? target[key] : value),
    };
    function get() {
        bindTargetKeyWithCurrentReaction({
            target: target,
            key: key,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        value = createObservable(target, key, value);
        store.value = value;
        if (oldValue === value)
            return;
        runReactionsFromTargetKey({
            target: target,
            key: key,
            type: 'set',
            oldValue: oldValue,
            value: value,
        });
    }
    if (target) {
        Object.defineProperty(target, key, {
            set: set,
            get: get,
            enumerable: true,
            configurable: false,
        });
        return target;
    }
    return store.value;
});
//# sourceMappingURL=observable.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/annotations/box.js




var box = createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: target ? target[key] : value,
    };
    var proxy = {
        set: set,
        get: get,
    };
    ProxyRaw.set(proxy, store);
    RawProxy.set(store, proxy);
    buildDataTree(target, key, store);
    function get() {
        bindTargetKeyWithCurrentReaction({
            target: store,
            key: key,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        store.value = value;
        if (oldValue !== value) {
            runReactionsFromTargetKey({
                target: store,
                key: key,
                type: 'set',
                oldValue: oldValue,
                value: value,
            });
        }
    }
    if (target) {
        Object.defineProperty(target, key, {
            value: proxy,
            enumerable: true,
            configurable: false,
            writable: false,
        });
        return target;
    }
    return proxy;
});
//# sourceMappingURL=box.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/annotations/ref.js




var ref = createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: target ? target[key] : value,
    };
    var proxy = {};
    var context = target ? target : store;
    var property = target ? key : 'value';
    function get() {
        bindTargetKeyWithCurrentReaction({
            target: context,
            key: property,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        store.value = value;
        if (oldValue !== value) {
            runReactionsFromTargetKey({
                target: context,
                key: property,
                type: 'set',
                oldValue: oldValue,
                value: value,
            });
        }
    }
    if (target) {
        Object.defineProperty(target, key, {
            get: get,
            set: set,
            enumerable: true,
        });
        return target;
    }
    else {
        Object.defineProperty(proxy, 'value', {
            set: set,
            get: get,
        });
        buildDataTree(target, key, store);
        proxy[ObModelSymbol] = store;
    }
    return proxy;
});
//# sourceMappingURL=ref.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/annotations/shallow.js


var shallow = createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: createObservable(target, key, target ? target[key] : value, true),
    };
    function get() {
        bindTargetKeyWithCurrentReaction({
            target: target,
            key: key,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        value = createObservable(target, key, value, true);
        store.value = value;
        if (oldValue === value)
            return;
        runReactionsFromTargetKey({
            target: target,
            key: key,
            type: 'set',
            oldValue: oldValue,
            value: value,
        });
    }
    if (target) {
        Object.defineProperty(target, key, {
            set: set,
            get: get,
            enumerable: true,
            configurable: false,
        });
        return target;
    }
    return store.value;
});
//# sourceMappingURL=shallow.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/annotations/computed.js





var getDescriptor = Object.getOwnPropertyDescriptor;
var getProto = Object.getPrototypeOf;
var ClassDescriptorSymbol = Symbol('ClassDescriptorSymbol');
function getPropertyDescriptor(obj, key) {
    if (!obj)
        return;
    return getDescriptor(obj, key) || getPropertyDescriptor(getProto(obj), key);
}
function getPropertyDescriptorCache(obj, key) {
    var constructor = obj.constructor;
    if (constructor === Object || constructor === Array)
        return getPropertyDescriptor(obj, key);
    var cache = constructor[ClassDescriptorSymbol] || {};
    var descriptor = cache[key];
    if (descriptor)
        return descriptor;
    var newDesc = getPropertyDescriptor(obj, key);
    constructor[ClassDescriptorSymbol] = cache;
    cache[key] = newDesc;
    return newDesc;
}
function getPrototypeDescriptor(target, key, value) {
    if (!target) {
        if (value) {
            if (esm_checkers_isFn(value)) {
                return { get: value };
            }
            else {
                return value;
            }
        }
        return {};
    }
    var descriptor = getPropertyDescriptorCache(target, key);
    if (descriptor) {
        return descriptor;
    }
    return {};
}
var computed = createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {};
    var proxy = {};
    var context = target ? target : store;
    var property = target ? key : 'value';
    var descriptor = getPrototypeDescriptor(target, property, value);
    function compute() {
        var _a;
        store.value = (_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(context);
    }
    function reaction() {
        if (ReactionStack.indexOf(reaction) === -1) {
            releaseBindingReactions(reaction);
            try {
                ReactionStack.push(reaction);
                compute();
            }
            finally {
                ReactionStack.pop();
            }
        }
    }
    reaction._name = 'ComputedReaction';
    reaction._scheduler = function () {
        reaction._dirty = true;
        runReactionsFromTargetKey({
            target: context,
            key: property,
            value: store.value,
            type: 'set',
        });
    };
    reaction._isComputed = true;
    reaction._dirty = true;
    reaction._context = context;
    reaction._property = property;
    function get() {
        if (hasRunningReaction()) {
            bindComputedReactions(reaction);
        }
        if (!isUntracking()) {
            //如果允许untracked过程中收集依赖，那么永远不会存在绑定，因为_dirty已经设置为false
            if (reaction._dirty) {
                reaction();
                reaction._dirty = false;
            }
        }
        else {
            compute();
        }
        bindTargetKeyWithCurrentReaction({
            target: context,
            key: property,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var _a;
        try {
            batchStart();
            (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call(context, value);
        }
        finally {
            batchEnd();
        }
    }
    if (target) {
        Object.defineProperty(target, key, {
            get: get,
            set: set,
            enumerable: true,
        });
        return target;
    }
    else {
        Object.defineProperty(proxy, 'value', {
            set: set,
            get: get,
        });
        buildDataTree(target, key, store);
        proxy[ObModelSymbol] = store;
    }
    return proxy;
});
//# sourceMappingURL=computed.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/annotations/index.js





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/observable.js



function esm_observable_observable(target) {
    return createObservable(null, null, target);
}
esm_observable_observable.box = box;
esm_observable_observable.ref = ref;
esm_observable_observable.deep = observable_observable;
esm_observable_observable.shallow = shallow;
esm_observable_observable.computed = computed;
esm_observable_observable[MakeObModelSymbol] = observable_observable;
//# sourceMappingURL=observable.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/model.js







function model_define(target, annotations) {
    if (isObservable(target))
        return target;
    if (!isSupportObservable(target))
        return target;
    target[ObModelSymbol] = target;
    buildDataTree(undefined, undefined, target);
    for (var key in annotations) {
        var annotation = annotations[key];
        if (isAnnotation(annotation)) {
            getObservableMaker(annotation)({
                target: target,
                key: key,
            });
        }
    }
    return target;
}
function model(target) {
    var annotations = Object.keys(target || {}).reduce(function (buf, key) {
        var descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor && descriptor.get) {
            buf[key] = esm_observable_observable.computed;
        }
        else if (esm_checkers_isFn(target[key])) {
            buf[key] = action_action;
        }
        else {
            buf[key] = esm_observable_observable;
        }
        return buf;
    }, {});
    return model_define(target, annotations);
}
//# sourceMappingURL=model.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/autorun.js
var autorun_assign = (undefined && undefined.__assign) || function () {
    autorun_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return autorun_assign.apply(this, arguments);
};




var autorun = function (tracker, name) {
    if (name === void 0) { name = 'AutoRun'; }
    var reaction = function () {
        if (!esm_checkers_isFn(tracker))
            return;
        if (reaction._boundary > 0)
            return;
        if (ReactionStack.indexOf(reaction) === -1) {
            releaseBindingReactions(reaction);
            try {
                batchStart();
                ReactionStack.push(reaction);
                tracker();
            }
            finally {
                ReactionStack.pop();
                reaction._boundary++;
                batchEnd();
                reaction._boundary = 0;
                reaction._memos.cursor = 0;
                reaction._effects.cursor = 0;
            }
        }
    };
    var cleanRefs = function () {
        reaction._memos = {
            queue: [],
            cursor: 0,
        };
        reaction._effects = {
            queue: [],
            cursor: 0,
        };
    };
    reaction._boundary = 0;
    reaction._name = name;
    cleanRefs();
    reaction();
    return function () {
        disposeBindingReactions(reaction);
        disposeEffects(reaction);
        cleanRefs();
    };
};
autorun.memo = function (callback, dependencies) {
    if (!esm_checkers_isFn(callback))
        return;
    var current = ReactionStack[ReactionStack.length - 1];
    if (!current || !current._memos)
        throw new Error('autorun.memo must used in autorun function body.');
    var deps = toArray(dependencies || []);
    var id = current._memos.cursor++;
    var old = current._memos.queue[id];
    if (!old || hasDepsChange(deps, old.deps)) {
        var value = callback();
        current._memos.queue[id] = {
            value: value,
            deps: deps,
        };
        return value;
    }
    return old.value;
};
autorun.effect = function (callback, dependencies) {
    if (!esm_checkers_isFn(callback))
        return;
    var current = ReactionStack[ReactionStack.length - 1];
    if (!current || !current._effects)
        throw new Error('autorun.effect must used in autorun function body.');
    var effects = current._effects;
    var deps = toArray(dependencies || [{}]);
    var id = effects.cursor++;
    var old = effects.queue[id];
    if (!old || hasDepsChange(deps, old.deps)) {
        Promise.resolve(0).then(function () {
            if (current._disposed)
                return;
            var dispose = callback();
            if (esm_checkers_isFn(dispose)) {
                effects.queue[id].dispose = dispose;
            }
        });
        effects.queue[id] = {
            deps: deps,
        };
    }
};
var reaction = function (tracker, subscriber, options) {
    var realOptions = autorun_assign({ name: 'Reaction' }, options);
    var value = {};
    var dirtyCheck = function () {
        if (esm_checkers_isFn(realOptions.equals))
            return !realOptions.equals(value.oldValue, value.currentValue);
        return value.oldValue !== value.currentValue;
    };
    var fireAction = function () {
        try {
            //如果untrack的话，会导致用户如果在scheduler里同步调用setState影响下次React渲染的依赖收集
            batchStart();
            if (esm_checkers_isFn(subscriber))
                subscriber(value.currentValue, value.oldValue);
        }
        finally {
            batchEnd();
        }
    };
    var reaction = function () {
        if (ReactionStack.indexOf(reaction) === -1) {
            releaseBindingReactions(reaction);
            try {
                ReactionStack.push(reaction);
                value.currentValue = tracker();
            }
            finally {
                ReactionStack.pop();
            }
        }
    };
    reaction._scheduler = function (looping) {
        looping();
        if (dirtyCheck())
            fireAction();
        value.oldValue = value.currentValue;
    };
    reaction._name = realOptions.name;
    reaction();
    value.oldValue = value.currentValue;
    if (realOptions.fireImmediately) {
        fireAction();
    }
    return function () {
        disposeBindingReactions(reaction);
    };
};
//# sourceMappingURL=autorun.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/tracker.js



var Tracker = /** @class */ (function () {
    function Tracker(scheduler, name) {
        if (name === void 0) { name = 'TrackerReaction'; }
        var _this = this;
        this.track = function (tracker) {
            if (!esm_checkers_isFn(tracker))
                return _this.results;
            if (_this.track._boundary > 0)
                return;
            if (ReactionStack.indexOf(_this.track) === -1) {
                releaseBindingReactions(_this.track);
                try {
                    batchStart();
                    ReactionStack.push(_this.track);
                    _this.results = tracker();
                }
                finally {
                    ReactionStack.pop();
                    _this.track._boundary++;
                    batchEnd();
                    _this.track._boundary = 0;
                }
            }
            return _this.results;
        };
        this.dispose = function () {
            disposeBindingReactions(_this.track);
        };
        this.track._scheduler = function (callback) {
            if (_this.track._boundary === 0)
                _this.dispose();
            if (esm_checkers_isFn(callback))
                scheduler(callback);
        };
        this.track._name = name;
        this.track._boundary = 0;
    }
    return Tracker;
}());

//# sourceMappingURL=tracker.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/observe.js




var observe = function (target, observer, deep) {
    if (deep === void 0) { deep = true; }
    var addListener = function (target) {
        var raw = externals_raw(target);
        var node = tree_getDataNode(raw);
        var listener = function (operation) {
            var targetRaw = externals_raw(operation.target);
            var targetNode = tree_getDataNode(targetRaw);
            if (deep) {
                if (node.contains(targetNode)) {
                    observer(new tree_DataChange(operation, targetNode));
                    return;
                }
            }
            if (node === targetNode ||
                (node.targetRaw === targetRaw && node.key === operation.key)) {
                observer(new tree_DataChange(operation, targetNode));
            }
        };
        if (node && esm_checkers_isFn(observer)) {
            environment_ObserverListeners.add(listener);
        }
        return function () {
            environment_ObserverListeners.delete(listener);
        };
    };
    if (target && typeof target !== 'object')
        throw Error("Can not observe ".concat(typeof target, " type."));
    return addListener(target);
};
//# sourceMappingURL=observe.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/types.js

//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.3.1/node_modules/@formily/reactive/esm/index.js










//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/shared/checkers.js


var isForm = function (node) {
    return node instanceof Form;
};
var isField = function (node) {
    return node instanceof Field;
};
var isGeneralField = function (node) {
    return node instanceof Field || node instanceof VoidField;
};
var isArrayField = function (node) {
    return node instanceof ArrayField;
};
var isObjectField = function (node) {
    return node instanceof ObjectField;
};
var isVoidField = function (node) {
    return node instanceof VoidField;
};
var isFormState = function (state) {
    if (checkers_isFn(state === null || state === void 0 ? void 0 : state.initialize))
        return false;
    return (state === null || state === void 0 ? void 0 : state.displayName) === 'Form';
};
var isFieldState = function (state) {
    if (checkers_isFn(state === null || state === void 0 ? void 0 : state.initialize))
        return false;
    return (state === null || state === void 0 ? void 0 : state.displayName) === 'Field';
};
var isGeneralFieldState = function (node) {
    var _a;
    if (checkers_isFn(node === null || node === void 0 ? void 0 : node.initialize))
        return false;
    return ((_a = node === null || node === void 0 ? void 0 : node.displayName) === null || _a === void 0 ? void 0 : _a.indexOf('Field')) > -1;
};
var isArrayFieldState = function (state) {
    if (checkers_isFn(state === null || state === void 0 ? void 0 : state.initialize))
        return false;
    return (state === null || state === void 0 ? void 0 : state.displayName) === 'ArrayField';
};
var isDataField = function (node) {
    return isField(node) || isArrayField(node) || isObjectField(node);
};
var isDataFieldState = function (node) {
    return (isFieldState(node) || isObjectFieldState(node) || isArrayFieldState(node));
};
var isObjectFieldState = function (state) {
    if (checkers_isFn(state === null || state === void 0 ? void 0 : state.initialize))
        return false;
    return (state === null || state === void 0 ? void 0 : state.displayName) === 'ObjectField';
};
var isVoidFieldState = function (state) {
    if (checkers_isFn(state === null || state === void 0 ? void 0 : state.initialize))
        return false;
    return (state === null || state === void 0 ? void 0 : state.displayName) === 'VoidField';
};
var isQuery = function (query) {
    return query && query instanceof Query;
};
//# sourceMappingURL=checkers.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/Graph.js



var Graph = /** @class */ (function () {
    function Graph(form) {
        var _this = this;
        this.getGraph = function () {
            var graph = {};
            graph[''] = _this.form.getState();
            array_each(_this.form.fields, function (field, identifier) {
                graph[identifier] = field.getState();
            });
            return graph;
        };
        this.setGraph = function (graph) {
            var form = _this.form;
            var createField = function (identifier, state) {
                var address = Path.parse(identifier);
                var name = address.segments[address.segments.length - 1];
                var basePath = address.parent();
                if (isFieldState(state)) {
                    return _this.form.createField({ name: name, basePath: basePath });
                }
                else if (isArrayFieldState(state)) {
                    return _this.form.createArrayField({ name: name, basePath: basePath });
                }
                else if (isObjectFieldState(state)) {
                    return _this.form.createObjectField({ name: name, basePath: basePath });
                }
                else {
                    return _this.form.createVoidField({ name: name, basePath: basePath });
                }
            };
            array_each(graph, function (state, address) {
                if (isFormState(state)) {
                    form.setState(state);
                }
                else {
                    var field = form.fields[address];
                    if (field) {
                        field.setState(state);
                    }
                    else {
                        createField(address, state).setState(state);
                    }
                }
            });
        };
        this.form = form;
        model_define(this, {
            setGraph: batch,
        });
    }
    return Graph;
}());

//# sourceMappingURL=Graph.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/types.js
var isValidateResult = function (obj) {
    return !!obj['type'] && !!obj['message'];
};
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/registry.js

var registry_getIn = Path.getIn;
var registry_self = globalThisPolyfill;
var defaultLanguage = 'en';
var getBrowserlanguage = function () {
    /* istanbul ignore next */
    if (!registry_self.navigator) {
        return defaultLanguage;
    }
    return (registry_self.navigator.browserlanguage || registry_self.navigator.language || defaultLanguage);
};
var registry = {
    locales: {
        messages: {},
        language: getBrowserlanguage(),
    },
    formats: {},
    rules: {},
    template: null,
};
var getISOCode = function (language) {
    var isoCode = registry.locales.language;
    if (registry.locales.messages[language]) {
        return language;
    }
    var lang = lowerCase(language);
    array_each(registry.locales.messages, function (messages, key) {
        var target = lowerCase(key);
        if (target.indexOf(lang) > -1 || lang.indexOf(target) > -1) {
            isoCode = key;
            return false;
        }
    });
    return isoCode;
};
var getValidateLocaleIOSCode = getISOCode;
var setValidateLanguage = function (lang) {
    registry.locales.language = lang || defaultLanguage;
};
var getValidateLanguage = function () { return registry.locales.language; };
var getLocaleByPath = function (path, lang) {
    if (lang === void 0) { lang = registry.locales.language; }
    return registry_getIn(registry.locales.messages, "".concat(getISOCode(lang), ".").concat(path));
};
var getValidateLocale = function (path) {
    var message = getLocaleByPath(path);
    return (message ||
        getLocaleByPath('pattern') ||
        getLocaleByPath('pattern', defaultLanguage));
};
var getValidateMessageTemplateEngine = function () { return registry.template; };
var getValidateFormats = function (key) {
    return key ? registry.formats[key] : registry.formats;
};
var getValidateRules = function (key) {
    return key ? registry.rules[key] : registry.rules;
};
var registerValidateLocale = function (locale) {
    registry.locales.messages = merge(registry.locales.messages, locale);
};
var registerValidateRules = function (rules) {
    array_each(rules, function (rule, key) {
        if (checkers_isFn(rule)) {
            registry.rules[key] = rule;
        }
    });
};
var registerValidateFormats = function (formats) {
    array_each(formats, function (pattern, key) {
        if (checkers_isStr(pattern) || pattern instanceof RegExp) {
            registry.formats[key] = new RegExp(pattern);
        }
    });
};
var registerValidateMessageTemplateEngine = function (template) {
    registry.template = template;
};
//# sourceMappingURL=registry.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/template.js


var render = function (result, rules) {
    var message = result.message;
    if (checkers_isStr(message)) {
        var template = getValidateMessageTemplateEngine();
        if (checkers_isFn(template)) {
            result.message = template(message, rules);
        }
        result.message = result.message.replace(/\{\{\s*([\w.]+)\s*\}\}/g, function (_, $0) {
            return Path.getIn(rules, $0);
        });
    }
    return result;
};
//# sourceMappingURL=template.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/parser.js
var parser_assign = (undefined && undefined.__assign) || function () {
    parser_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return parser_assign.apply(this, arguments);
};
var parser_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var parser_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




var getRuleMessage = function (rule, type) {
    if (rule.format) {
        return rule.message || getValidateLocale(rule.format);
    }
    return rule.message || getValidateLocale(type);
};
var parseValidatorDescription = function (description) {
    if (!description)
        return {};
    var rules = {};
    if (checkers_isStr(description)) {
        rules.format = description;
    }
    else if (checkers_isFn(description)) {
        rules.validator = description;
    }
    else {
        rules = Object.assign(rules, description);
    }
    return rules;
};
var parseValidatorDescriptions = function (validator) {
    if (!validator)
        return [];
    var array = checkers_isArr(validator) ? validator : [validator];
    return array.map(function (description) {
        return parseValidatorDescription(description);
    });
};
var parseValidatorRules = function (rules) {
    if (rules === void 0) { rules = {}; }
    var getRulesKeys = function () {
        var keys = [];
        if ('required' in rules) {
            keys.push('required');
        }
        for (var key in rules) {
            if (key === 'required' || key === 'validator')
                continue;
            keys.push(key);
        }
        if ('validator' in rules) {
            keys.push('validator');
        }
        return keys;
    };
    var getContext = function (context, value) {
        return parser_assign(parser_assign(parser_assign({}, rules), context), { value: value });
    };
    var createValidate = function (callback, message) {
        return function (value, context) { return parser_awaiter(void 0, void 0, void 0, function () {
            var context_, results, e_1;
            return parser_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        context_ = getContext(context, value);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, callback(value, parser_assign(parser_assign({}, rules), { message: message }), context_, function (message, scope) {
                                var _a;
                                return (_a = render({
                                    type: 'error',
                                    message: message,
                                }, Object.assign(context_, scope))) === null || _a === void 0 ? void 0 : _a.message;
                            })];
                    case 2:
                        results = _a.sent();
                        if (isBool(results)) {
                            if (!results) {
                                return [2 /*return*/, render({
                                        type: 'error',
                                        message: message,
                                    }, context_)];
                            }
                            return [2 /*return*/, {
                                    type: 'error',
                                    message: undefined,
                                }];
                        }
                        else if (results) {
                            if (isValidateResult(results)) {
                                return [2 /*return*/, render(results, context_)];
                            }
                            return [2 /*return*/, render({
                                    type: 'error',
                                    message: results,
                                }, context_)];
                        }
                        return [2 /*return*/, {
                                type: 'error',
                                message: undefined,
                            }];
                    case 3:
                        e_1 = _a.sent();
                        return [2 /*return*/, {
                                type: 'error',
                                message: (e_1 === null || e_1 === void 0 ? void 0 : e_1.message) || e_1,
                            }];
                    case 4: return [2 /*return*/];
                }
            });
        }); };
    };
    return getRulesKeys().reduce(function (buf, key) {
        var callback = getValidateRules(key);
        if (callback) {
            var validator = createValidate(callback, getRuleMessage(rules, key));
            return buf.concat(validator);
        }
        return buf;
    }, []);
};
var parseValidator = function (validator, options) {
    if (options === void 0) { options = {}; }
    if (!validator)
        return [];
    var array = checkers_isArr(validator) ? validator : [validator];
    return array.reduce(function (buf, description) {
        var _a;
        var rules = parseValidatorDescription(description);
        var triggerType = (_a = rules.triggerType) !== null && _a !== void 0 ? _a : 'onInput';
        if ((options === null || options === void 0 ? void 0 : options.triggerType) && options.triggerType !== triggerType)
            return buf;
        return rules ? buf.concat(parseValidatorRules(rules)) : buf;
    }, []);
};
//# sourceMappingURL=parser.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/locale.js
/* harmony default export */ const locale = ({
    en: {
        pattern: 'This field is invalid',
        invalid: 'This field is invalid',
        required: 'The field value is required',
        number: 'The field value is not a number',
        integer: 'The field value is not an integer number',
        url: 'The field value is a invalid url',
        email: 'The field value is not a email format',
        ipv6: 'The field value is not a ipv6 format',
        ipv4: 'The field value is not a ipv4 format',
        idcard: 'The field value is not an idcard format',
        qq: 'The field value is not a qq number format',
        phone: 'The field value is not a phone number format',
        money: 'The field value is not a currency format',
        zh: 'The field value is not a chinese string',
        date: 'The field value is not a valid date format',
        zip: 'The field value is not a zip format',
        len: 'The length or number of entries must be {{len}}',
        min: 'The length or number of entries must be at least {{min}}',
        minLength: 'The length or number of entries must be at least {{minLength}}',
        minItems: 'The length or number of entries must be at least {{minItems}}',
        maximum: 'The field value cannot be greater than {{maximum}}',
        exclusiveMaximum: 'The field value must be less than {{exclusiveMaximum}}',
        minimum: 'The field value cannot be less than {{minimum}}',
        exclusiveMinimum: 'The field value must be greater than {{exclusiveMinimum}}',
        max: 'The field length or number of entries must be at most {{max}}',
        maxLength: 'The field length or number of entries must be at most {{maxLength}}',
        maxItems: 'The field length or number of entries must be at most {{maxItems}}',
        whitespace: 'This field value cannot be blank string.',
        enum: 'The field value must be one of {{enum}}',
        const: 'The field value must be equal to {{const}}',
        multipleOf: 'The field value must be divisible by {{multipleOf}}',
        maxProperties: 'The number of field properties cannot be greater than {{maxProperties}}',
        minProperties: 'The number of field properties cannot be less than {{maxProperties}}',
        uniqueItems: 'Array elements are not unique',
    },
    zh: {
        pattern: '该字段不是一个合法的字段',
        invalid: '该字段不是一个合法的字段',
        required: '该字段是必填字段',
        number: '该字段不是合法的数字',
        integer: '该字段不是合法的整型数字',
        url: '该字段不是合法的url',
        email: '该字段不是合法的邮箱格式',
        ipv6: '该字段不是合法的ipv6格式',
        ipv4: '该字段不是合法的ipv4格式',
        idcard: '该字段不是合法的身份证格式',
        qq: '该字段不符合QQ号格式',
        phone: '该字段不是有效的手机号',
        money: '该字段不是有效货币格式',
        zh: '该字段不是合法的中文字符串',
        date: '该字段不是合法的日期格式',
        zip: '该字段不是合法的邮编格式',
        len: '长度或条目数必须为{{len}}',
        min: '长度或条目数不能小于{{min}}',
        minLength: '长度或条目数不能小于{{minLength}}',
        minItems: '长度或条目数不能小于{{minItems}}',
        max: '长度或条目数不能大于{{max}}',
        maxLength: '长度或条目数不能大于{{maxLength}}',
        maxItems: '长度或条目数不能大于{{maxItems}}',
        maximum: '数值不能大于{{maximum}}',
        exclusiveMaximum: '数值必须小于{{exclusiveMaximum}}',
        minimum: '数值不能小于{{minimum}}',
        exclusiveMinimum: '数值必须大于{{exclusiveMinimum}}',
        whitespace: '不能为纯空白字符串',
        enum: '字段值必须为{{enum}}其中一个',
        const: '字段值必须等于{{const}}',
        multipleOf: '字段值不能被{{multipleOf}}整除',
        maxProperties: '字段属性数量不能大于{{maxProperties}}',
        minProperties: '字段属性数量不能小于{{minProperties}}',
        uniqueItems: '数组元素不唯一',
    },
    'en-US': {
        pattern: 'This field is invalid',
        invalid: 'This field is invalid',
        required: 'The field value is required',
        number: 'The field value is not a number',
        integer: 'The field value is not an integer number',
        url: 'The field value is a invalid url',
        email: 'The field value is not a email format',
        ipv6: 'The field value is not a ipv6 format',
        ipv4: 'The field value is not a ipv4 format',
        idcard: 'The field value is not an idcard format',
        qq: 'The field value is not a qq number format',
        phone: 'The field value is not a phone number format',
        money: 'The field value is not a currency format',
        zh: 'The field value is not a chinese string',
        date: 'The field value is not a valid date format',
        zip: 'The field value is not a zip format',
        len: 'The length or number of entries must be {{len}}',
        min: 'The length or number of entries must be at least {{min}}',
        minLength: 'The length or number of entries must be at least {{minLength}}',
        minItems: 'The length or number of entries must be at least {{minItems}}',
        maximum: 'The field value cannot be greater than {{maximum}}',
        exclusiveMaximum: 'The field value must be less than {{exclusiveMaximum}}',
        minimum: 'The field value cannot be less than {{minimum}}',
        exclusiveMinimum: 'The field value must be greater than {{exclusiveMinimum}}',
        max: 'The field length or number of entries must be at most {{max}}',
        maxLength: 'The field length or number of entries must be at most {{maxLength}}',
        maxItems: 'The field length or number of entries must be at most {{maxItems}}',
        whitespace: 'This field value cannot be blank string.',
        enum: 'The field value must be one of {{enum}}',
        const: 'The field value must be equal to {{const}}',
        multipleOf: 'The field value must be divisible by {{multipleOf}}',
        maxProperties: 'The number of field properties cannot be greater than {{maxProperties}}',
        minProperties: 'The number of field properties cannot be less than {{maxProperties}}',
        uniqueItems: 'Array elements are not unique',
    },
    'zh-CN': {
        pattern: '该字段不是一个合法的字段',
        invalid: '该字段不是一个合法的字段',
        required: '该字段是必填字段',
        number: '该字段不是合法的数字',
        integer: '该字段不是合法的整型数字',
        url: '该字段不是合法的url',
        email: '该字段不是合法的邮箱格式',
        ipv6: '该字段不是合法的ipv6格式',
        ipv4: '该字段不是合法的ipv4格式',
        idcard: '该字段不是合法的身份证格式',
        qq: '该字段不符合QQ号格式',
        phone: '该字段不是有效的手机号',
        money: '该字段不是有效货币格式',
        zh: '该字段不是合法的中文字符串',
        date: '该字段不是合法的日期格式',
        zip: '该字段不是合法的邮编格式',
        len: '长度或条目数必须为{{len}}',
        min: '长度或条目数不能小于{{min}}',
        minLength: '长度或条目数不能小于{{minLength}}',
        minItems: '长度或条目数不能小于{{minItems}}',
        maxLength: '长度或条目数不能大于{{maxLength}}',
        maxItems: '长度或条目数不能大于{{maxItems}}',
        max: '长度或条目数不能大于{{max}}',
        maximum: '数值不能大于{{maximum}}',
        exclusiveMaximum: '数值必须小于{{exclusiveMaximum}}',
        minimum: '数值不能小于{{minimum}}',
        exclusiveMinimum: '数值必须大于{{exclusiveMinimum}}',
        whitespace: '不能为纯空白字符串',
        enum: '字段值必须为{{enum}}其中一个',
        const: '字段值必须等于{{const}}',
        multipleOf: '字段值不能被{{multipleOf}}整除',
        maxProperties: '字段属性数量不能大于{{maxProperties}}',
        minProperties: '字段属性数量不能小于{{minProperties}}',
        uniqueItems: '数组元素不唯一',
    },
    'zh-TW': {
        pattern: '該字段不是一個合法的字段',
        invalid: '該字段不是一個合法的字段',
        required: '該字段是必填字段',
        number: '該字段不是合法的數字',
        integer: '該字段不是合法的整型數字',
        url: '該字段不是合法的url',
        email: '該字段不是合法的郵箱格式',
        ipv6: '該字段不是合法的ipv6格式',
        ipv4: '該字段不是合法的ipv4格式',
        idcard: '該字段不是合法的身份證格式',
        qq: '該字段不符合QQ號格式',
        phone: '該字段不是有效的手機號',
        money: '該字段不是有效貨幣格式',
        zh: '該字段不是合法的中文字符串',
        date: '該字段不是合法的日期格式',
        zip: '該字段不是合法的郵編格式',
        len: '長度或條目數必須為{{len}}',
        min: '長度或條目數不能小於{{min}}',
        minItems: '長度或條目數不能小於{{minItems}}',
        minLength: '長度或條目數不能小於{{minLength}}',
        max: '長度或條目數不能大於{{max}}',
        maxItems: '長度或條目數不能大於{{maxItems}}',
        maxLength: '長度或條目數不能大於{{maxLength}}',
        maximum: '數值不能大於{{maximum}}',
        exclusiveMaximum: '數值必須小於{{exclusiveMaximum}}',
        minimum: '數值不能小於{{minimum}}',
        exclusiveMinimum: '數值必須大於{{exclusiveMinimum}}',
        whitespace: '不能為純空白字符串',
        enum: '字段值必須為{{enum}}其中一個',
        const: '字段值必須等於{{const}}',
        multipleOf: '字段值不能被{{multipleOf}}整除',
        maxProperties: '字段屬性數量不能大於{{maxProperties}}',
        minProperties: '字段屬性數量不能小於{{minProperties}}',
        uniqueItems: '數組元素不唯一',
    },
    ja: {
        url: 'このフィールドは無効なURLです',
        whitespace: 'このフィールドを空の文字列にすることはできません。',
        zh: 'このフィールドは中国語の文字列ではありません',
        zip: 'このフィールドはzip形式ではありません',
        date: 'このフィールドは有効な日付形式ではありません',
        email: 'このフィールドはメール形式ではありません',
        exclusiveMaximum: '値は{{exclusiveMaximum}}未満である必要があります',
        exclusiveMinimum: '値は{{exclusiveMinimum}}より大きい必要があります',
        idcard: 'このフィールドはIDカード形式ではありません',
        integer: 'このフィールドは整数ではありません',
        ipv4: 'このフィールドはIPv4形式ではありません',
        ipv6: 'このフィールドはIPv6形式ではありません',
        len: 'エントリの長さまたは数は{{len}}でなければなりません',
        max: 'エントリの長さまたは数は最大{{max}}でなければなりません',
        maxItems: 'エントリの長さまたは数は最大{{maxItems}}でなければなりません',
        maxLength: 'エントリの長さまたは数は最大{{maxLength}}でなければなりません',
        maximum: '値は{{最大}}を超えることはできません',
        min: 'エントリの長さまたは数は、少なくとも{{min}}である必要があります',
        minItems: 'エントリの長さまたは数は、少なくとも{{minItems}}である必要があります',
        minLength: 'エントリの長さまたは数は、少なくとも{{minLength}}である必要があります',
        minimum: '値は{{minimum}}以上にする必要があります',
        money: 'このフィールドは通貨形式ではありません',
        number: 'このフィールドは数値ではありません',
        pattern: 'このフィールドはどのパターンとも一致しません',
        invalid: 'このフィールドはどのパターンとも一致しません',
        phone: 'このフィールドは電話番号の形式ではありません',
        qq: 'このフィールドはqq数値形式ではありません',
        required: 'この項目は必須です',
        enum: 'フィールド値は{{enum}}のいずれかである必要があります',
        cons: 'フィールド値は{{const}}と等しくなければなりません',
        multipleOf: 'フィールド値を{{multipleOf}}で割り切れない',
        maxProperties: 'フィールドプロパティの数は{{maxProperties}}を超えることはできません',
        minProperties: 'フィールドプロパティの数は{{minProperties}}未満にすることはできません',
        uniqueItems: '配列要素は一意ではありません',
    },
});
//# sourceMappingURL=locale.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/formats.js
/* harmony default export */ const formats = ({
    url: new RegExp(
    // protocol identifier
    '^(?:(?:(?:https?|ftp|rtmp):)?//)' +
        // user:pass authentication
        '(?:\\S+(?::\\S*)?@)?' +
        '(?:' +
        // IP address exclusion - private & local networks
        // Reference: https://www.arin.net/knowledge/address_filters.html
        // filter 10.*.*.* and 127.*.*.* addresses
        '(?!(?:10|127)(?:\\.\\d{1,3}){3})' +
        // filter 169.254.*.* and 192.168.*.*
        '(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})' +
        // filter 172.16.0.0 - 172.31.255.255
        // TODO: add test to validate that it invalidates address in 16-31 range
        '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})' +
        // IP address dotted notation octets
        // excludes loopback network 0.0.0.0
        // excludes reserved space >= 224.0.0.0
        // excludes network & broadcast addresses
        // (first & last IP address of each class)
        // filter 1. part for 1-223
        '(?:22[0-3]|2[01]\\d|[1-9]\\d?|1\\d\\d)' +
        // filter 2. and 3. part for 0-255
        '(?:\\.(?:25[0-5]|2[0-4]\\d|1?\\d{1,2})){2}' +
        // filter 4. part for 1-254
        '(?:\\.(?:25[0-4]|2[0-4]\\d|1\\d\\d|[1-9]\\d?))' +
        '|' +
        // host name
        '(?:(?:[a-z\\u00a1-\\uffff0-9_]-*)*[a-z\\u00a1-\\uffff0-9_]+)' +
        // domain name
        '(?:\\.(?:[a-z\\u00a1-\\uffff0-9_]-*)*[a-z\\u00a1-\\uffff0-9_]+)*' +
        // TLD identifier
        '(?:\\.(?:[a-z\\u00a1-\\uffff_]{2,}))' +
        ')' +
        // port number
        '(?::\\d{2,5})?' +
        // resource path
        '(?:/?\\S*)?$'),
    email: /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/,
    ipv6: /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
    ipv4: /^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})$/,
    number: /^[+-]?\d+(\.\d+)?$/,
    integer: /^[+-]?\d+$/,
    qq: /^(\+?[1-9]\d*|0)$/,
    phone: /^\d{3}-\d{8}$|^\d{4}-\d{7}$|^\d{11}$/,
    idcard: /^\d{15}$|^\d{17}(\d|x|X)$/,
    money: /^([\u0024\u00A2\u00A3\u00A4\u20AC\u00A5\u20B1\u20B9\uFFE5]\s*)(\d+,?)+(\.\d+)?\s*$/,
    zh: /^[\u4e00-\u9fa5]+$/,
    date: /^[0-9]+[./-][0-9]+[./-][0-9]+\s*(?:[0-9]+\s*:\s*[0-9]+\s*:\s*[0-9]+)?$/,
    zip: /^[0-9]{6}$/,
});
//# sourceMappingURL=formats.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/rules.js
var rules_assign = (undefined && undefined.__assign) || function () {
    rules_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return rules_assign.apply(this, arguments);
};
var rules_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var rules_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var rules_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var rules_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};


var isValidateEmpty = function (value) {
    var _a;
    if (checkers_isArr(value)) {
        for (var i = 0; i < value.length; i++) {
            if (isEmpty_isValid(value[i]))
                return false;
        }
        return true;
    }
    else {
        //compat to draft-js
        if (value === null || value === void 0 ? void 0 : value.getCurrentContent) {
            /* istanbul ignore next */
            return !((_a = value.getCurrentContent()) === null || _a === void 0 ? void 0 : _a.hasText());
        }
        return isEmpty_isEmpty(value);
    }
};
var getLength = function (value) {
    return checkers_isStr(value) ? stringLength(value) : value ? value.length : 0;
};
var extendSameRules = function (rules, names) {
    array_each(names, function (realName, name) {
        rules[name] = function (value, rule) {
            var _a;
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return rules[realName].apply(rules, rules_spreadArray([value, rules_assign(rules_assign({}, rule), (_a = {}, _a[realName] = rule[name], _a))], rules_read(args), false));
        };
    });
};
var RULES = {
    format: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        if (rule.format) {
            var format = getValidateFormats(rule.format);
            if (format) {
                return !new RegExp(format).test(value) ? rule.message : '';
            }
        }
        return '';
    },
    required: function (value, rule) {
        if (rule.required === false)
            return '';
        return isValidateEmpty(value) ? rule.message : '';
    },
    max: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        var length = isNum(value) ? value : getLength(value);
        var max = Number(rule.max);
        return length > max ? rule.message : '';
    },
    min: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        var length = isNum(value) ? value : getLength(value);
        var min = Number(rule.min);
        return length < min ? rule.message : '';
    },
    exclusiveMaximum: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        var length = isNum(value) ? value : getLength(value);
        var max = Number(rule.exclusiveMaximum);
        return length >= max ? rule.message : '';
    },
    exclusiveMinimum: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        var length = isNum(value) ? value : getLength(value);
        var min = Number(rule.exclusiveMinimum);
        return length <= min ? rule.message : '';
    },
    len: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        var length = getLength(value);
        var len = Number(rule.len);
        return length !== len ? rule.message : '';
    },
    pattern: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        return !new RegExp(rule.pattern).test(value) ? rule.message : '';
    },
    validator: function (value, rule, context, format) {
        return rules_awaiter(this, void 0, void 0, function () {
            var response;
            return rules_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!checkers_isFn(rule.validator)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.resolve(rule.validator(value, rule, context, format))];
                    case 1:
                        response = _a.sent();
                        if (isBool(response)) {
                            return [2 /*return*/, !response ? rule.message : ''];
                        }
                        else {
                            return [2 /*return*/, response];
                        }
                        _a.label = 2;
                    case 2: 
                    /* istanbul ignore next */
                    throw new Error("The rule's validator property must be a function.");
                }
            });
        });
    },
    whitespace: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        if (rule.whitespace) {
            return /^\s+$/.test(value) ? rule.message : '';
        }
    },
    enum: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        var enums = toArr(rule.enum);
        return enums.indexOf(value) === -1 ? rule.message : '';
    },
    const: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        return rule.const !== value ? rule.message : '';
    },
    multipleOf: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        return Number(value) % Number(rule.multipleOf) !== 0 ? rule.message : '';
    },
    uniqueItems: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        value = toArr(value);
        return value.some(function (item, index) {
            for (var i = 0; i < value.length; i++) {
                if (i !== index && !compare_isEqual(value[i], item)) {
                    return false;
                }
            }
            return true;
        })
            ? ''
            : rule.message;
    },
    maxProperties: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        return Object.keys(value || {}).length <= Number(rule.maxProperties)
            ? ''
            : rule.message;
    },
    minProperties: function (value, rule) {
        if (isValidateEmpty(value))
            return '';
        return Object.keys(value || {}).length >= Number(rule.minProperties)
            ? ''
            : rule.message;
    },
};
extendSameRules(RULES, {
    maximum: 'max',
    minimum: 'min',
    maxItems: 'max',
    minItems: 'min',
    maxLength: 'max',
    minLength: 'min',
});
/* harmony default export */ const rules = (RULES);
//# sourceMappingURL=rules.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/validator.js
var validator_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var validator_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





registerValidateRules(rules);
registerValidateLocale(locale);
registerValidateFormats(formats);
var validate = function (value, validator, options) { return validator_awaiter(void 0, void 0, void 0, function () {
    var validates, results, i, result, type, message;
    return validator_generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                validates = parseValidator(validator, options);
                results = {
                    error: [],
                    success: [],
                    warning: [],
                };
                i = 0;
                _a.label = 1;
            case 1:
                if (!(i < validates.length)) return [3 /*break*/, 4];
                return [4 /*yield*/, validates[i](value, options === null || options === void 0 ? void 0 : options.context)];
            case 2:
                result = _a.sent();
                type = result.type, message = result.message;
                results[type] = results[type] || [];
                if (message) {
                    results[type].push(message);
                    if (options === null || options === void 0 ? void 0 : options.validateFirst)
                        return [3 /*break*/, 4];
                }
                _a.label = 3;
            case 3:
                i++;
                return [3 /*break*/, 1];
            case 4: return [2 /*return*/, results];
        }
    });
}); };
//# sourceMappingURL=validator.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+validator@2.3.1/node_modules/@formily/validator/esm/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/types.js
var LifeCycleTypes;
(function (LifeCycleTypes) {
    /**
     * Form LifeCycle
     **/
    LifeCycleTypes["ON_FORM_INIT"] = "onFormInit";
    LifeCycleTypes["ON_FORM_MOUNT"] = "onFormMount";
    LifeCycleTypes["ON_FORM_UNMOUNT"] = "onFormUnmount";
    LifeCycleTypes["ON_FORM_INPUT_CHANGE"] = "onFormInputChange";
    LifeCycleTypes["ON_FORM_VALUES_CHANGE"] = "onFormValuesChange";
    LifeCycleTypes["ON_FORM_INITIAL_VALUES_CHANGE"] = "onFormInitialValuesChange";
    LifeCycleTypes["ON_FORM_SUBMIT"] = "onFormSubmit";
    LifeCycleTypes["ON_FORM_RESET"] = "onFormReset";
    LifeCycleTypes["ON_FORM_SUBMIT_START"] = "onFormSubmitStart";
    LifeCycleTypes["ON_FORM_SUBMITTING"] = "onFormSubmitting";
    LifeCycleTypes["ON_FORM_SUBMIT_END"] = "onFormSubmitEnd";
    LifeCycleTypes["ON_FORM_SUBMIT_VALIDATE_START"] = "onFormSubmitValidateStart";
    LifeCycleTypes["ON_FORM_SUBMIT_VALIDATE_SUCCESS"] = "onFormSubmitValidateSuccess";
    LifeCycleTypes["ON_FORM_SUBMIT_VALIDATE_FAILED"] = "onFormSubmitValidateFailed";
    LifeCycleTypes["ON_FORM_SUBMIT_VALIDATE_END"] = "onFormSubmitValidateEnd";
    LifeCycleTypes["ON_FORM_SUBMIT_SUCCESS"] = "onFormSubmitSuccess";
    LifeCycleTypes["ON_FORM_SUBMIT_FAILED"] = "onFormSubmitFailed";
    LifeCycleTypes["ON_FORM_VALIDATE_START"] = "onFormValidateStart";
    LifeCycleTypes["ON_FORM_VALIDATING"] = "onFormValidating";
    LifeCycleTypes["ON_FORM_VALIDATE_SUCCESS"] = "onFormValidateSuccess";
    LifeCycleTypes["ON_FORM_VALIDATE_FAILED"] = "onFormValidateFailed";
    LifeCycleTypes["ON_FORM_VALIDATE_END"] = "onFormValidateEnd";
    LifeCycleTypes["ON_FORM_GRAPH_CHANGE"] = "onFormGraphChange";
    LifeCycleTypes["ON_FORM_LOADING"] = "onFormLoading";
    /**
     * Field LifeCycle
     **/
    LifeCycleTypes["ON_FIELD_INIT"] = "onFieldInit";
    LifeCycleTypes["ON_FIELD_INPUT_VALUE_CHANGE"] = "onFieldInputValueChange";
    LifeCycleTypes["ON_FIELD_VALUE_CHANGE"] = "onFieldValueChange";
    LifeCycleTypes["ON_FIELD_INITIAL_VALUE_CHANGE"] = "onFieldInitialValueChange";
    LifeCycleTypes["ON_FIELD_SUBMIT"] = "onFieldSubmit";
    LifeCycleTypes["ON_FIELD_SUBMIT_START"] = "onFieldSubmitStart";
    LifeCycleTypes["ON_FIELD_SUBMITTING"] = "onFieldSubmitting";
    LifeCycleTypes["ON_FIELD_SUBMIT_END"] = "onFieldSubmitEnd";
    LifeCycleTypes["ON_FIELD_SUBMIT_VALIDATE_START"] = "onFieldSubmitValidateStart";
    LifeCycleTypes["ON_FIELD_SUBMIT_VALIDATE_SUCCESS"] = "onFieldSubmitValidateSuccess";
    LifeCycleTypes["ON_FIELD_SUBMIT_VALIDATE_FAILED"] = "onFieldSubmitValidateFailed";
    LifeCycleTypes["ON_FIELD_SUBMIT_VALIDATE_END"] = "onFieldSubmitValidateEnd";
    LifeCycleTypes["ON_FIELD_SUBMIT_SUCCESS"] = "onFieldSubmitSuccess";
    LifeCycleTypes["ON_FIELD_SUBMIT_FAILED"] = "onFieldSubmitFailed";
    LifeCycleTypes["ON_FIELD_VALIDATE_START"] = "onFieldValidateStart";
    LifeCycleTypes["ON_FIELD_VALIDATING"] = "onFieldValidating";
    LifeCycleTypes["ON_FIELD_VALIDATE_SUCCESS"] = "onFieldValidateSuccess";
    LifeCycleTypes["ON_FIELD_VALIDATE_FAILED"] = "onFieldValidateFailed";
    LifeCycleTypes["ON_FIELD_VALIDATE_END"] = "onFieldValidateEnd";
    LifeCycleTypes["ON_FIELD_LOADING"] = "onFieldLoading";
    LifeCycleTypes["ON_FIELD_RESET"] = "onFieldReset";
    LifeCycleTypes["ON_FIELD_MOUNT"] = "onFieldMount";
    LifeCycleTypes["ON_FIELD_UNMOUNT"] = "onFieldUnmount";
})(LifeCycleTypes || (LifeCycleTypes = {}));
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/shared/constants.js
var ReservedProperties = {
    form: true,
    parent: true,
    props: true,
    caches: true,
    requests: true,
    disposers: true,
    heart: true,
    graph: true,
    indexes: true,
    fields: true,
    lifecycles: true,
    componentType: true,
    componentProps: true,
    decoratorType: true,
    decoratorProps: true,
};
var ReadOnlyProperties = {
    address: true,
    path: true,
    valid: true,
    invalid: true,
    selfValid: true,
    selfInvalid: true,
    errors: true,
    successes: true,
    warnings: true,
    validateStatus: true,
};
var SELF_DISPLAY = 'selfDisplay';
var SELF_PATTERN = 'selfPattern';
var MutuallyExclusiveProperties = {
    pattern: SELF_PATTERN,
    editable: SELF_PATTERN,
    readOnly: SELF_PATTERN,
    readPretty: SELF_PATTERN,
    disabled: SELF_PATTERN,
    display: SELF_DISPLAY,
    hidden: SELF_DISPLAY,
    visible: SELF_DISPLAY,
};
var RESPONSE_REQUEST_DURATION = 100;
var GlobalState = {
    lifecycles: [],
    context: [],
    effectStart: false,
    effectEnd: false,
    initializing: false,
};
var NumberIndexReg = /^\.(\d+)/;
//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/shared/internals.js
var internals_assign = (undefined && undefined.__assign) || function () {
    internals_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return internals_assign.apply(this, arguments);
};
var internals_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var internals_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};






var internals_hasOwnProperty = Object.prototype.hasOwnProperty;
var notify = function (target, formType, fieldType) {
    if (isForm(target)) {
        target.notify(formType);
    }
    else {
        target.notify(fieldType);
    }
};
var isHTMLInputEvent = function (event, stopPropagation) {
    var _a;
    if (stopPropagation === void 0) { stopPropagation = true; }
    if (event === null || event === void 0 ? void 0 : event.target) {
        if (typeof event.target === 'object' &&
            ('value' in event.target || 'checked' in event.target))
            return true;
        if (stopPropagation)
            (_a = event.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(event);
    }
    return false;
};
var getValuesFromEvent = function (args) {
    return args.map(function (event) {
        if (event === null || event === void 0 ? void 0 : event.target) {
            if (isEmpty_isValid(event.target.value))
                return event.target.value;
            if (isEmpty_isValid(event.target.checked))
                return event.target.checked;
            return;
        }
        return event;
    });
};
var getTypedDefaultValue = function (field) {
    if (isArrayField(field))
        return [];
    if (isObjectField(field))
        return {};
};
var buildFieldPath = function (field) {
    return buildDataPath(field.form.fields, field.address);
};
var buildDataPath = function (fields, pattern) {
    var prevArray = false;
    var segments = pattern.segments;
    var path = segments.reduce(function (path, key, index) {
        var currentPath = path.concat(key);
        var currentAddress = segments.slice(0, index + 1);
        var current = fields[currentAddress.join('.')];
        if (prevArray) {
            if (!isVoidField(current)) {
                prevArray = false;
            }
            return path;
        }
        if (index >= segments.length - 1) {
            return currentPath;
        }
        if (isVoidField(current)) {
            var parentAddress = segments.slice(0, index);
            var parent_1 = fields[parentAddress.join('.')];
            if (isArrayField(parent_1) && isNumberLike(key)) {
                prevArray = true;
                return currentPath;
            }
            return path;
        }
        else {
            prevArray = false;
        }
        return currentPath;
    }, []);
    return new Path(path);
};
var locateNode = function (field, address) {
    field.address = Path.parse(address);
    field.path = buildFieldPath(field);
    field.form.indexes[field.path.toString()] = field.address.toString();
    return field;
};
var patchFieldStates = function (target, patches) {
    patches.forEach(function (_a) {
        var type = _a.type, address = _a.address, oldAddress = _a.oldAddress, payload = _a.payload;
        if (type === 'remove') {
            destroy(target, address, false);
        }
        else if (type === 'update') {
            if (payload) {
                target[address] = payload;
                if (target[oldAddress] === payload) {
                    target[oldAddress] = undefined;
                }
            }
            if (address && payload) {
                locateNode(payload, address);
            }
        }
    });
};
var destroy = function (target, address, forceClear) {
    if (forceClear === void 0) { forceClear = true; }
    var field = target[address];
    field === null || field === void 0 ? void 0 : field.dispose();
    if (isDataField(field) && forceClear) {
        var form = field.form;
        var path = field.path;
        form.deleteValuesIn(path);
        form.deleteInitialValuesIn(path);
    }
    delete target[address];
};
var patchFormValues = function (form, path, source) {
    var update = function (path, source) {
        if (path.length) {
            form.setValuesIn(path, clone(source));
        }
        else {
            Object.assign(form.values, clone(source));
        }
    };
    var patch = function (source, path) {
        if (path === void 0) { path = []; }
        var targetValue = form.getValuesIn(path);
        var targetField = form.query(path).take();
        var isUnVoidField = targetField && !isVoidField(targetField);
        if (isUnVoidField && targetField.display === 'none') {
            targetField.caches.value = clone(source);
            return;
        }
        if (allowAssignDefaultValue(targetValue, source)) {
            update(path, source);
        }
        else {
            if (isEmpty_isEmpty(source))
                return;
            if (GlobalState.initializing)
                return;
            if (checkers_isPlainObj(targetValue) && checkers_isPlainObj(source)) {
                array_each(source, function (value, key) {
                    patch(value, path.concat(key));
                });
            }
            else {
                if (targetField) {
                    if (isUnVoidField && !targetField.selfModified) {
                        update(path, source);
                    }
                }
                else if (form.initialized) {
                    update(path, source);
                }
            }
        }
    };
    patch(source, path);
};
var matchFeedback = function (search, feedback) {
    if (!search || !feedback)
        return false;
    if (search.type && search.type !== feedback.type)
        return false;
    if (search.code && search.code !== feedback.code)
        return false;
    if (search.path && feedback.path) {
        if (!Path.parse(search.path).match(feedback.path))
            return false;
    }
    if (search.address && feedback.address) {
        if (!Path.parse(search.address).match(feedback.address))
            return false;
    }
    if (search.triggerType && search.triggerType !== feedback.triggerType)
        return false;
    return true;
};
var queryFeedbacks = function (field, search) {
    return field.feedbacks.filter(function (feedback) {
        var _a, _b, _c;
        if (!((_a = feedback.messages) === null || _a === void 0 ? void 0 : _a.length))
            return false;
        return matchFeedback(search, internals_assign(internals_assign({}, feedback), { address: (_b = field.address) === null || _b === void 0 ? void 0 : _b.toString(), path: (_c = field.path) === null || _c === void 0 ? void 0 : _c.toString() }));
    });
};
var queryFeedbackMessages = function (field, search) {
    if (!field.feedbacks.length)
        return [];
    return queryFeedbacks(field, search).reduce(function (buf, info) { return (isEmpty_isEmpty(info.messages) ? buf : buf.concat(info.messages)); }, []);
};
var updateFeedback = function (field, feedback) {
    if (!feedback)
        return;
    return batch(function () {
        var _a, _b;
        if (!field.feedbacks.length) {
            if (!((_a = feedback.messages) === null || _a === void 0 ? void 0 : _a.length)) {
                return;
            }
            field.feedbacks = [feedback];
        }
        else {
            var searched_1 = queryFeedbacks(field, feedback);
            if (searched_1.length) {
                field.feedbacks = field.feedbacks.reduce(function (buf, item) {
                    var _a;
                    if (searched_1.includes(item)) {
                        if ((_a = feedback.messages) === null || _a === void 0 ? void 0 : _a.length) {
                            item.messages = feedback.messages;
                            return buf.concat(item);
                        }
                        else {
                            return buf;
                        }
                    }
                    else {
                        return buf.concat(item);
                    }
                }, []);
                return;
            }
            else if ((_b = feedback.messages) === null || _b === void 0 ? void 0 : _b.length) {
                field.feedbacks = field.feedbacks.concat(feedback);
            }
        }
    });
};
var validateToFeedbacks = function (field, triggerType) {
    if (triggerType === void 0) { triggerType = 'onInput'; }
    return internals_awaiter(void 0, void 0, void 0, function () {
        var results;
        var _a;
        return internals_generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, validate(field.value, field.validator, {
                        triggerType: triggerType,
                        validateFirst: (_a = field.props.validateFirst) !== null && _a !== void 0 ? _a : field.form.props.validateFirst,
                        context: { field: field, form: field.form },
                    })];
                case 1:
                    results = _b.sent();
                    batch(function () {
                        array_each(results, function (messages, type) {
                            field.setFeedback({
                                triggerType: triggerType,
                                type: type,
                                code: pascalCase("validate-".concat(type)),
                                messages: messages,
                            });
                        });
                    });
                    return [2 /*return*/, results];
            }
        });
    });
};
var setValidatorRule = function (field, name, value) {
    var _a;
    if (!isEmpty_isValid(value))
        return;
    var validators = parseValidatorDescriptions(field.validator);
    var hasRule = validators.some(function (desc) { return name in desc; });
    var rule = (_a = {},
        _a[name] = value,
        _a);
    if (hasRule) {
        field.validator = validators.map(function (desc) {
            if (checkers_isPlainObj(desc) && internals_hasOwnProperty.call(desc, name)) {
                desc[name] = value;
                return desc;
            }
            return desc;
        });
    }
    else {
        if (name === 'required') {
            field.validator = [rule].concat(validators);
        }
        else {
            field.validator = validators.concat(rule);
        }
    }
};
var spliceArrayState = function (field, props) {
    var _a = internals_assign({ startIndex: 0, deleteCount: 0, insertCount: 0 }, props), startIndex = _a.startIndex, deleteCount = _a.deleteCount, insertCount = _a.insertCount;
    var address = field.address.toString();
    var addrLength = address.length;
    var form = field.form;
    var fields = form.fields;
    var fieldPatches = [];
    var offset = insertCount - deleteCount;
    var isArrayChildren = function (identifier) {
        return identifier.indexOf(address) === 0 && identifier.length > addrLength;
    };
    var isAfterNode = function (identifier) {
        var _a;
        var afterStr = identifier.substring(addrLength);
        var number = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (number === undefined)
            return false;
        var index = Number(number);
        return index > startIndex + deleteCount - 1;
    };
    var isInsertNode = function (identifier) {
        var _a;
        var afterStr = identifier.substring(addrLength);
        var number = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (number === undefined)
            return false;
        var index = Number(number);
        return index >= startIndex && index < startIndex + insertCount;
    };
    var isDeleteNode = function (identifier) {
        var _a;
        var preStr = identifier.substring(0, addrLength);
        var afterStr = identifier.substring(addrLength);
        var number = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (number === undefined)
            return false;
        var index = Number(number);
        return ((index > startIndex &&
            !fields["".concat(preStr).concat(afterStr.replace(/^\.\d+/, ".".concat(index + deleteCount)))]) ||
            index === startIndex);
    };
    var moveIndex = function (identifier) {
        var _a;
        if (offset === 0)
            return identifier;
        var preStr = identifier.substring(0, addrLength);
        var afterStr = identifier.substring(addrLength);
        var number = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (number === undefined)
            return identifier;
        var index = Number(number) + offset;
        return "".concat(preStr).concat(afterStr.replace(/^\.\d+/, ".".concat(index)));
    };
    batch(function () {
        array_each(fields, function (field, identifier) {
            if (isArrayChildren(identifier)) {
                if (isAfterNode(identifier)) {
                    var newIdentifier = moveIndex(identifier);
                    fieldPatches.push({
                        type: 'update',
                        address: newIdentifier,
                        oldAddress: identifier,
                        payload: field,
                    });
                }
                if (isInsertNode(identifier) || isDeleteNode(identifier)) {
                    fieldPatches.push({ type: 'remove', address: identifier });
                }
            }
        });
        patchFieldStates(fields, fieldPatches);
    });
    field.form.notify(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
};
var exchangeArrayState = function (field, props) {
    var _a = internals_assign({ fromIndex: 0, toIndex: 0 }, props), fromIndex = _a.fromIndex, toIndex = _a.toIndex;
    var address = field.address.toString();
    var fields = field.form.fields;
    var addrLength = address.length;
    var fieldPatches = [];
    var isArrayChildren = function (identifier) {
        return identifier.indexOf(address) === 0 && identifier.length > addrLength;
    };
    var isDown = fromIndex < toIndex;
    var isMoveNode = function (identifier) {
        var _a;
        var afterStr = identifier.slice(address.length);
        var number = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (number === undefined)
            return false;
        var index = Number(number);
        return isDown
            ? index > fromIndex && index <= toIndex
            : index < fromIndex && index >= toIndex;
    };
    var isFromNode = function (identifier) {
        var _a;
        var afterStr = identifier.substring(addrLength);
        var number = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (number === undefined)
            return false;
        var index = Number(number);
        return index === fromIndex;
    };
    var moveIndex = function (identifier) {
        var preStr = identifier.substring(0, addrLength);
        var afterStr = identifier.substring(addrLength);
        var number = afterStr.match(NumberIndexReg)[1];
        var current = Number(number);
        var index = current;
        if (index === fromIndex) {
            index = toIndex;
        }
        else {
            index += isDown ? -1 : 1;
        }
        return "".concat(preStr).concat(afterStr.replace(/^\.\d+/, ".".concat(index)));
    };
    batch(function () {
        array_each(fields, function (field, identifier) {
            if (isArrayChildren(identifier)) {
                if (isMoveNode(identifier) || isFromNode(identifier)) {
                    var newIdentifier = moveIndex(identifier);
                    fieldPatches.push({
                        type: 'update',
                        address: newIdentifier,
                        oldAddress: identifier,
                        payload: field,
                    });
                    if (!fields[newIdentifier]) {
                        fieldPatches.push({
                            type: 'remove',
                            address: identifier,
                        });
                    }
                }
            }
        });
        patchFieldStates(fields, fieldPatches);
    });
    field.form.notify(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
};
var cleanupArrayChildren = function (field, start) {
    var address = field.address.toString();
    var fields = field.form.fields;
    var isArrayChildren = function (identifier) {
        return (identifier.indexOf(address) === 0 && identifier.length > address.length);
    };
    var isNeedCleanup = function (identifier) {
        var _a;
        var afterStr = identifier.slice(address.length);
        var numStr = (_a = afterStr.match(NumberIndexReg)) === null || _a === void 0 ? void 0 : _a[1];
        if (numStr === undefined)
            return false;
        var index = Number(numStr);
        return index >= start;
    };
    batch(function () {
        array_each(fields, function (field, identifier) {
            if (isArrayChildren(identifier) && isNeedCleanup(identifier)) {
                field.destroy();
            }
        });
    });
};
var cleanupObjectChildren = function (field, keys) {
    if (keys.length === 0)
        return;
    var address = field.address.toString();
    var fields = field.form.fields;
    var isObjectChildren = function (identifier) {
        return (identifier.indexOf(address) === 0 && identifier.length > address.length);
    };
    var isNeedCleanup = function (identifier) {
        var _a;
        var afterStr = identifier.slice(address.length);
        var key = (_a = afterStr.match(/^\.([^.]+)/)) === null || _a === void 0 ? void 0 : _a[1];
        if (key === undefined)
            return false;
        return keys.includes(key);
    };
    batch(function () {
        array_each(fields, function (field, identifier) {
            if (isObjectChildren(identifier) && isNeedCleanup(identifier)) {
                field.destroy();
            }
        });
    });
};
var initFieldUpdate = batch.scope.bound(function (field) {
    var form = field.form;
    var updates = Path.ensureIn(form, 'requests.updates', []);
    var indexes = Path.ensureIn(form, 'requests.updateIndexes', {});
    for (var index = 0; index < updates.length; index++) {
        var _a = updates[index], pattern = _a.pattern, callbacks = _a.callbacks;
        var removed = false;
        if (field.match(pattern)) {
            callbacks.forEach(function (callback) {
                field.setState(callback);
            });
            if (!pattern.isWildMatchPattern && !pattern.isMatchPattern) {
                updates.splice(index--, 1);
                removed = true;
            }
        }
        if (!removed) {
            indexes[pattern.toString()] = index;
        }
        else {
            delete indexes[pattern.toString()];
        }
    }
});
var subscribeUpdate = function (form, pattern, callback) {
    var updates = Path.ensureIn(form, 'requests.updates', []);
    var indexes = Path.ensureIn(form, 'requests.updateIndexes', {});
    var id = pattern.toString();
    var current = indexes[id];
    if (isEmpty_isValid(current)) {
        if (updates[current] &&
            !updates[current].callbacks.some(function (fn) {
                return fn.toString() === callback.toString() ? fn === callback : false;
            })) {
            updates[current].callbacks.push(callback);
        }
    }
    else {
        indexes[id] = updates.length;
        updates.push({
            pattern: pattern,
            callbacks: [callback],
        });
    }
};
var deserialize = function (model, setter) {
    if (!model)
        return;
    if (checkers_isFn(setter)) {
        setter(model);
    }
    else {
        for (var key in setter) {
            if (!internals_hasOwnProperty.call(setter, key))
                continue;
            if (ReadOnlyProperties[key] || ReservedProperties[key])
                continue;
            var MutuallyExclusiveKey = MutuallyExclusiveProperties[key];
            if (MutuallyExclusiveKey &&
                internals_hasOwnProperty.call(setter, MutuallyExclusiveKey) &&
                !isEmpty_isValid(setter[MutuallyExclusiveKey]))
                continue;
            var value = setter[key];
            if (checkers_isFn(value))
                continue;
            model[key] = value;
        }
    }
    return model;
};
var serialize = function (model, getter) {
    if (checkers_isFn(getter)) {
        return getter(model);
    }
    else {
        var results = {};
        for (var key in model) {
            if (!internals_hasOwnProperty.call(model, key))
                continue;
            if (ReservedProperties[key])
                continue;
            if (key === 'address' || key === 'path') {
                results[key] = model[key].toString();
                continue;
            }
            var value = model[key];
            if (checkers_isFn(value))
                continue;
            results[key] = toJS(value);
        }
        return results;
    }
};
var createChildrenFeedbackFilter = function (field) {
    var _a;
    var identifier = (_a = field.address) === null || _a === void 0 ? void 0 : _a.toString();
    return function (_a) {
        var address = _a.address;
        return address === identifier || address.indexOf(identifier + '.') === 0;
    };
};
var createStateSetter = function (model) {
    return batch.bound(function (setter) { return deserialize(model, setter); });
};
var createStateGetter = function (model) {
    return function (getter) { return serialize(model, getter); };
};
var createBatchStateSetter = function (form) {
    return batch.bound(function (pattern, payload) {
        if (isQuery(pattern)) {
            pattern.forEach(function (field) {
                field.setState(payload);
            });
        }
        else if (isGeneralField(pattern)) {
            pattern.setState(payload);
        }
        else {
            var matchCount_1 = 0, path = Path.parse(pattern);
            form.query(path).forEach(function (field) {
                field.setState(payload);
                matchCount_1++;
            });
            if (matchCount_1 === 0 || path.isWildMatchPattern) {
                subscribeUpdate(form, path, payload);
            }
        }
    });
};
var createBatchStateGetter = function (form) {
    return function (pattern, payload) {
        if (isQuery(pattern)) {
            return pattern.take(payload);
        }
        else if (isGeneralField(pattern)) {
            return pattern.getState(payload);
        }
        else {
            return form.query(pattern).take(function (field) {
                return field.getState(payload);
            });
        }
    };
};
var triggerFormInitialValuesChange = function (form, change) {
    if (Array.isArray(change.object) && change.key === 'length')
        return;
    if (contains(form.initialValues, change.object) ||
        form.initialValues === change.value) {
        if (change.type === 'add' || change.type === 'set') {
            patchFormValues(form, change.path.slice(1), change.value);
        }
        if (form.initialized) {
            form.notify(LifeCycleTypes.ON_FORM_INITIAL_VALUES_CHANGE);
        }
    }
};
var triggerFormValuesChange = function (form, change) {
    if (Array.isArray(change.object) && change.key === 'length')
        return;
    if ((contains(form.values, change.object) || form.values === change.value) &&
        form.initialized) {
        form.notify(LifeCycleTypes.ON_FORM_VALUES_CHANGE);
    }
};
var setValidating = function (target, validating) {
    clearTimeout(target.requests.validate);
    if (validating) {
        target.requests.validate = setTimeout(function () {
            batch(function () {
                target.validating = validating;
                notify(target, LifeCycleTypes.ON_FORM_VALIDATING, LifeCycleTypes.ON_FIELD_VALIDATING);
            });
        }, RESPONSE_REQUEST_DURATION);
        notify(target, LifeCycleTypes.ON_FORM_VALIDATE_START, LifeCycleTypes.ON_FIELD_VALIDATE_START);
    }
    else {
        if (target.validating !== validating) {
            target.validating = validating;
        }
        notify(target, LifeCycleTypes.ON_FORM_VALIDATE_END, LifeCycleTypes.ON_FIELD_VALIDATE_END);
    }
};
var setSubmitting = function (target, submitting) {
    clearTimeout(target.requests.submit);
    if (submitting) {
        target.requests.submit = setTimeout(function () {
            batch(function () {
                target.submitting = submitting;
                notify(target, LifeCycleTypes.ON_FORM_SUBMITTING, LifeCycleTypes.ON_FIELD_SUBMITTING);
            });
        }, RESPONSE_REQUEST_DURATION);
        notify(target, LifeCycleTypes.ON_FORM_SUBMIT_START, LifeCycleTypes.ON_FIELD_SUBMIT_START);
    }
    else {
        if (target.submitting !== submitting) {
            target.submitting = submitting;
        }
        notify(target, LifeCycleTypes.ON_FORM_SUBMIT_END, LifeCycleTypes.ON_FIELD_SUBMIT_END);
    }
};
var setLoading = function (target, loading) {
    clearTimeout(target.requests.loading);
    if (loading) {
        target.requests.loading = setTimeout(function () {
            batch(function () {
                target.loading = loading;
                notify(target, LifeCycleTypes.ON_FORM_LOADING, LifeCycleTypes.ON_FIELD_LOADING);
            });
        }, RESPONSE_REQUEST_DURATION);
    }
    else if (target.loading !== loading) {
        target.loading = loading;
    }
};
var batchSubmit = function (target, onSubmit) { return internals_awaiter(void 0, void 0, void 0, function () {
    var getValues, e_1, results, e_2;
    return internals_generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                getValues = function (target) {
                    if (isForm(target)) {
                        return toJS(target.values);
                    }
                    return toJS(target.value);
                };
                target.setSubmitting(true);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_START, LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_START);
                return [4 /*yield*/, target.validate()];
            case 2:
                _a.sent();
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_SUCCESS, LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_SUCCESS);
                return [3 /*break*/, 4];
            case 3:
                e_1 = _a.sent();
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_FAILED, LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_FAILED);
                return [3 /*break*/, 4];
            case 4:
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_END, LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_END);
                _a.label = 5;
            case 5:
                _a.trys.push([5, 9, , 10]);
                if (target.invalid) {
                    throw target.errors;
                }
                if (!checkers_isFn(onSubmit)) return [3 /*break*/, 7];
                return [4 /*yield*/, onSubmit(getValues(target))];
            case 6:
                results = _a.sent();
                return [3 /*break*/, 8];
            case 7:
                results = getValues(target);
                _a.label = 8;
            case 8:
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT_SUCCESS, LifeCycleTypes.ON_FIELD_SUBMIT_SUCCESS);
                return [3 /*break*/, 10];
            case 9:
                e_2 = _a.sent();
                target.setSubmitting(false);
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT_FAILED, LifeCycleTypes.ON_FIELD_SUBMIT_FAILED);
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT, LifeCycleTypes.ON_FIELD_SUBMIT);
                throw e_2;
            case 10:
                target.setSubmitting(false);
                notify(target, LifeCycleTypes.ON_FORM_SUBMIT, LifeCycleTypes.ON_FIELD_SUBMIT);
                return [2 /*return*/, results];
        }
    });
}); };
var batchValidate = function (target, pattern, triggerType) { return internals_awaiter(void 0, void 0, void 0, function () {
    var tasks;
    return internals_generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (isForm(target))
                    target.setValidating(true);
                else {
                    if (target.pattern !== 'editable' || target.display !== 'visible')
                        return [2 /*return*/];
                }
                tasks = [];
                target.query(pattern).forEach(function (field) {
                    if (!isVoidField(field)) {
                        tasks.push(validateSelf(field, triggerType, field === target));
                    }
                });
                return [4 /*yield*/, Promise.all(tasks)];
            case 1:
                _a.sent();
                if (isForm(target))
                    target.setValidating(false);
                if (target.invalid) {
                    notify(target, LifeCycleTypes.ON_FORM_VALIDATE_FAILED, LifeCycleTypes.ON_FIELD_VALIDATE_FAILED);
                    throw target.errors;
                }
                notify(target, LifeCycleTypes.ON_FORM_VALIDATE_SUCCESS, LifeCycleTypes.ON_FIELD_VALIDATE_SUCCESS);
                return [2 /*return*/];
        }
    });
}); };
var batchReset = function (target, pattern, options) { return internals_awaiter(void 0, void 0, void 0, function () {
    var tasks;
    return internals_generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                tasks = [];
                target.query(pattern).forEach(function (field) {
                    if (!isVoidField(field)) {
                        tasks.push(resetSelf(field, options, target === field));
                    }
                });
                if (isForm(target)) {
                    target.modified = false;
                }
                notify(target, LifeCycleTypes.ON_FORM_RESET, LifeCycleTypes.ON_FIELD_RESET);
                return [4 /*yield*/, Promise.all(tasks)];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
var validateSelf = batch.bound(function (target, triggerType, noEmit) {
    if (noEmit === void 0) { noEmit = false; }
    return internals_awaiter(void 0, void 0, void 0, function () {
        var start, end, allTriggerTypes, results_1, i, payload, results;
        return internals_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    start = function () {
                        setValidating(target, true);
                    };
                    end = function () {
                        setValidating(target, false);
                        if (noEmit)
                            return;
                        if (target.selfValid) {
                            target.notify(LifeCycleTypes.ON_FIELD_VALIDATE_SUCCESS);
                        }
                        else {
                            target.notify(LifeCycleTypes.ON_FIELD_VALIDATE_FAILED);
                        }
                    };
                    if (target.pattern !== 'editable' || target.display !== 'visible')
                        return [2 /*return*/, {}];
                    start();
                    if (!!triggerType) return [3 /*break*/, 5];
                    allTriggerTypes = parseValidatorDescriptions(target.validator).reduce(function (types, desc) {
                        return types.indexOf(desc.triggerType) > -1
                            ? types
                            : types.concat(desc.triggerType);
                    }, []);
                    results_1 = {};
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < allTriggerTypes.length)) return [3 /*break*/, 4];
                    return [4 /*yield*/, validateToFeedbacks(target, allTriggerTypes[i])];
                case 2:
                    payload = _a.sent();
                    array_each(payload, function (result, key) {
                        results_1[key] = results_1[key] || [];
                        results_1[key] = results_1[key].concat(result);
                    });
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4:
                    end();
                    return [2 /*return*/, results_1];
                case 5: return [4 /*yield*/, validateToFeedbacks(target, triggerType)];
                case 6:
                    results = _a.sent();
                    end();
                    return [2 /*return*/, results];
            }
        });
    });
});
var resetSelf = batch.bound(function (target, options, noEmit) {
    if (noEmit === void 0) { noEmit = false; }
    return internals_awaiter(void 0, void 0, void 0, function () {
        var typedDefaultValue, initialValue;
        return internals_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    typedDefaultValue = getTypedDefaultValue(target);
                    target.modified = false;
                    target.selfModified = false;
                    target.visited = false;
                    target.feedbacks = [];
                    target.inputValue = typedDefaultValue;
                    target.inputValues = [];
                    target.caches = {};
                    if (!isUndef(target.value)) {
                        if (options === null || options === void 0 ? void 0 : options.forceClear) {
                            target.value = typedDefaultValue;
                        }
                        else {
                            initialValue = target.initialValue;
                            target.value = toJS(!isUndef(initialValue) ? initialValue : typedDefaultValue);
                        }
                    }
                    if (!noEmit) {
                        target.notify(LifeCycleTypes.ON_FIELD_RESET);
                    }
                    if (!(options === null || options === void 0 ? void 0 : options.validate)) return [3 /*break*/, 2];
                    return [4 /*yield*/, validateSelf(target)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: return [2 /*return*/];
            }
        });
    });
});
var modifySelf = function (target) {
    if (target.selfModified)
        return;
    target.selfModified = true;
    target.modified = true;
    var parent = target.parent;
    while (parent) {
        if (isDataField(parent)) {
            if (parent.modified)
                return;
            parent.modified = true;
        }
        parent = parent.parent;
    }
    target.form.modified = true;
};
var getValidFormValues = function (values) {
    if (isObservable(values))
        return values;
    return clone(values || {});
};
var getValidFieldDefaultValue = function (value, initialValue) {
    if (allowAssignDefaultValue(value, initialValue))
        return clone(initialValue);
    return value;
};
var allowAssignDefaultValue = function (target, source) {
    var isValidTarget = !isUndef(target);
    var isValidSource = !isUndef(source);
    if (!isValidTarget) {
        return isValidSource;
    }
    if (typeof target === typeof source) {
        if (target === '')
            return false;
        if (target === 0)
            return false;
    }
    var isEmptyTarget = target !== null && isEmpty_isEmpty(target, true);
    var isEmptySource = source !== null && isEmpty_isEmpty(source, true);
    if (isEmptyTarget) {
        return !isEmptySource;
    }
    return false;
};
var createReactions = function (field) {
    var reactions = toArr(field.props.reactions);
    field.form.addEffects(field, function () {
        reactions.forEach(function (reaction) {
            if (checkers_isFn(reaction)) {
                field.disposers.push(autorun(batch.scope.bound(function () {
                    if (field.destroyed)
                        return;
                    reaction(field);
                })));
            }
        });
    });
};
var createReaction = function (tracker, scheduler) {
    return reaction(tracker, untracked.bound(scheduler));
};
var initializeStart = function () {
    GlobalState.initializing = true;
};
var initializeEnd = function () {
    batch.endpoint(function () {
        GlobalState.initializing = false;
    });
};
var getArrayParent = function (field, index) {
    if (index === void 0) { index = field.index; }
    if (index > -1) {
        var parent_2 = field.parent;
        while (parent_2) {
            if (isArrayField(parent_2))
                return parent_2;
            if (parent_2 === field.form)
                return;
            parent_2 = parent_2.parent;
        }
    }
};
var getObjectParent = function (field) {
    var parent = field.parent;
    while (parent) {
        if (isArrayField(parent))
            return;
        if (isObjectField(parent))
            return parent;
        if (parent === field.form)
            return;
        parent = parent.parent;
    }
};
//# sourceMappingURL=internals.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/Query.js


var output = function (field, taker) {
    if (!field)
        return;
    if (checkers_isFn(taker)) {
        return taker(field, field.address);
    }
    return field;
};
var takeMatchPattern = function (form, pattern) {
    var identifier = pattern.toString();
    var indexIdentifier = form.indexes[identifier];
    var absoluteField = form.fields[identifier];
    var indexField = form.fields[indexIdentifier];
    if (absoluteField) {
        return identifier;
    }
    else if (indexField) {
        return indexIdentifier;
    }
};
var Query = /** @class */ (function () {
    function Query(props) {
        var _this = this;
        this.addresses = [];
        this.pattern = Path.parse(props.pattern, props.base);
        this.form = props.form;
        if (!this.pattern.isMatchPattern) {
            var matched = takeMatchPattern(this.form, this.pattern.haveRelativePattern
                ? buildDataPath(props.form.fields, this.pattern)
                : this.pattern);
            if (matched) {
                this.addresses = [matched];
            }
        }
        else {
            array_each(this.form.fields, function (field, address) {
                if (!field) {
                    delete _this.form.fields[address];
                    return;
                }
                if (field.match(_this.pattern)) {
                    _this.addresses.push(address);
                }
            });
        }
    }
    Query.prototype.take = function (taker) {
        return output(this.form.fields[this.addresses[0]], taker);
    };
    Query.prototype.map = function (iterator) {
        var _this = this;
        return this.addresses.map(function (address) {
            return output(_this.form.fields[address], iterator);
        });
    };
    Query.prototype.forEach = function (iterator) {
        var _this = this;
        return this.addresses.forEach(function (address) {
            return output(_this.form.fields[address], iterator);
        });
    };
    Query.prototype.reduce = function (reducer, initial) {
        var _this = this;
        return this.addresses.reduce(function (value, address) {
            return output(_this.form.fields[address], function (field, address) {
                return reducer(value, field, address);
            });
        }, initial);
    };
    Query.prototype.get = function (key) {
        var results = this.take();
        if (results) {
            return results[key];
        }
    };
    Query.prototype.getIn = function (pattern) {
        return Path.getIn(this.take(), pattern);
    };
    Query.prototype.value = function () {
        return this.get('value');
    };
    Query.prototype.initialValue = function () {
        return this.get('initialValue');
    };
    return Query;
}());

//# sourceMappingURL=Query.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/BaseField.js
var BaseField_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var BaseField_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




var BaseField = /** @class */ (function () {
    function BaseField() {
        var _this = this;
        this.disposers = [];
        this.actions = {};
        this.setTitle = function (title) {
            _this.title = title;
        };
        this.setDescription = function (description) {
            _this.description = description;
        };
        this.setDisplay = function (type) {
            _this.display = type;
        };
        this.setPattern = function (type) {
            _this.pattern = type;
        };
        this.setComponent = function (component, props) {
            if (component) {
                _this.componentType = component;
            }
            if (props) {
                _this.componentProps = _this.componentProps || {};
                Object.assign(_this.componentProps, props);
            }
        };
        this.setComponentProps = function (props) {
            if (props) {
                _this.componentProps = _this.componentProps || {};
                Object.assign(_this.componentProps, props);
            }
        };
        this.setDecorator = function (component, props) {
            if (component) {
                _this.decoratorType = component;
            }
            if (props) {
                _this.decoratorProps = _this.decoratorProps || {};
                Object.assign(_this.decoratorProps, props);
            }
        };
        this.setDecoratorProps = function (props) {
            if (props) {
                _this.decoratorProps = _this.decoratorProps || {};
                Object.assign(_this.decoratorProps, props);
            }
        };
        this.setData = function (data) {
            _this.data = data;
        };
        this.setContent = function (content) {
            _this.content = content;
        };
        this.onInit = function () {
            _this.initialized = true;
            initFieldUpdate(_this);
            _this.notify(LifeCycleTypes.ON_FIELD_INIT);
        };
        this.onMount = function () {
            _this.mounted = true;
            _this.unmounted = false;
            _this.notify(LifeCycleTypes.ON_FIELD_MOUNT);
        };
        this.onUnmount = function () {
            _this.mounted = false;
            _this.unmounted = true;
            _this.notify(LifeCycleTypes.ON_FIELD_UNMOUNT);
        };
        this.query = function (pattern) {
            return new Query({
                pattern: pattern,
                base: _this.address,
                form: _this.form,
            });
        };
        this.notify = function (type, payload) {
            return _this.form.notify(type, payload !== null && payload !== void 0 ? payload : _this);
        };
        this.dispose = function () {
            _this.disposers.forEach(function (dispose) {
                dispose();
            });
            _this.form.removeEffects(_this);
        };
        this.destroy = function (forceClear) {
            if (forceClear === void 0) { forceClear = true; }
            destroy(_this.form.fields, _this.address.toString(), forceClear);
        };
        this.match = function (pattern) {
            return Path.parse(pattern).matchAliasGroup(_this.address, _this.path);
        };
        this.inject = function (actions) {
            array_each(actions, function (action, key) {
                if (checkers_isFn(action)) {
                    _this.actions[key] = action;
                }
            });
        };
        this.invoke = function (name) {
            var _a, _b;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return (_b = (_a = _this.actions)[name]) === null || _b === void 0 ? void 0 : _b.call.apply(_b, BaseField_spreadArray([_a], BaseField_read(args), false));
        };
    }
    BaseField.prototype.locate = function (address) {
        this.form.fields[address.toString()] = this;
        locateNode(this, address);
    };
    Object.defineProperty(BaseField.prototype, "indexes", {
        get: function () {
            return this.path.transform(/^\d+$/, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return args.map(function (index) { return Number(index); });
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "index", {
        get: function () {
            var _a;
            return (_a = this.indexes[this.indexes.length - 1]) !== null && _a !== void 0 ? _a : -1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "records", {
        get: function () {
            var array = getArrayParent(this);
            return array === null || array === void 0 ? void 0 : array.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "record", {
        get: function () {
            var _a;
            var obj = getObjectParent(this);
            if (obj) {
                return obj.value;
            }
            var index = this.index;
            var array = getArrayParent(this, index);
            if (array) {
                return (_a = array.value) === null || _a === void 0 ? void 0 : _a[index];
            }
            return this.form.values;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "component", {
        get: function () {
            return [this.componentType, this.componentProps];
        },
        set: function (value) {
            var component = toArr(value);
            this.componentType = component[0];
            this.componentProps = component[1] || {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "decorator", {
        get: function () {
            return [this.decoratorType, this.decoratorProps];
        },
        set: function (value) {
            var decorator = toArr(value);
            this.decoratorType = decorator[0];
            this.decoratorProps = decorator[1] || {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "parent", {
        get: function () {
            var parent = this.address.parent();
            var identifier = parent.toString();
            while (!this.form.fields[identifier]) {
                parent = parent.parent();
                identifier = parent.toString();
                if (!identifier)
                    return;
            }
            return this.form.fields[identifier];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "display", {
        get: function () {
            var _a;
            var parentDisplay = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.display;
            if (parentDisplay && parentDisplay !== 'visible') {
                if (this.selfDisplay && this.selfDisplay !== 'visible')
                    return this.selfDisplay;
                return parentDisplay;
            }
            if (isEmpty_isValid(this.selfDisplay))
                return this.selfDisplay;
            return parentDisplay || this.form.display || 'visible';
        },
        set: function (display) {
            this.selfDisplay = display;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "pattern", {
        get: function () {
            var _a;
            var parentPattern = ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.pattern) || this.form.pattern || 'editable';
            var selfPattern = this.selfPattern;
            if (isEmpty_isValid(selfPattern)) {
                if (parentPattern === 'readPretty' && selfPattern !== 'editable') {
                    return parentPattern;
                }
                return selfPattern;
            }
            return parentPattern;
        },
        set: function (pattern) {
            this.selfPattern = pattern;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "editable", {
        get: function () {
            return this.pattern === 'editable';
        },
        set: function (editable) {
            if (!isEmpty_isValid(editable))
                return;
            if (editable) {
                this.pattern = 'editable';
            }
            else {
                this.pattern = 'readPretty';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "disabled", {
        get: function () {
            return this.pattern === 'disabled';
        },
        set: function (disabled) {
            if (!isEmpty_isValid(disabled))
                return;
            if (disabled) {
                this.pattern = 'disabled';
            }
            else {
                this.pattern = 'editable';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "readOnly", {
        get: function () {
            return this.pattern === 'readOnly';
        },
        set: function (readOnly) {
            if (!isEmpty_isValid(readOnly))
                return;
            if (readOnly) {
                this.pattern = 'readOnly';
            }
            else {
                this.pattern = 'editable';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "readPretty", {
        get: function () {
            return this.pattern === 'readPretty';
        },
        set: function (readPretty) {
            if (!isEmpty_isValid(readPretty))
                return;
            if (readPretty) {
                this.pattern = 'readPretty';
            }
            else {
                this.pattern = 'editable';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "hidden", {
        get: function () {
            return this.display === 'hidden';
        },
        set: function (hidden) {
            if (!isEmpty_isValid(hidden))
                return;
            if (hidden) {
                this.display = 'hidden';
            }
            else {
                this.display = 'visible';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "visible", {
        get: function () {
            return this.display === 'visible';
        },
        set: function (visible) {
            if (!isEmpty_isValid(visible))
                return;
            if (visible) {
                this.display = 'visible';
            }
            else {
                this.display = 'none';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseField.prototype, "destroyed", {
        get: function () {
            return !this.form.fields[this.address.toString()];
        },
        enumerable: false,
        configurable: true
    });
    return BaseField;
}());

//# sourceMappingURL=BaseField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/Field.js
var Field_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Field_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Field_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};






var Field = /** @class */ (function (_super) {
    Field_extends(Field, _super);
    function Field(address, props, form, designable) {
        var _this = _super.call(this) || this;
        _this.displayName = 'Field';
        _this.caches = {};
        _this.requests = {};
        _this.setDataSource = function (dataSource) {
            _this.dataSource = dataSource;
        };
        _this.setFeedback = function (feedback) {
            updateFeedback(_this, feedback);
        };
        _this.setSelfErrors = function (messages) {
            _this.selfErrors = messages;
        };
        _this.setSelfWarnings = function (messages) {
            _this.selfWarnings = messages;
        };
        _this.setSelfSuccesses = function (messages) {
            _this.selfSuccesses = messages;
        };
        _this.setValidator = function (validator) {
            _this.validator = validator;
        };
        _this.setValidatorRule = function (name, value) {
            setValidatorRule(_this, name, value);
        };
        _this.setRequired = function (required) {
            _this.required = required;
        };
        _this.setValue = function (value) {
            if (_this.destroyed)
                return;
            if (!_this.initialized) {
                if (_this.display === 'none') {
                    _this.caches.value = value;
                    return;
                }
                value = getValidFieldDefaultValue(value, _this.initialValue);
                if (!allowAssignDefaultValue(_this.value, value) && !_this.designable) {
                    return;
                }
            }
            _this.form.setValuesIn(_this.path, value);
        };
        _this.setInitialValue = function (initialValue) {
            if (_this.destroyed)
                return;
            if (!_this.initialized) {
                if (!allowAssignDefaultValue(_this.initialValue, initialValue) &&
                    !_this.designable) {
                    return;
                }
            }
            _this.form.setInitialValuesIn(_this.path, initialValue);
        };
        _this.setLoading = function (loading) {
            setLoading(_this, loading);
        };
        _this.setValidating = function (validating) {
            setValidating(_this, validating);
        };
        _this.setSubmitting = function (submitting) {
            setSubmitting(_this, submitting);
        };
        _this.setState = createStateSetter(_this);
        _this.getState = createStateGetter(_this);
        _this.onInput = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Field_awaiter(_this, void 0, void 0, function () {
                var isHTMLInputEventFromSelf, getValues, values, value;
                return Field_generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            isHTMLInputEventFromSelf = function (args) {
                                var _a, _b;
                                return isHTMLInputEvent(args[0]) && 'currentTarget' in args[0]
                                    ? ((_a = args[0]) === null || _a === void 0 ? void 0 : _a.target) === ((_b = args[0]) === null || _b === void 0 ? void 0 : _b.currentTarget)
                                    : true;
                            };
                            getValues = function (args) {
                                var _a;
                                if ((_a = args[0]) === null || _a === void 0 ? void 0 : _a.target) {
                                    if (!isHTMLInputEvent(args[0]))
                                        return args;
                                }
                                return getValuesFromEvent(args);
                            };
                            if (!isHTMLInputEventFromSelf(args))
                                return [2 /*return*/];
                            values = getValues(args);
                            value = values[0];
                            this.caches.inputting = true;
                            this.inputValue = value;
                            this.inputValues = values;
                            this.value = value;
                            this.modify();
                            this.notify(LifeCycleTypes.ON_FIELD_INPUT_VALUE_CHANGE);
                            this.notify(LifeCycleTypes.ON_FORM_INPUT_CHANGE, this.form);
                            return [4 /*yield*/, validateSelf(this, 'onInput')];
                        case 1:
                            _a.sent();
                            this.caches.inputting = false;
                            return [2 /*return*/];
                    }
                });
            });
        };
        _this.onFocus = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Field_awaiter(_this, void 0, void 0, function () {
                var _a;
                return Field_generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if ((_a = args[0]) === null || _a === void 0 ? void 0 : _a.target) {
                                if (!isHTMLInputEvent(args[0], false))
                                    return [2 /*return*/];
                            }
                            this.active = true;
                            this.visited = true;
                            return [4 /*yield*/, validateSelf(this, 'onFocus')];
                        case 1:
                            _b.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        _this.onBlur = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Field_awaiter(_this, void 0, void 0, function () {
                var _a;
                return Field_generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if ((_a = args[0]) === null || _a === void 0 ? void 0 : _a.target) {
                                if (!isHTMLInputEvent(args[0], false))
                                    return [2 /*return*/];
                            }
                            this.active = false;
                            return [4 /*yield*/, validateSelf(this, 'onBlur')];
                        case 1:
                            _b.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        _this.validate = function (triggerType) {
            return batchValidate(_this, "".concat(_this.address, ".**"), triggerType);
        };
        _this.submit = function (onSubmit) {
            return batchSubmit(_this, onSubmit);
        };
        _this.reset = function (options) {
            return batchReset(_this, "".concat(_this.address, ".**"), options);
        };
        _this.queryFeedbacks = function (search) {
            return queryFeedbacks(_this, search);
        };
        _this.modify = function () { return modifySelf(_this); };
        _this.form = form;
        _this.props = props;
        _this.designable = designable;
        initializeStart();
        _this.locate(address);
        _this.initialize();
        _this.makeObservable();
        _this.makeReactive();
        _this.onInit();
        initializeEnd();
        return _this;
    }
    Field.prototype.initialize = function () {
        this.initialized = false;
        this.loading = false;
        this.validating = false;
        this.submitting = false;
        this.selfModified = false;
        this.active = false;
        this.visited = false;
        this.mounted = false;
        this.unmounted = false;
        this.inputValues = [];
        this.inputValue = null;
        this.feedbacks = [];
        this.title = this.props.title;
        this.description = this.props.description;
        this.display = this.props.display;
        this.pattern = this.props.pattern;
        this.editable = this.props.editable;
        this.disabled = this.props.disabled;
        this.readOnly = this.props.readOnly;
        this.readPretty = this.props.readPretty;
        this.visible = this.props.visible;
        this.hidden = this.props.hidden;
        this.dataSource = this.props.dataSource;
        this.validator = this.props.validator;
        this.required = this.props.required;
        this.content = this.props.content;
        this.initialValue = this.props.initialValue;
        this.value = this.props.value;
        this.data = this.props.data;
        this.decorator = toArr(this.props.decorator);
        this.component = toArr(this.props.component);
    };
    Field.prototype.makeObservable = function () {
        if (this.designable)
            return;
        model_define(this, {
            path: esm_observable_observable.ref,
            title: esm_observable_observable.ref,
            description: esm_observable_observable.ref,
            dataSource: esm_observable_observable.ref,
            selfDisplay: esm_observable_observable.ref,
            selfPattern: esm_observable_observable.ref,
            loading: esm_observable_observable.ref,
            validating: esm_observable_observable.ref,
            submitting: esm_observable_observable.ref,
            selfModified: esm_observable_observable.ref,
            modified: esm_observable_observable.ref,
            active: esm_observable_observable.ref,
            visited: esm_observable_observable.ref,
            initialized: esm_observable_observable.ref,
            mounted: esm_observable_observable.ref,
            unmounted: esm_observable_observable.ref,
            inputValue: esm_observable_observable.ref,
            inputValues: esm_observable_observable.ref,
            decoratorType: esm_observable_observable.ref,
            componentType: esm_observable_observable.ref,
            content: esm_observable_observable.ref,
            feedbacks: esm_observable_observable.ref,
            decoratorProps: esm_observable_observable,
            componentProps: esm_observable_observable,
            validator: esm_observable_observable.shallow,
            data: esm_observable_observable.shallow,
            component: esm_observable_observable.computed,
            decorator: esm_observable_observable.computed,
            errors: esm_observable_observable.computed,
            warnings: esm_observable_observable.computed,
            successes: esm_observable_observable.computed,
            valid: esm_observable_observable.computed,
            invalid: esm_observable_observable.computed,
            selfErrors: esm_observable_observable.computed,
            selfWarnings: esm_observable_observable.computed,
            selfSuccesses: esm_observable_observable.computed,
            selfValid: esm_observable_observable.computed,
            selfInvalid: esm_observable_observable.computed,
            validateStatus: esm_observable_observable.computed,
            value: esm_observable_observable.computed,
            initialValue: esm_observable_observable.computed,
            display: esm_observable_observable.computed,
            pattern: esm_observable_observable.computed,
            required: esm_observable_observable.computed,
            hidden: esm_observable_observable.computed,
            visible: esm_observable_observable.computed,
            disabled: esm_observable_observable.computed,
            readOnly: esm_observable_observable.computed,
            readPretty: esm_observable_observable.computed,
            editable: esm_observable_observable.computed,
            indexes: esm_observable_observable.computed,
            setDisplay: action_action,
            setTitle: action_action,
            setDescription: action_action,
            setDataSource: action_action,
            setValue: action_action,
            setPattern: action_action,
            setInitialValue: action_action,
            setLoading: action_action,
            setValidating: action_action,
            setFeedback: action_action,
            setSelfErrors: action_action,
            setSelfWarnings: action_action,
            setSelfSuccesses: action_action,
            setValidator: action_action,
            setRequired: action_action,
            setComponent: action_action,
            setComponentProps: action_action,
            setDecorator: action_action,
            setDecoratorProps: action_action,
            setData: action_action,
            setContent: action_action,
            validate: action_action,
            reset: action_action,
            onInit: batch,
            onInput: batch,
            onMount: batch,
            onUnmount: batch,
            onFocus: batch,
            onBlur: batch,
        });
    };
    Field.prototype.makeReactive = function () {
        var _this = this;
        if (this.designable)
            return;
        this.disposers.push(createReaction(function () { return _this.value; }, function (value) {
            _this.notify(LifeCycleTypes.ON_FIELD_VALUE_CHANGE);
            if (isEmpty_isValid(value)) {
                if (_this.selfModified && !_this.caches.inputting) {
                    validateSelf(_this);
                }
                if (!isEmpty_isEmpty(value) && _this.display === 'none') {
                    _this.caches.value = toJS(value);
                    _this.form.deleteValuesIn(_this.path);
                }
            }
        }), createReaction(function () { return _this.initialValue; }, function () {
            _this.notify(LifeCycleTypes.ON_FIELD_INITIAL_VALUE_CHANGE);
        }), createReaction(function () { return _this.display; }, function (display) {
            var _a;
            var value = _this.value;
            if (display !== 'none') {
                if (value === undefined && _this.caches.value !== undefined) {
                    _this.setValue(_this.caches.value);
                    _this.caches.value = undefined;
                }
            }
            else {
                _this.caches.value = (_a = toJS(value)) !== null && _a !== void 0 ? _a : toJS(_this.initialValue);
                _this.form.deleteValuesIn(_this.path);
            }
            if (display === 'none' || display === 'hidden') {
                _this.setFeedback({
                    type: 'error',
                    messages: [],
                });
            }
        }), createReaction(function () { return _this.pattern; }, function (pattern) {
            if (pattern !== 'editable') {
                _this.setFeedback({
                    type: 'error',
                    messages: [],
                });
            }
        }));
        createReactions(this);
    };
    Object.defineProperty(Field.prototype, "selfErrors", {
        get: function () {
            return queryFeedbackMessages(this, {
                type: 'error',
            });
        },
        set: function (messages) {
            this.setFeedback({
                type: 'error',
                code: 'EffectError',
                messages: messages,
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "errors", {
        get: function () {
            return this.form.errors.filter(createChildrenFeedbackFilter(this));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "selfWarnings", {
        get: function () {
            return queryFeedbackMessages(this, {
                type: 'warning',
            });
        },
        set: function (messages) {
            this.setFeedback({
                type: 'warning',
                code: 'EffectWarning',
                messages: messages,
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "warnings", {
        get: function () {
            return this.form.warnings.filter(createChildrenFeedbackFilter(this));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "selfSuccesses", {
        get: function () {
            return queryFeedbackMessages(this, {
                type: 'success',
            });
        },
        set: function (messages) {
            this.setFeedback({
                type: 'success',
                code: 'EffectSuccess',
                messages: messages,
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "successes", {
        get: function () {
            return this.form.successes.filter(createChildrenFeedbackFilter(this));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "selfValid", {
        get: function () {
            return !this.selfErrors.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "valid", {
        get: function () {
            return !this.errors.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "selfInvalid", {
        get: function () {
            return !this.selfValid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "invalid", {
        get: function () {
            return !this.valid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "value", {
        get: function () {
            return this.form.getValuesIn(this.path);
        },
        set: function (value) {
            this.setValue(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "initialValue", {
        get: function () {
            return this.form.getInitialValuesIn(this.path);
        },
        set: function (initialValue) {
            this.setInitialValue(initialValue);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "required", {
        get: function () {
            var validators = checkers_isArr(this.validator)
                ? this.validator
                : parseValidatorDescriptions(this.validator);
            return validators.some(function (desc) { return !!(desc === null || desc === void 0 ? void 0 : desc['required']); });
        },
        set: function (required) {
            if (this.required === required)
                return;
            this.setValidatorRule('required', required);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Field.prototype, "validateStatus", {
        get: function () {
            if (this.validating)
                return 'validating';
            if (this.selfInvalid)
                return 'error';
            if (this.selfWarnings.length)
                return 'warning';
            if (this.selfSuccesses.length)
                return 'success';
        },
        enumerable: false,
        configurable: true
    });
    return Field;
}(BaseField));

//# sourceMappingURL=Field.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/shared/effective.js
var effective_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var effective_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




var createEffectHook = function (type, callback) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (GlobalState.effectStart) {
            GlobalState.lifecycles.push(new LifeCycle(type, function (payload, ctx) {
                if (checkers_isFn(callback)) {
                    callback.apply(void 0, effective_spreadArray([payload, ctx], effective_read(GlobalState.context), false)).apply(void 0, effective_spreadArray([], effective_read(args), false));
                }
            }));
        }
        else {
            throw new Error('Effect hooks cannot be used in asynchronous function body');
        }
    };
};
var createEffectContext = function (defaultValue) {
    var index;
    return {
        provide: function (value) {
            if (GlobalState.effectStart) {
                index = GlobalState.context.length;
                GlobalState.context[index] = isEmpty_isValid(value) ? value : defaultValue;
            }
            else {
                throw new Error('Provide method cannot be used in asynchronous function body');
            }
        },
        consume: function () {
            if (!GlobalState.effectStart) {
                throw new Error('Consume method cannot be used in asynchronous function body');
            }
            return GlobalState.context[index];
        },
    };
};
var FormEffectContext = createEffectContext();
var useEffectForm = FormEffectContext.consume;
var runEffects = function (context) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    GlobalState.lifecycles = [];
    GlobalState.context = [];
    GlobalState.effectStart = true;
    GlobalState.effectEnd = false;
    if (isForm(context)) {
        FormEffectContext.provide(context);
    }
    args.forEach(function (effects) {
        if (checkers_isFn(effects)) {
            effects(context);
        }
    });
    GlobalState.context = [];
    GlobalState.effectStart = false;
    GlobalState.effectEnd = true;
    return GlobalState.lifecycles;
};
//# sourceMappingURL=effective.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/ArrayField.js
var ArrayField_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ArrayField_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var ArrayField_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




var ArrayField = /** @class */ (function (_super) {
    ArrayField_extends(ArrayField, _super);
    function ArrayField(address, props, form, designable) {
        var _this = _super.call(this, address, props, form, designable) || this;
        _this.displayName = 'ArrayField';
        _this.push = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return action_action(function () {
                var _a;
                if (!checkers_isArr(_this.value)) {
                    _this.value = [];
                }
                (_a = _this.value).push.apply(_a, ArrayField_spreadArray([], ArrayField_read(items), false));
                return _this.onInput(_this.value);
            });
        };
        _this.pop = function () {
            if (!checkers_isArr(_this.value))
                return;
            return action_action(function () {
                var index = _this.value.length - 1;
                spliceArrayState(_this, {
                    startIndex: index,
                    deleteCount: 1,
                });
                _this.value.pop();
                return _this.onInput(_this.value);
            });
        };
        _this.insert = function (index) {
            var items = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                items[_i - 1] = arguments[_i];
            }
            return action_action(function () {
                var _a;
                if (!checkers_isArr(_this.value)) {
                    _this.value = [];
                }
                if (items.length === 0) {
                    return;
                }
                spliceArrayState(_this, {
                    startIndex: index,
                    insertCount: items.length,
                });
                (_a = _this.value).splice.apply(_a, ArrayField_spreadArray([index, 0], ArrayField_read(items), false));
                return _this.onInput(_this.value);
            });
        };
        _this.remove = function (index) {
            if (!checkers_isArr(_this.value))
                return;
            return action_action(function () {
                spliceArrayState(_this, {
                    startIndex: index,
                    deleteCount: 1,
                });
                _this.value.splice(index, 1);
                return _this.onInput(_this.value);
            });
        };
        _this.shift = function () {
            if (!checkers_isArr(_this.value))
                return;
            return action_action(function () {
                _this.value.shift();
                return _this.onInput(_this.value);
            });
        };
        _this.unshift = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return action_action(function () {
                var _a;
                if (!checkers_isArr(_this.value)) {
                    _this.value = [];
                }
                spliceArrayState(_this, {
                    startIndex: 0,
                    insertCount: items.length,
                });
                (_a = _this.value).unshift.apply(_a, ArrayField_spreadArray([], ArrayField_read(items), false));
                return _this.onInput(_this.value);
            });
        };
        _this.move = function (fromIndex, toIndex) {
            if (!checkers_isArr(_this.value))
                return;
            if (fromIndex === toIndex)
                return;
            return action_action(function () {
                move(_this.value, fromIndex, toIndex);
                exchangeArrayState(_this, {
                    fromIndex: fromIndex,
                    toIndex: toIndex,
                });
                return _this.onInput(_this.value);
            });
        };
        _this.moveUp = function (index) {
            if (!checkers_isArr(_this.value))
                return;
            return _this.move(index, index - 1 < 0 ? _this.value.length - 1 : index - 1);
        };
        _this.moveDown = function (index) {
            if (!checkers_isArr(_this.value))
                return;
            return _this.move(index, index + 1 >= _this.value.length ? 0 : index + 1);
        };
        _this.makeAutoCleanable();
        return _this;
    }
    ArrayField.prototype.makeAutoCleanable = function () {
        var _this = this;
        this.disposers.push(reaction(function () { var _a; return (_a = _this.value) === null || _a === void 0 ? void 0 : _a.length; }, function (newLength, oldLength) {
            if (oldLength && !newLength) {
                cleanupArrayChildren(_this, 0);
            }
            else if (newLength < oldLength) {
                cleanupArrayChildren(_this, newLength);
            }
        }));
    };
    return ArrayField;
}(Field));

//# sourceMappingURL=ArrayField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/ObjectField.js
var ObjectField_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var ObjectField = /** @class */ (function (_super) {
    ObjectField_extends(ObjectField, _super);
    function ObjectField(address, props, form, designable) {
        var _this = _super.call(this, address, props, form, designable) || this;
        _this.displayName = 'ObjectField';
        _this.additionalProperties = [];
        _this.addProperty = function (key, value) {
            _this.form.setValuesIn(_this.path.concat(key), value);
            _this.additionalProperties.push(key);
            return _this.onInput(_this.value);
        };
        _this.removeProperty = function (key) {
            _this.form.deleteValuesIn(_this.path.concat(key));
            _this.additionalProperties.splice(_this.additionalProperties.indexOf(key), 1);
            return _this.onInput(_this.value);
        };
        _this.existProperty = function (key) {
            return _this.form.existValuesIn(_this.path.concat(key));
        };
        _this.makeAutoCleanable();
        return _this;
    }
    ObjectField.prototype.makeAutoCleanable = function () {
        var _this = this;
        this.disposers.push(reaction(function () { return Object.keys(_this.value || {}); }, function (newKeys) {
            var filterKeys = _this.additionalProperties.filter(function (key) { return !newKeys.includes(key); });
            cleanupObjectChildren(_this, filterKeys);
        }));
    };
    return ObjectField;
}(Field));

//# sourceMappingURL=ObjectField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/VoidField.js
var VoidField_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var VoidField = /** @class */ (function (_super) {
    VoidField_extends(VoidField, _super);
    function VoidField(address, props, form, designable) {
        var _this = _super.call(this) || this;
        _this.displayName = 'VoidField';
        _this.setState = createStateSetter(_this);
        _this.getState = createStateGetter(_this);
        _this.form = form;
        _this.props = props;
        _this.designable = designable;
        initializeStart();
        _this.locate(address);
        _this.initialize();
        _this.makeObservable();
        _this.makeReactive();
        _this.onInit();
        initializeEnd();
        return _this;
    }
    VoidField.prototype.initialize = function () {
        this.mounted = false;
        this.unmounted = false;
        this.initialized = false;
        this.title = this.props.title;
        this.description = this.props.description;
        this.pattern = this.props.pattern;
        this.display = this.props.display;
        this.hidden = this.props.hidden;
        this.editable = this.props.editable;
        this.disabled = this.props.disabled;
        this.readOnly = this.props.readOnly;
        this.readPretty = this.props.readPretty;
        this.visible = this.props.visible;
        this.content = this.props.content;
        this.data = this.props.data;
        this.decorator = toArr(this.props.decorator);
        this.component = toArr(this.props.component);
    };
    VoidField.prototype.makeObservable = function () {
        if (this.designable)
            return;
        model_define(this, {
            path: esm_observable_observable.ref,
            title: esm_observable_observable.ref,
            description: esm_observable_observable.ref,
            selfDisplay: esm_observable_observable.ref,
            selfPattern: esm_observable_observable.ref,
            initialized: esm_observable_observable.ref,
            mounted: esm_observable_observable.ref,
            unmounted: esm_observable_observable.ref,
            decoratorType: esm_observable_observable.ref,
            componentType: esm_observable_observable.ref,
            content: esm_observable_observable.ref,
            data: esm_observable_observable.shallow,
            decoratorProps: esm_observable_observable,
            componentProps: esm_observable_observable,
            display: esm_observable_observable.computed,
            pattern: esm_observable_observable.computed,
            hidden: esm_observable_observable.computed,
            visible: esm_observable_observable.computed,
            disabled: esm_observable_observable.computed,
            readOnly: esm_observable_observable.computed,
            readPretty: esm_observable_observable.computed,
            editable: esm_observable_observable.computed,
            component: esm_observable_observable.computed,
            decorator: esm_observable_observable.computed,
            indexes: esm_observable_observable.computed,
            setTitle: action_action,
            setDescription: action_action,
            setDisplay: action_action,
            setPattern: action_action,
            setComponent: action_action,
            setComponentProps: action_action,
            setDecorator: action_action,
            setDecoratorProps: action_action,
            setData: action_action,
            setContent: action_action,
            onInit: batch,
            onMount: batch,
            onUnmount: batch,
        });
    };
    VoidField.prototype.makeReactive = function () {
        if (this.designable)
            return;
        createReactions(this);
    };
    return VoidField;
}(BaseField));

//# sourceMappingURL=VoidField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/Form.js
var Form_assign = (undefined && undefined.__assign) || function () {
    Form_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Form_assign.apply(this, arguments);
};













var DEV_TOOLS_HOOK = '__FORMILY_DEV_TOOLS_HOOK__';
var Form = /** @class */ (function () {
    function Form(props) {
        var _this = this;
        this.displayName = 'Form';
        this.fields = {};
        this.requests = {};
        this.indexes = {};
        this.disposers = [];
        /** 创建字段 **/
        this.createField = function (props) {
            var address = Path.parse(props.basePath).concat(props.name);
            var identifier = address.toString();
            if (!identifier)
                return;
            if (!_this.fields[identifier] || _this.props.designable) {
                batch(function () {
                    new Field(address, props, _this, _this.props.designable);
                });
                _this.notify(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
            }
            return _this.fields[identifier];
        };
        this.createArrayField = function (props) {
            var address = Path.parse(props.basePath).concat(props.name);
            var identifier = address.toString();
            if (!identifier)
                return;
            if (!_this.fields[identifier] || _this.props.designable) {
                batch(function () {
                    new ArrayField(address, Form_assign(Form_assign({}, props), { value: checkers_isArr(props.value) ? props.value : [] }), _this, _this.props.designable);
                });
                _this.notify(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
            }
            return _this.fields[identifier];
        };
        this.createObjectField = function (props) {
            var address = Path.parse(props.basePath).concat(props.name);
            var identifier = address.toString();
            if (!identifier)
                return;
            if (!_this.fields[identifier] || _this.props.designable) {
                batch(function () {
                    new ObjectField(address, Form_assign(Form_assign({}, props), { value: isObj(props.value) ? props.value : {} }), _this, _this.props.designable);
                });
                _this.notify(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
            }
            return _this.fields[identifier];
        };
        this.createVoidField = function (props) {
            var address = Path.parse(props.basePath).concat(props.name);
            var identifier = address.toString();
            if (!identifier)
                return;
            if (!_this.fields[identifier] || _this.props.designable) {
                batch(function () {
                    new VoidField(address, props, _this, _this.props.designable);
                });
                _this.notify(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
            }
            return _this.fields[identifier];
        };
        /** 状态操作模型 **/
        this.setValues = function (values, strategy) {
            if (strategy === void 0) { strategy = 'merge'; }
            if (!checkers_isPlainObj(values))
                return;
            if (strategy === 'merge' || strategy === 'deepMerge') {
                merge(_this.values, values, {
                    // never reach
                    arrayMerge: function (target, source) { return source; },
                    assign: true,
                });
            }
            else if (strategy === 'shallowMerge') {
                Object.assign(_this.values, values);
            }
            else {
                _this.values = values;
            }
        };
        this.setInitialValues = function (initialValues, strategy) {
            if (strategy === void 0) { strategy = 'merge'; }
            if (!checkers_isPlainObj(initialValues))
                return;
            if (strategy === 'merge' || strategy === 'deepMerge') {
                merge(_this.initialValues, initialValues, {
                    // never reach
                    arrayMerge: function (target, source) { return source; },
                    assign: true,
                });
            }
            else if (strategy === 'shallowMerge') {
                Object.assign(_this.initialValues, initialValues);
            }
            else {
                _this.initialValues = initialValues;
            }
        };
        this.setValuesIn = function (pattern, value) {
            Path.setIn(_this.values, pattern, value);
        };
        this.deleteValuesIn = function (pattern) {
            Path.deleteIn(_this.values, pattern);
        };
        this.existValuesIn = function (pattern) {
            return Path.existIn(_this.values, pattern);
        };
        this.getValuesIn = function (pattern) {
            return Path.getIn(_this.values, pattern);
        };
        this.setInitialValuesIn = function (pattern, initialValue) {
            Path.setIn(_this.initialValues, pattern, initialValue);
        };
        this.deleteInitialValuesIn = function (pattern) {
            Path.deleteIn(_this.initialValues, pattern);
        };
        this.existInitialValuesIn = function (pattern) {
            return Path.existIn(_this.initialValues, pattern);
        };
        this.getInitialValuesIn = function (pattern) {
            return Path.getIn(_this.initialValues, pattern);
        };
        this.setLoading = function (loading) {
            setLoading(_this, loading);
        };
        this.setSubmitting = function (submitting) {
            setSubmitting(_this, submitting);
        };
        this.setValidating = function (validating) {
            setValidating(_this, validating);
        };
        this.setDisplay = function (display) {
            _this.display = display;
        };
        this.setPattern = function (pattern) {
            _this.pattern = pattern;
        };
        this.addEffects = function (id, effects) {
            if (!_this.heart.hasLifeCycles(id)) {
                _this.heart.addLifeCycles(id, runEffects(_this, effects));
            }
        };
        this.removeEffects = function (id) {
            _this.heart.removeLifeCycles(id);
        };
        this.setEffects = function (effects) {
            _this.heart.setLifeCycles(runEffects(_this, effects));
        };
        this.clearErrors = function (pattern) {
            if (pattern === void 0) { pattern = '*'; }
            _this.query(pattern).forEach(function (field) {
                if (!isVoidField(field)) {
                    field.setFeedback({
                        type: 'error',
                        messages: [],
                    });
                }
            });
        };
        this.clearWarnings = function (pattern) {
            if (pattern === void 0) { pattern = '*'; }
            _this.query(pattern).forEach(function (field) {
                if (!isVoidField(field)) {
                    field.setFeedback({
                        type: 'warning',
                        messages: [],
                    });
                }
            });
        };
        this.clearSuccesses = function (pattern) {
            if (pattern === void 0) { pattern = '*'; }
            _this.query(pattern).forEach(function (field) {
                if (!isVoidField(field)) {
                    field.setFeedback({
                        type: 'success',
                        messages: [],
                    });
                }
            });
        };
        this.query = function (pattern) {
            return new Query({
                pattern: pattern,
                base: '',
                form: _this,
            });
        };
        this.queryFeedbacks = function (search) {
            return _this.query(search.address || search.path || '*').reduce(function (messages, field) {
                if (isVoidField(field))
                    return messages;
                return messages.concat(field
                    .queryFeedbacks(search)
                    .map(function (feedback) { return (Form_assign(Form_assign({}, feedback), { address: field.address.toString(), path: field.path.toString() })); })
                    .filter(function (feedback) { return feedback.messages.length > 0; }));
            }, []);
        };
        this.notify = function (type, payload) {
            _this.heart.publish(type, payload !== null && payload !== void 0 ? payload : _this);
        };
        this.subscribe = function (subscriber) {
            return _this.heart.subscribe(subscriber);
        };
        this.unsubscribe = function (id) {
            _this.heart.unsubscribe(id);
        };
        /**事件钩子**/
        this.onInit = function () {
            _this.initialized = true;
            _this.notify(LifeCycleTypes.ON_FORM_INIT);
        };
        this.onMount = function () {
            _this.mounted = true;
            _this.notify(LifeCycleTypes.ON_FORM_MOUNT);
            if (globalThisPolyfill[DEV_TOOLS_HOOK] && !_this.props.designable) {
                globalThisPolyfill[DEV_TOOLS_HOOK].inject(_this.id, _this);
            }
        };
        this.onUnmount = function () {
            _this.notify(LifeCycleTypes.ON_FORM_UNMOUNT);
            _this.query('*').forEach(function (field) { return field.destroy(false); });
            _this.disposers.forEach(function (dispose) { return dispose(); });
            _this.unmounted = true;
            _this.indexes = {};
            _this.heart.clear();
            if (globalThisPolyfill[DEV_TOOLS_HOOK] && !_this.props.designable) {
                globalThisPolyfill[DEV_TOOLS_HOOK].unmount(_this.id);
            }
        };
        this.setState = createStateSetter(this);
        this.getState = createStateGetter(this);
        this.setFormState = createStateSetter(this);
        this.getFormState = createStateGetter(this);
        this.setFieldState = createBatchStateSetter(this);
        this.getFieldState = createBatchStateGetter(this);
        this.getFormGraph = function () {
            return _this.graph.getGraph();
        };
        this.setFormGraph = function (graph) {
            _this.graph.setGraph(graph);
        };
        this.clearFormGraph = function (pattern, forceClear) {
            if (pattern === void 0) { pattern = '*'; }
            if (forceClear === void 0) { forceClear = true; }
            _this.query(pattern).forEach(function (field) {
                field.destroy(forceClear);
            });
        };
        this.validate = function (pattern) {
            if (pattern === void 0) { pattern = '*'; }
            return batchValidate(_this, pattern);
        };
        this.submit = function (onSubmit) {
            return batchSubmit(_this, onSubmit);
        };
        this.reset = function (pattern, options) {
            if (pattern === void 0) { pattern = '*'; }
            return batchReset(_this, pattern, options);
        };
        this.initialize(props);
        this.makeObservable();
        this.makeReactive();
        this.makeValues();
        this.onInit();
    }
    Form.prototype.initialize = function (props) {
        this.id = uid();
        this.props = Form_assign({}, props);
        this.initialized = false;
        this.submitting = false;
        this.validating = false;
        this.loading = false;
        this.modified = false;
        this.mounted = false;
        this.unmounted = false;
        this.display = this.props.display || 'visible';
        this.pattern = this.props.pattern || 'editable';
        this.editable = this.props.editable;
        this.disabled = this.props.disabled;
        this.readOnly = this.props.readOnly;
        this.readPretty = this.props.readPretty;
        this.visible = this.props.visible;
        this.hidden = this.props.hidden;
        this.graph = new Graph(this);
        this.heart = new Heart({
            lifecycles: this.lifecycles,
            context: this,
        });
    };
    Form.prototype.makeValues = function () {
        this.values = getValidFormValues(this.props.values);
        this.initialValues = getValidFormValues(this.props.initialValues);
    };
    Form.prototype.makeObservable = function () {
        model_define(this, {
            fields: esm_observable_observable.shallow,
            indexes: esm_observable_observable.shallow,
            initialized: esm_observable_observable.ref,
            validating: esm_observable_observable.ref,
            submitting: esm_observable_observable.ref,
            loading: esm_observable_observable.ref,
            modified: esm_observable_observable.ref,
            pattern: esm_observable_observable.ref,
            display: esm_observable_observable.ref,
            mounted: esm_observable_observable.ref,
            unmounted: esm_observable_observable.ref,
            values: esm_observable_observable,
            initialValues: esm_observable_observable,
            valid: esm_observable_observable.computed,
            invalid: esm_observable_observable.computed,
            errors: esm_observable_observable.computed,
            warnings: esm_observable_observable.computed,
            successes: esm_observable_observable.computed,
            hidden: esm_observable_observable.computed,
            visible: esm_observable_observable.computed,
            editable: esm_observable_observable.computed,
            readOnly: esm_observable_observable.computed,
            readPretty: esm_observable_observable.computed,
            disabled: esm_observable_observable.computed,
            setValues: action_action,
            setValuesIn: action_action,
            setInitialValues: action_action,
            setInitialValuesIn: action_action,
            setPattern: action_action,
            setDisplay: action_action,
            setState: action_action,
            deleteInitialValuesIn: action_action,
            deleteValuesIn: action_action,
            setSubmitting: action_action,
            setValidating: action_action,
            reset: action_action,
            submit: action_action,
            validate: action_action,
            onMount: batch,
            onUnmount: batch,
            onInit: batch,
        });
    };
    Form.prototype.makeReactive = function () {
        var _this = this;
        this.disposers.push(observe(this, function (change) {
            triggerFormInitialValuesChange(_this, change);
            triggerFormValuesChange(_this, change);
        }, true));
    };
    Object.defineProperty(Form.prototype, "valid", {
        get: function () {
            return !this.invalid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "invalid", {
        get: function () {
            return this.errors.length > 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "errors", {
        get: function () {
            return this.queryFeedbacks({
                type: 'error',
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "warnings", {
        get: function () {
            return this.queryFeedbacks({
                type: 'warning',
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "successes", {
        get: function () {
            return this.queryFeedbacks({
                type: 'success',
            });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "lifecycles", {
        get: function () {
            return runEffects(this, this.props.effects);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "hidden", {
        get: function () {
            return this.display === 'hidden';
        },
        set: function (hidden) {
            if (!isEmpty_isValid(hidden))
                return;
            if (hidden) {
                this.display = 'hidden';
            }
            else {
                this.display = 'visible';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "visible", {
        get: function () {
            return this.display === 'visible';
        },
        set: function (visible) {
            if (!isEmpty_isValid(visible))
                return;
            if (visible) {
                this.display = 'visible';
            }
            else {
                this.display = 'none';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "editable", {
        get: function () {
            return this.pattern === 'editable';
        },
        set: function (editable) {
            if (!isEmpty_isValid(editable))
                return;
            if (editable) {
                this.pattern = 'editable';
            }
            else {
                this.pattern = 'readPretty';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "readOnly", {
        get: function () {
            return this.pattern === 'readOnly';
        },
        set: function (readOnly) {
            if (!isEmpty_isValid(readOnly))
                return;
            if (readOnly) {
                this.pattern = 'readOnly';
            }
            else {
                this.pattern = 'editable';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "disabled", {
        get: function () {
            return this.pattern === 'disabled';
        },
        set: function (disabled) {
            if (!isEmpty_isValid(disabled))
                return;
            if (disabled) {
                this.pattern = 'disabled';
            }
            else {
                this.pattern = 'editable';
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Form.prototype, "readPretty", {
        get: function () {
            return this.pattern === 'readPretty';
        },
        set: function (readPretty) {
            if (!isEmpty_isValid(readPretty))
                return;
            if (readPretty) {
                this.pattern = 'readPretty';
            }
            else {
                this.pattern = 'editable';
            }
        },
        enumerable: false,
        configurable: true
    });
    return Form;
}());

//# sourceMappingURL=Form.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/models/index.js









//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/shared/externals.js





var createForm = function (options) {
    return new Form(options);
};

//# sourceMappingURL=externals.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/effects/onFormEffects.js




function createFormEffect(type) {
    return createEffectHook(type, function (form) { return function (callback) {
        batch(function () {
            callback(form);
        });
    }; });
}
var onFormInit = createFormEffect(LifeCycleTypes.ON_FORM_INIT);
var onFormMount = createFormEffect(LifeCycleTypes.ON_FORM_MOUNT);
var onFormUnmount = createFormEffect(LifeCycleTypes.ON_FORM_UNMOUNT);
var onFormValuesChange = createFormEffect(LifeCycleTypes.ON_FORM_VALUES_CHANGE);
var onFormInitialValuesChange = createFormEffect(LifeCycleTypes.ON_FORM_INITIAL_VALUES_CHANGE);
var onFormInputChange = createFormEffect(LifeCycleTypes.ON_FORM_INPUT_CHANGE);
var onFormSubmit = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT);
var onFormReset = createFormEffect(LifeCycleTypes.ON_FORM_RESET);
var onFormSubmitStart = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_START);
var onFormSubmitEnd = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_END);
var onFormSubmitSuccess = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_SUCCESS);
var onFormSubmitFailed = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_FAILED);
var onFormSubmitValidateStart = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_START);
var onFormSubmitValidateSuccess = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_SUCCESS);
var onFormSubmitValidateFailed = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_FAILED);
var onFormSubmitValidateEnd = createFormEffect(LifeCycleTypes.ON_FORM_SUBMIT_VALIDATE_END);
var onFormValidateStart = createFormEffect(LifeCycleTypes.ON_FORM_VALIDATE_START);
var onFormValidateSuccess = createFormEffect(LifeCycleTypes.ON_FORM_VALIDATE_SUCCESS);
var onFormValidateFailed = createFormEffect(LifeCycleTypes.ON_FORM_VALIDATE_FAILED);
var onFormValidateEnd = createFormEffect(LifeCycleTypes.ON_FORM_VALIDATE_END);
var onFormGraphChange = createFormEffect(LifeCycleTypes.ON_FORM_GRAPH_CHANGE);
var onFormLoading = createFormEffect(LifeCycleTypes.ON_FORM_LOADING);
function onFormReact(callback) {
    var dispose = null;
    onFormInit(function (form) {
        dispose = autorun(function () {
            if (checkers_isFn(callback))
                callback(form);
        });
    });
    onFormUnmount(function () {
        dispose();
    });
}
//# sourceMappingURL=onFormEffects.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/effects/onFieldEffects.js




function createFieldEffect(type) {
    return createEffectHook(type, function (field, form) {
        return function (pattern, callback) {
            if (Path.parse(pattern).matchAliasGroup(field.address, field.path)) {
                batch(function () {
                    callback(field, form);
                });
            }
        };
    });
}
var _onFieldInit = createFieldEffect(LifeCycleTypes.ON_FIELD_INIT);
var onFieldMount = createFieldEffect(LifeCycleTypes.ON_FIELD_MOUNT);
var onFieldUnmount = createFieldEffect(LifeCycleTypes.ON_FIELD_UNMOUNT);
var onFieldValueChange = createFieldEffect(LifeCycleTypes.ON_FIELD_VALUE_CHANGE);
var onFieldInitialValueChange = createFieldEffect(LifeCycleTypes.ON_FIELD_INITIAL_VALUE_CHANGE);
var onFieldInputValueChange = createFieldEffect(LifeCycleTypes.ON_FIELD_INPUT_VALUE_CHANGE);
var onFieldValidateStart = createFieldEffect(LifeCycleTypes.ON_FIELD_VALIDATE_START);
var onFieldValidateEnd = createFieldEffect(LifeCycleTypes.ON_FIELD_VALIDATE_END);
var onFieldValidating = createFieldEffect(LifeCycleTypes.ON_FIELD_VALIDATING);
var onFieldValidateFailed = createFieldEffect(LifeCycleTypes.ON_FIELD_VALIDATE_FAILED);
var onFieldValidateSuccess = createFieldEffect(LifeCycleTypes.ON_FIELD_VALIDATE_SUCCESS);
var onFieldSubmit = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT);
var onFieldSubmitStart = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_START);
var onFieldSubmitEnd = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_END);
var onFieldSubmitValidateStart = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_START);
var onFieldSubmitValidateEnd = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_END);
var onFieldSubmitSuccess = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_SUCCESS);
var onFieldSubmitFailed = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_FAILED);
var onFieldSubmitValidateSuccess = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_SUCCESS);
var onFieldSubmitValidateFailed = createFieldEffect(LifeCycleTypes.ON_FIELD_SUBMIT_VALIDATE_FAILED);
var onFieldReset = createFieldEffect(LifeCycleTypes.ON_FIELD_RESET);
var onFieldLoading = createFieldEffect(LifeCycleTypes.ON_FIELD_LOADING);
function onFieldInit(pattern, callback) {
    var form = useEffectForm();
    var count = form.query(pattern).reduce(function (count, field) {
        callback(field, form);
        return count + 1;
    }, 0);
    if (count === 0) {
        _onFieldInit(pattern, callback);
    }
}
function onFieldReact(pattern, callback) {
    onFieldInit(pattern, function (field, form) {
        field.disposers.push(autorun(function () {
            if (checkers_isFn(callback))
                callback(field, form);
        }));
    });
}
function onFieldChange(pattern, watches, callback) {
    if (checkers_isFn(watches)) {
        callback = watches;
        watches = ['value'];
    }
    else {
        watches = watches || ['value'];
    }
    onFieldInit(pattern, function (field, form) {
        if (checkers_isFn(callback))
            callback(field, form);
        var dispose = reaction(function () {
            return toArr(watches).map(function (key) {
                return field[key];
            });
        }, function () {
            if (checkers_isFn(callback))
                callback(field, form);
        });
        field.disposers.push(dispose);
    });
}
//# sourceMappingURL=onFieldEffects.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/effects/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+core@2.3.1/node_modules/@formily/core/esm/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/shared.js



var REVA_ACTIONS_KEY = Symbol.for('__REVA_ACTIONS');
var SchemaNestedMap = {
    parent: true,
    root: true,
    properties: true,
    patternProperties: true,
    additionalProperties: true,
    items: true,
    additionalItems: true,
    'x-linkages': true,
    'x-reactions': true,
};
var SchemaStateMap = {
    title: 'title',
    description: 'description',
    default: 'initialValue',
    enum: 'dataSource',
    readOnly: 'readOnly',
    writeOnly: 'editable',
    'x-content': 'content',
    'x-data': 'data',
    'x-value': 'value',
    'x-editable': 'editable',
    'x-disabled': 'disabled',
    'x-read-pretty': 'readPretty',
    'x-read-only': 'readOnly',
    'x-visible': 'visible',
    'x-hidden': 'hidden',
    'x-display': 'display',
    'x-pattern': 'pattern',
    'x-validator': 'validator',
    'x-decorator': 'decoratorType',
    'x-component': 'componentType',
    'x-decorator-props': 'decoratorProps',
    'x-component-props': 'componentProps',
};
var SchemaValidatorMap = {
    required: true,
    format: true,
    maxItems: true,
    minItems: true,
    maxLength: true,
    minLength: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    pattern: true,
    const: true,
    multipleOf: true,
    maxProperties: true,
    minProperties: true,
    uniqueItems: true,
};
var SchemaNormalKeys = Object.keys(SchemaStateMap);
var SchemaValidatorKeys = Object.keys(SchemaValidatorMap);
var shared_hasOwnProperty = Object.prototype.hasOwnProperty;
var traverse = function (target, visitor) {
    var seenObjects = [];
    var root = target;
    var traverse = function (target, path) {
        if (path === void 0) { path = []; }
        if (checkers_isPlainObj(target)) {
            var seenIndex = seenObjects.indexOf(target);
            if (seenIndex > -1) {
                return;
            }
            var addIndex = seenObjects.length;
            seenObjects.push(target);
            if (isNoNeedCompileObject(target) && root !== target) {
                visitor(target, path);
                return;
            }
            array_each(target, function (value, key) {
                traverse(value, path.concat(key));
            });
            seenObjects.splice(addIndex, 1);
        }
        else {
            visitor(target, path);
        }
    };
    traverse(target);
};
var traverseSchema = function (schema, visitor) {
    if (schema['x-validator'] !== undefined) {
        visitor(schema['x-validator'], ['x-validator']);
    }
    var seenObjects = [];
    var root = schema;
    var traverse = function (target, path) {
        var _a;
        if (path === void 0) { path = []; }
        if (path[0] === 'x-compile-omitted' ||
            path[0] === 'x-validator' ||
            path[0] === 'version' ||
            path[0] === '_isJSONSchemaObject')
            return;
        if (String(path[0]).indexOf('x-') == -1 && checkers_isFn(target))
            return;
        if (SchemaNestedMap[path[0]])
            return;
        if (((_a = schema['x-compile-omitted']) === null || _a === void 0 ? void 0 : _a.indexOf(path[0])) > -1) {
            visitor(target, path, true);
            return;
        }
        if (checkers_isPlainObj(target)) {
            if (path[0] === 'default' || path[0] === 'x-value') {
                visitor(target, path);
                return;
            }
            var seenIndex = seenObjects.indexOf(target);
            if (seenIndex > -1) {
                return;
            }
            var addIndex = seenObjects.length;
            seenObjects.push(target);
            if (isNoNeedCompileObject(target) && root !== target) {
                visitor(target, path);
                return;
            }
            array_each(target, function (value, key) {
                traverse(value, path.concat(key));
            });
            seenObjects.splice(addIndex, 1);
        }
        else {
            visitor(target, path);
        }
    };
    traverse(schema);
};
var isNoNeedCompileObject = function (source) {
    if ('$$typeof' in source && '_owner' in source) {
        return true;
    }
    if (source['_isAMomentObject']) {
        return true;
    }
    if (Schema.isSchemaInstance(source)) {
        return true;
    }
    if (source[REVA_ACTIONS_KEY]) {
        return true;
    }
    if (checkers_isFn(source['toJS'])) {
        return true;
    }
    if (checkers_isFn(source['toJSON'])) {
        return true;
    }
    if (isObservable(source)) {
        return true;
    }
    return false;
};
var createDataSource = function (source) {
    return toArr(source).map(function (item) {
        if (typeof item === 'object') {
            return item;
        }
        else {
            return {
                label: item,
                value: item,
            };
        }
    });
};
var patchStateFormSchema = function (targetState, pattern, compiled) {
    untracked(function () {
        var _a;
        var path = Path.parse(pattern);
        var segments = path.segments;
        var key = segments[0];
        var isEnum = key === 'enum' && checkers_isArr(compiled);
        var schemaMapKey = SchemaStateMap[key];
        if (schemaMapKey) {
            Path.setIn(targetState, [schemaMapKey].concat(segments.slice(1)), isEnum ? createDataSource(compiled) : compiled);
        }
        else {
            var isValidatorKey = SchemaValidatorMap[key];
            if (isValidatorKey) {
                (_a = targetState['setValidatorRule']) === null || _a === void 0 ? void 0 : _a.call(targetState, key, compiled);
            }
        }
    });
};
//# sourceMappingURL=shared.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/compiler.js



var ExpRE = /^\s*\{\{([\s\S]*)\}\}\s*$/;
var Registry = {
    silent: false,
    compile: function (expression, scope) {
        if (scope === void 0) { scope = {}; }
        if (Registry.silent) {
            try {
                return new Function('$root', "with($root) { return (".concat(expression, "); }"))(scope);
            }
            catch (_a) { }
        }
        else {
            return new Function('$root', "with($root) { return (".concat(expression, "); }"))(scope);
        }
    },
};
var silent = function (value) {
    if (value === void 0) { value = true; }
    Registry.silent = !!value;
};
var registerCompiler = function (compiler) {
    if (checkers_isFn(compiler)) {
        Registry.compile = compiler;
    }
};
var shallowCompile = function (source, scope) {
    if (checkers_isStr(source)) {
        var matched = source.match(ExpRE);
        if (!matched)
            return source;
        return Registry.compile(matched[1], scope);
    }
    return source;
};
var compile = function (source, scope) {
    var seenObjects = [];
    var compile = function (source) {
        if (checkers_isStr(source)) {
            return shallowCompile(source, scope);
        }
        else if (checkers_isArr(source)) {
            return source.map(function (value) { return compile(value); });
        }
        else if (checkers_isPlainObj(source)) {
            if (isNoNeedCompileObject(source))
                return source;
            var seenIndex = seenObjects.indexOf(source);
            if (seenIndex > -1) {
                return source;
            }
            var addIndex = seenObjects.length;
            seenObjects.push(source);
            var results = reduce(source, function (buf, value, key) {
                buf[key] = compile(value);
                return buf;
            }, {});
            seenObjects.splice(addIndex, 1);
            return results;
        }
        return source;
    };
    return compile(source);
};
var patchCompile = function (targetState, sourceState, scope) {
    traverse(sourceState, function (value, pattern) {
        var compiled = compile(value, scope);
        if (compiled === undefined)
            return;
        var path = Path.parse(pattern);
        var key = path.segments[0];
        if (shared_hasOwnProperty.call(targetState, key)) {
            untracked(function () { return Path.setIn(targetState, path, compiled); });
        }
    });
};
var patchSchemaCompile = function (targetState, sourceSchema, scope, demand) {
    if (demand === void 0) { demand = false; }
    traverseSchema(sourceSchema, function (value, path, omitCompile) {
        var compiled = value;
        var collected = hasCollected(function () {
            if (!omitCompile) {
                compiled = compile(value, scope);
            }
        });
        if (compiled === undefined)
            return;
        if (demand) {
            if (collected || !targetState.initialized) {
                patchStateFormSchema(targetState, path, compiled);
            }
        }
        else {
            patchStateFormSchema(targetState, path, compiled);
        }
    });
};
//# sourceMappingURL=compiler.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/transformer.js
var transformer_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};




var FieldEffects = {
    onFieldInit: onFieldInit,
    onFieldMount: onFieldMount,
    onFieldUnmount: onFieldUnmount,
    onFieldValueChange: onFieldValueChange,
    onFieldInputValueChange: onFieldInputValueChange,
    onFieldInitialValueChange: onFieldInitialValueChange,
    onFieldValidateStart: onFieldValidateStart,
    onFieldValidateEnd: onFieldValidateEnd,
    onFieldValidateFailed: onFieldValidateFailed,
    onFieldValidateSuccess: onFieldValidateSuccess,
};
var DefaultFieldEffects = ['onFieldInit', 'onFieldValueChange'];
var getDependencyValue = function (field, pattern, property) {
    var _a = transformer_read(String(pattern).split(/\s*#\s*/), 2), target = _a[0], path = _a[1];
    return field.query(target).getIn(path || property || 'value');
};
var getDependencies = function (field, dependencies) {
    if (checkers_isArr(dependencies)) {
        var results_1 = [];
        dependencies.forEach(function (pattern) {
            if (checkers_isStr(pattern)) {
                results_1.push(getDependencyValue(field, pattern));
            }
            else if (checkers_isPlainObj(pattern)) {
                if (pattern.name && pattern.source) {
                    results_1[pattern.name] = getDependencyValue(field, pattern.source, pattern.property);
                }
            }
        });
        return results_1;
    }
    else if (checkers_isPlainObj(dependencies)) {
        return reduce(dependencies, function (buf, pattern, key) {
            buf[key] = getDependencyValue(field, pattern);
            return buf;
        }, {});
    }
    return [];
};
var setSchemaFieldState = function (options, demand) {
    if (demand === void 0) { demand = false; }
    var _a = options || {}, request = _a.request, target = _a.target, runner = _a.runner, field = _a.field, scope = _a.scope;
    if (!request)
        return;
    if (target) {
        if (request.state) {
            field.form.setFieldState(target, function (state) {
                return patchCompile(state, request.state, lazyMerge(scope, {
                    $target: state,
                }));
            });
        }
        if (request.schema) {
            field.form.setFieldState(target, function (state) {
                return patchSchemaCompile(state, request.schema, lazyMerge(scope, {
                    $target: state,
                }), demand);
            });
        }
        if (checkers_isStr(runner) && runner) {
            field.form.setFieldState(target, function (state) {
                shallowCompile("{{function(){".concat(runner, "}}}"), lazyMerge(scope, {
                    $target: state,
                }))();
            });
        }
    }
    else {
        if (request.state) {
            field.setState(function (state) { return patchCompile(state, request.state, scope); });
        }
        if (request.schema) {
            field.setState(function (state) {
                return patchSchemaCompile(state, request.schema, scope, demand);
            });
        }
        if (checkers_isStr(runner) && runner) {
            shallowCompile("{{function(){".concat(runner, "}}}"), scope)();
        }
    }
};
var getBaseScope = function (field, options) {
    if (options === void 0) { options = {}; }
    var $observable = function (target, deps) {
        return autorun.memo(function () { return esm_observable_observable(target); }, deps);
    };
    var $props = function (props) { return field.setComponentProps(props); };
    var $effect = autorun.effect;
    var $memo = autorun.memo;
    var $self = field;
    var $form = field.form;
    var $values = field.form.values;
    return lazyMerge({
        get $lookup() {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.scope) === null || _a === void 0 ? void 0 : _a.$record) !== null && _b !== void 0 ? _b : $values;
        },
        get $records() {
            return field.records;
        },
        get $record() {
            var record = field.record;
            if (typeof record === 'object') {
                return lazyMerge(record, {
                    get $lookup() {
                        var _a, _b;
                        return (_b = (_a = options === null || options === void 0 ? void 0 : options.scope) === null || _a === void 0 ? void 0 : _a.$record) !== null && _b !== void 0 ? _b : $values;
                    },
                    get $index() {
                        return field.index;
                    },
                });
            }
            return record;
        },
        get $index() {
            return field.index;
        },
    }, options.scope, {
        $form: $form,
        $self: $self,
        $observable: $observable,
        $effect: $effect,
        $memo: $memo,
        $props: $props,
        $values: $values,
    });
};
var getBaseReactions = function (schema, options) { return function (field) {
    setSchemaFieldState({
        field: field,
        request: { schema: schema },
        scope: getBaseScope(field, options),
    }, true);
}; };
var getUserReactions = function (schema, options) {
    var reactions = toArr(schema['x-reactions']);
    return reactions.map(function (unCompiled) {
        return function (field) {
            var baseScope = getBaseScope(field, options);
            var reaction = shallowCompile(unCompiled, baseScope);
            if (!reaction)
                return;
            if (checkers_isFn(reaction)) {
                return reaction(field, baseScope);
            }
            var when = reaction.when, fulfill = reaction.fulfill, otherwise = reaction.otherwise, target = reaction.target, effects = reaction.effects;
            var run = function () {
                var $deps = getDependencies(field, reaction.dependencies);
                var $dependencies = $deps;
                var scope = lazyMerge(baseScope, {
                    $target: null,
                    $deps: $deps,
                    $dependencies: $dependencies,
                });
                var compiledWhen = shallowCompile(when, scope);
                var condition = when ? compiledWhen : true;
                var request = condition ? fulfill : otherwise;
                var runner = request === null || request === void 0 ? void 0 : request.run;
                setSchemaFieldState({
                    field: field,
                    target: target,
                    request: request,
                    runner: runner,
                    scope: scope,
                });
            };
            if (target) {
                reaction.effects = (effects === null || effects === void 0 ? void 0 : effects.length) ? effects : DefaultFieldEffects;
            }
            if (reaction.effects) {
                autorun.memo(function () {
                    untracked(function () {
                        array_each(reaction.effects, function (type) {
                            if (FieldEffects[type]) {
                                FieldEffects[type](field.address, run);
                            }
                        });
                    });
                }, []);
            }
            else {
                run();
            }
        };
    });
};
var transformFieldProps = function (schema, options) {
    return {
        name: schema.name,
        reactions: [getBaseReactions(schema, options)].concat(getUserReactions(schema, options)),
    };
};
//# sourceMappingURL=transformer.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/patches.js
var patches_assign = (undefined && undefined.__assign) || function () {
    patches_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return patches_assign.apply(this, arguments);
};

var patches = [];
var polyfills = {};
var reducePatches = function (schema) {
    return patches.reduce(function (buf, patch) {
        return patch(buf);
    }, patches_assign({}, schema));
};
var registerPatches = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    args.forEach(function (patch) {
        if (checkers_isFn(patch)) {
            patches.push(patch);
        }
    });
};
var registerPolyfills = function (version, patch) {
    if (version && checkers_isFn(patch)) {
        polyfills[version] = polyfills[version] || [];
        polyfills[version].push(patch);
    }
};
var enablePolyfills = function (versions) {
    if (checkers_isArr(versions)) {
        versions.forEach(function (version) {
            if (checkers_isArr(polyfills[version])) {
                polyfills[version].forEach(function (patch) {
                    registerPatches(patch);
                });
            }
        });
    }
};
//# sourceMappingURL=patches.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/polyfills/SPECIFICATION_1_0.js
var SPECIFICATION_1_0_assign = (undefined && undefined.__assign) || function () {
    SPECIFICATION_1_0_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return SPECIFICATION_1_0_assign.apply(this, arguments);
};
var SPECIFICATION_1_0_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var SPECIFICATION_1_0_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};


var VOID_COMPONENTS = [
    'card',
    'block',
    'grid-col',
    'grid-row',
    'grid',
    'layout',
    'step',
    'tab',
    'text-box',
];
var TYPE_DEFAULT_COMPONENTS = {};
var transformCondition = function (condition) {
    if (checkers_isStr(condition)) {
        return condition.replace(/\$value/, '$self.value');
    }
};
var transformXLinkage = function (linkages) {
    if (checkers_isArr(linkages)) {
        return linkages.reduce(function (buf, item) {
            if (!item)
                return buf;
            if (item.type === 'value:visible') {
                return buf.concat({
                    target: item.target,
                    when: transformCondition(item.condition),
                    fulfill: {
                        state: {
                            visible: true,
                        },
                    },
                    otherwise: {
                        state: {
                            visible: false,
                        },
                    },
                });
            }
            else if (item.type === 'value:schema') {
                return buf.concat({
                    target: item.target,
                    when: transformCondition(item.condition),
                    fulfill: {
                        schema: SpecificationV1Polyfill(SPECIFICATION_1_0_assign({ version: '1.0' }, item.schema)),
                    },
                    otherwise: {
                        schema: SpecificationV1Polyfill(SPECIFICATION_1_0_assign({ version: '1.0' }, item.otherwise)),
                    },
                });
            }
            else if (item.type === 'value:state') {
                return buf.concat({
                    target: item.target,
                    when: transformCondition(item.condition),
                    fulfill: {
                        state: item.state,
                    },
                    otherwise: {
                        state: item.otherwise,
                    },
                });
            }
        }, []);
    }
    return [];
};
var SpecificationV1Polyfill = function (schema) {
    if (isEmpty_isValid(schema['editable'])) {
        schema['x-editable'] = schema['x-editable'] || schema['editable'];
        delete schema['editable'];
    }
    if (isEmpty_isValid(schema['visible'])) {
        schema['x-visible'] = schema['x-visible'] || schema['visible'];
        delete schema['visible'];
    }
    if (isEmpty_isValid(schema['display'])) {
        schema['x-display'] =
            schema['x-display'] || (schema['display'] ? 'visible' : 'hidden');
        delete schema['display'];
    }
    if (isEmpty_isValid(schema['x-props'])) {
        schema['x-decorator-props'] =
            schema['x-decorator-props'] || schema['x-props'];
        delete schema['display'];
    }
    if (schema['x-linkages']) {
        schema['x-reactions'] = toArr(schema['x-reactions']).concat(transformXLinkage(schema['x-linkages']));
        delete schema['x-linkages'];
    }
    if (schema['x-component']) {
        if (VOID_COMPONENTS.some(function (component) { return lowerCase(component) === lowerCase(schema['x-component']); })) {
            schema['type'] = 'void';
        }
    }
    else {
        if (TYPE_DEFAULT_COMPONENTS[schema['type']]) {
            schema['x-component'] = TYPE_DEFAULT_COMPONENTS[schema['type']];
        }
    }
    if (!schema['x-decorator'] &&
        schema['type'] !== 'void' &&
        schema['type'] !== 'object') {
        schema['x-decorator'] = schema['x-decorator'] || 'FormItem';
    }
    if (schema['x-rules']) {
        schema['x-validator'] = []
            .concat(schema['x-validator'] || [])
            .concat(schema['x-rules']);
    }
    return schema;
};
registerPolyfills('1.0', SpecificationV1Polyfill);
var registerVoidComponents = function (components) {
    VOID_COMPONENTS.push.apply(VOID_COMPONENTS, SPECIFICATION_1_0_spreadArray([], SPECIFICATION_1_0_read(components), false));
};
var registerTypeDefaultComponents = function (maps) {
    Object.assign(TYPE_DEFAULT_COMPONENTS, maps);
};
//# sourceMappingURL=SPECIFICATION_1_0.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/polyfills/index.js

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/schema.js






var Schema = /** @class */ (function () {
    function Schema(json, parent) {
        var _this = this;
        this._isJSONSchemaObject = true;
        this.version = '2.0';
        this.addProperty = function (key, schema) {
            _this.properties = _this.properties || {};
            _this.properties[key] = new Schema(schema, _this);
            _this.properties[key].name = key;
            return _this.properties[key];
        };
        this.removeProperty = function (key) {
            var schema = _this.properties[key];
            delete _this.properties[key];
            return schema;
        };
        this.setProperties = function (properties) {
            for (var key in properties) {
                _this.addProperty(key, properties[key]);
            }
            return _this;
        };
        this.addPatternProperty = function (key, schema) {
            if (!schema)
                return;
            _this.patternProperties = _this.patternProperties || {};
            _this.patternProperties[key] = new Schema(schema, _this);
            _this.patternProperties[key].name = key;
            return _this.patternProperties[key];
        };
        this.removePatternProperty = function (key) {
            var schema = _this.patternProperties[key];
            delete _this.patternProperties[key];
            return schema;
        };
        this.setPatternProperties = function (properties) {
            if (!properties)
                return _this;
            for (var key in properties) {
                _this.addPatternProperty(key, properties[key]);
            }
            return _this;
        };
        this.setAdditionalProperties = function (properties) {
            if (!properties)
                return;
            _this.additionalProperties = new Schema(properties);
            return _this.additionalProperties;
        };
        this.setItems = function (schema) {
            if (!schema)
                return;
            if (Array.isArray(schema)) {
                _this.items = schema.map(function (item) { return new Schema(item, _this); });
            }
            else {
                _this.items = new Schema(schema, _this);
            }
            return _this.items;
        };
        this.setAdditionalItems = function (items) {
            if (!items)
                return;
            _this.additionalItems = new Schema(items, _this);
            return _this.additionalItems;
        };
        this.findDefinitions = function (ref) {
            if (!ref || !_this.root || !checkers_isStr(ref))
                return;
            if (ref.indexOf('#/') !== 0)
                return;
            return Path.getIn(_this.root, ref.substring(2).split('/'));
        };
        this.mapProperties = function (callback) {
            return Schema.getOrderProperties(_this).map(function (_a, index) {
                var schema = _a.schema, key = _a.key;
                return callback(schema, key, index);
            });
        };
        this.mapPatternProperties = function (callback) {
            return Schema.getOrderProperties(_this, 'patternProperties').map(function (_a, index) {
                var schema = _a.schema, key = _a.key;
                return callback(schema, key, index);
            });
        };
        this.reduceProperties = function (callback, predicate) {
            var results = predicate;
            Schema.getOrderProperties(_this, 'properties').forEach(function (_a, index) {
                var schema = _a.schema, key = _a.key;
                results = callback(results, schema, key, index);
            });
            return results;
        };
        this.reducePatternProperties = function (callback, predicate) {
            var results = predicate;
            Schema.getOrderProperties(_this, 'patternProperties').forEach(function (_a, index) {
                var schema = _a.schema, key = _a.key;
                results = callback(results, schema, key, index);
            });
            return results;
        };
        this.compile = function (scope) {
            var schema = new Schema({}, _this.parent);
            array_each(_this, function (value, key) {
                if (checkers_isFn(value) && !key.includes('x-'))
                    return;
                if (key === 'parent' || key === 'root')
                    return;
                if (!SchemaNestedMap[key]) {
                    schema[key] = value ? compile(value, scope) : value;
                }
                else {
                    schema[key] = value ? shallowCompile(value, scope) : value;
                }
            });
            return schema;
        };
        this.fromJSON = function (json) {
            if (!json)
                return _this;
            if (Schema.isSchemaInstance(json))
                return json;
            array_each(reducePatches(json), function (value, key) {
                if (checkers_isFn(value) && !key.includes('x-'))
                    return;
                if (key === 'properties') {
                    _this.setProperties(value);
                }
                else if (key === 'patternProperties') {
                    _this.setPatternProperties(value);
                }
                else if (key === 'additionalProperties') {
                    _this.setAdditionalProperties(value);
                }
                else if (key === 'items') {
                    _this.setItems(value);
                }
                else if (key === 'additionalItems') {
                    _this.setAdditionalItems(value);
                }
                else if (key === '$ref') {
                    _this.fromJSON(_this.findDefinitions(value));
                }
                else {
                    _this[key] = value;
                }
            });
            return _this;
        };
        this.toJSON = function (recursion) {
            if (recursion === void 0) { recursion = true; }
            var results = {};
            array_each(_this, function (value, key) {
                var _a, _b;
                if ((checkers_isFn(value) && !key.includes('x-')) ||
                    key === 'parent' ||
                    key === 'root')
                    return;
                if (key === 'properties' || key === 'patternProperties') {
                    if (!recursion)
                        return;
                    results[key] = map(value, function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });
                }
                else if (key === 'additionalProperties' || key === 'additionalItems') {
                    if (!recursion)
                        return;
                    results[key] = (_a = value === null || value === void 0 ? void 0 : value.toJSON) === null || _a === void 0 ? void 0 : _a.call(value);
                }
                else if (key === 'items') {
                    if (!recursion)
                        return;
                    if (Array.isArray(value)) {
                        results[key] = value.map(function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.toJSON) === null || _a === void 0 ? void 0 : _a.call(item); });
                    }
                    else {
                        results[key] = (_b = value === null || value === void 0 ? void 0 : value.toJSON) === null || _b === void 0 ? void 0 : _b.call(value);
                    }
                }
                else {
                    results[key] = value;
                }
            });
            return results;
        };
        this.toFieldProps = function (options) {
            return transformFieldProps(_this, options);
        };
        if (parent) {
            this.parent = parent;
            this.root = parent.root;
        }
        else {
            this.root = this;
        }
        return this.fromJSON(json);
    }
    Schema.getOrderProperties = function (schema, propertiesName) {
        if (schema === void 0) { schema = {}; }
        if (propertiesName === void 0) { propertiesName = 'properties'; }
        var orderProperties = [];
        var unorderProperties = [];
        for (var key in schema[propertiesName]) {
            var item = schema[propertiesName][key];
            var index = item['x-index'];
            if (!isNaN(index)) {
                orderProperties[index] = { schema: item, key: key };
            }
            else {
                unorderProperties.push({ schema: item, key: key });
            }
        }
        return orderProperties.concat(unorderProperties).filter(function (item) { return !!item; });
    };
    Schema.compile = function (expression, scope) {
        return compile(expression, scope);
    };
    Schema.shallowCompile = function (expression, scope) {
        return shallowCompile(expression, scope);
    };
    Schema.isSchemaInstance = function (value) {
        return instOf(value, Schema);
    };
    Schema.registerCompiler = registerCompiler;
    Schema.registerPatches = registerPatches;
    Schema.registerVoidComponents = registerVoidComponents;
    Schema.registerTypeDefaultComponents = registerTypeDefaultComponents;
    Schema.registerPolyfills = registerPolyfills;
    Schema.enablePolyfills = enablePolyfills;
    Schema.silent = silent;
    return Schema;
}());

//# sourceMappingURL=schema.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+json-schema@2.3.1_typescript@5.4.5/node_modules/@formily/json-schema/esm/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: external "React"
const external_React_namespaceObject = globalThis["React"];
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_namespaceObject);
// EXTERNAL MODULE: ./node_modules/.pnpm/hoist-non-react-statics@3.3.2/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(35);
var hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/useLayoutEffect.js

var useLayoutEffect_useLayoutEffect = typeof document !== 'undefined' ? external_React_namespaceObject.useLayoutEffect : external_React_namespaceObject.useEffect;
//# sourceMappingURL=useLayoutEffect.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/shared/global.js
/* istanbul ignore next */
function global_globalSelf() {
    try {
        if (typeof self !== 'undefined') {
            return self;
        }
    }
    catch (e) { }
    try {
        if (typeof window !== 'undefined') {
            return window;
        }
    }
    catch (e) { }
    try {
        if (typeof __webpack_require__.g !== 'undefined') {
            return __webpack_require__.g;
        }
    }
    catch (e) { }
    return Function('return this')();
}
var global_globalThisPolyfill = global_globalSelf();
//# sourceMappingURL=global.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/shared/gc.js

var gc_registry = global_globalThisPolyfill['FinalizationRegistry'] &&
    new global_globalThisPolyfill['FinalizationRegistry'](function (token) { var _a; return (_a = token === null || token === void 0 ? void 0 : token.clean) === null || _a === void 0 ? void 0 : _a.call(token); });
var GarbageCollector = /** @class */ (function () {
    function GarbageCollector(clean, expireTime) {
        if (expireTime === void 0) { expireTime = 10000; }
        this.token = {
            clean: clean,
        };
        this.expireTime = expireTime;
    }
    GarbageCollector.prototype.open = function (target) {
        var _this = this;
        if (gc_registry) {
            gc_registry.register(target, this.token, this.token);
        }
        else {
            this.request = setTimeout(function () {
                var _a, _b;
                (_b = (_a = _this.token) === null || _a === void 0 ? void 0 : _a.clean) === null || _b === void 0 ? void 0 : _b.call(_a);
            }, this.expireTime);
        }
    };
    GarbageCollector.prototype.close = function () {
        if (gc_registry) {
            gc_registry.unregister(this.token);
        }
        else {
            clearTimeout(this.request);
        }
    };
    return GarbageCollector;
}());

//# sourceMappingURL=gc.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/shared/immediate.js
var immediate = function (callback) {
    var disposed = false;
    Promise.resolve(0).then(function () {
        if (disposed) {
            disposed = false;
            return;
        }
        callback();
    });
    return function () {
        disposed = true;
    };
};
//# sourceMappingURL=immediate.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/shared/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/useDidUpdate.js



var useDidUpdate_useDidUpdate = function (callback) {
    var request = (0,external_React_namespaceObject.useRef)(null);
    request.current = immediate(callback);
    useLayoutEffect_useLayoutEffect(function () {
        request.current();
        callback();
    });
};
//# sourceMappingURL=useDidUpdate.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/useForceUpdate.js
var useForceUpdate_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};



var EMPTY_ARRAY = [];
var RENDER_COUNT = { value: 0 };
var RENDER_QUEUE = new Set();
function useForceUpdate_useForceUpdate() {
    var _a = useForceUpdate_read((0,external_React_namespaceObject.useState)([]), 2), setState = _a[1];
    var firstRenderedRef = (0,external_React_namespaceObject.useRef)(false);
    var needUpdateRef = (0,external_React_namespaceObject.useRef)(false);
    useLayoutEffect_useLayoutEffect(function () {
        firstRenderedRef.current = true;
        if (needUpdateRef.current) {
            setState([]);
            needUpdateRef.current = false;
        }
        return function () {
            firstRenderedRef.current = false;
        };
    }, EMPTY_ARRAY);
    var update = (0,external_React_namespaceObject.useCallback)(function () {
        setState([]);
    }, EMPTY_ARRAY);
    var scheduler = (0,external_React_namespaceObject.useCallback)(function () {
        if (!firstRenderedRef.current) {
            // 针对StrictMode无法快速回收内存，只能考虑拦截第一次渲染函数的setState，
            // 因为第一次渲染函数的setState会触发第二次渲染函数执行，从而清理掉第二次渲染函数内部的依赖
            needUpdateRef.current = true;
            return;
        }
        if (RENDER_COUNT.value === 0) {
            update();
        }
        else {
            RENDER_QUEUE.add(update);
        }
    }, EMPTY_ARRAY);
    RENDER_COUNT.value++;
    useDidUpdate_useDidUpdate(function () {
        if (RENDER_COUNT.value > 0) {
            RENDER_COUNT.value--;
        }
        if (RENDER_COUNT.value === 0) {
            RENDER_QUEUE.forEach(function (update) {
                RENDER_QUEUE.delete(update);
                update();
            });
        }
    });
    return scheduler;
}
//# sourceMappingURL=useForceUpdate.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/useCompatEffect.js


var useCompatEffect_isArr = Array.isArray;
var isEqualDeps = function (target, source) {
    var arrA = useCompatEffect_isArr(target);
    var arrB = useCompatEffect_isArr(source);
    if (arrA !== arrB)
        return false;
    if (arrA) {
        if (target.length !== source.length)
            return false;
        return target.every(function (val, index) { return val === source[index]; });
    }
    return target === source;
};
var useCompatEffect = function (effect, deps) {
    var depsRef = (0,external_React_namespaceObject.useRef)(null);
    var mountedRef = (0,external_React_namespaceObject.useRef)(false);
    (0,external_React_namespaceObject.useEffect)(function () {
        mountedRef.current = true;
        var dispose = effect();
        return function () {
            mountedRef.current = false;
            if (!isEqualDeps(depsRef.current, deps)) {
                if (dispose)
                    dispose();
                return;
            }
            immediate(function () {
                if (mountedRef.current)
                    return;
                if (dispose)
                    dispose();
            });
        };
    }, deps);
    depsRef.current = deps;
};
//# sourceMappingURL=useCompatEffect.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/useCompatFactory.js
var useCompatFactory_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};



var ObjectToBeRetainedByReact = /** @class */ (function () {
    function ObjectToBeRetainedByReact() {
    }
    return ObjectToBeRetainedByReact;
}());
function objectToBeRetainedByReactFactory() {
    return new ObjectToBeRetainedByReact();
}
var useCompatFactory = function (factory) {
    var instRef = external_React_default().useRef(null);
    var gcRef = external_React_default().useRef();
    var _a = useCompatFactory_read(external_React_default().useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];
    if (!instRef.current) {
        instRef.current = factory();
    }
    //StrictMode/ConcurrentMode会导致组件无法正确触发UnMount，所以只能自己做垃圾回收
    if (!gcRef.current) {
        gcRef.current = new GarbageCollector(function () {
            if (instRef.current) {
                instRef.current.dispose();
            }
        });
        gcRef.current.open(objectRetainedByReact);
    }
    useCompatEffect(function () {
        gcRef.current.close();
        return function () {
            if (instRef.current) {
                instRef.current.dispose();
                instRef.current = null;
            }
        };
    }, []);
    return instRef.current;
};
//# sourceMappingURL=useCompatFactory.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/useObserver.js



var useObserver_useObserver = function (view, options) {
    var forceUpdate = useForceUpdate_useForceUpdate();
    var tracker = useCompatFactory(function () {
        return new Tracker(function () {
            if (typeof (options === null || options === void 0 ? void 0 : options.scheduler) === 'function') {
                options.scheduler(forceUpdate);
            }
            else {
                forceUpdate();
            }
        }, options === null || options === void 0 ? void 0 : options.displayName);
    });
    return tracker.track(view);
};
//# sourceMappingURL=useObserver.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/observer.js
var observer_assign = (undefined && undefined.__assign) || function () {
    observer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return observer_assign.apply(this, arguments);
};



function observer(component, options) {
    var realOptions = observer_assign({ forwardRef: false }, options);
    var wrappedComponent = realOptions.forwardRef
        ? (0,external_React_namespaceObject.forwardRef)(function (props, ref) {
            return useObserver_useObserver(function () { return component(observer_assign(observer_assign({}, props), { ref: ref })); }, realOptions);
        })
        : function (props) {
            return useObserver_useObserver(function () { return component(props); }, realOptions);
        };
    var memoComponent = (0,external_React_namespaceObject.memo)(wrappedComponent);
    hoist_non_react_statics_cjs_default()(memoComponent, component);
    if (realOptions.displayName) {
        memoComponent.displayName = realOptions.displayName;
    }
    return memoComponent;
}
var Observer = observer(function (props) {
    var children = typeof props.children === 'function' ? props.children() : props.children;
    return external_React_default().createElement(external_React_namespaceObject.Fragment, {}, children);
});
//# sourceMappingURL=observer.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/hooks/index.js






var unstable_useForceUpdate = (/* unused pure expression or super */ null && (useForceUpdate));
var unstable_useCompatEffect = useCompatEffect;
var unstable_useCompatFactory = useCompatFactory;
var unstable_useDidUpdate = (/* unused pure expression or super */ null && (useDidUpdate));
var unstable_useLayoutEffect = (/* unused pure expression or super */ null && (useLayoutEffect));
var unstable_useObserver = (/* unused pure expression or super */ null && (useObserver));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive-react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_re_v3cwybfusholdzscqjhu6vhxyu/node_modules/@formily/reactive-react/esm/index.js



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useAttach.js

var useAttach = function (target) {
    unstable_useCompatEffect(function () {
        target.onMount();
        return function () { return target.onUnmount(); };
    }, [target]);
    return target;
};
//# sourceMappingURL=useAttach.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/shared/context.js

var createContextCleaner = function () {
    var contexts = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        contexts[_i] = arguments[_i];
    }
    return function (_a) {
        var children = _a.children;
        return contexts.reduce(function (buf, ctx) {
            return external_React_default().createElement(ctx.Provider, { value: undefined }, buf);
        }, children);
    };
};
var FormContext = (0,external_React_namespaceObject.createContext)(null);
var FieldContext = (0,external_React_namespaceObject.createContext)(null);
var SchemaMarkupContext = (0,external_React_namespaceObject.createContext)(null);
var SchemaContext = (0,external_React_namespaceObject.createContext)(null);
var SchemaExpressionScopeContext = (0,external_React_namespaceObject.createContext)(null);
var SchemaComponentsContext = (0,external_React_namespaceObject.createContext)(null);
var SchemaOptionsContext = (0,external_React_namespaceObject.createContext)(null);
var ContextCleaner = createContextCleaner(FieldContext, SchemaMarkupContext, SchemaContext, SchemaExpressionScopeContext, SchemaComponentsContext, SchemaOptionsContext);
//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useForm.js


var useForm = function () {
    return (0,external_React_namespaceObject.useContext)(FormContext);
};
//# sourceMappingURL=useForm.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useField.js


var useField = function () {
    return (0,external_React_namespaceObject.useContext)(FieldContext);
};
//# sourceMappingURL=useField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useParentForm.js



var useParentForm = function () {
    var field = useField();
    var form = useForm();
    var findObjectParent = function (field) {
        if (!field)
            return form;
        if (isObjectField(field))
            return field;
        return findObjectParent(field === null || field === void 0 ? void 0 : field.parent);
    };
    return findObjectParent(field);
};
//# sourceMappingURL=useParentForm.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useFieldSchema.js


var useFieldSchema = function () {
    return (0,external_React_namespaceObject.useContext)(SchemaContext);
};
//# sourceMappingURL=useFieldSchema.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useFormEffects.js



var useFormEffects = function (effects) {
    var form = useForm();
    unstable_useCompatFactory(function () {
        var id = uid();
        form.addEffects(id, effects);
        return {
            dispose: function () {
                form.removeEffects(id);
            },
        };
    });
};
//# sourceMappingURL=useFormEffects.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/useExpressionScope.js


var useExpressionScope = function () { return (0,external_React_namespaceObject.useContext)(SchemaExpressionScopeContext); };
//# sourceMappingURL=useExpressionScope.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/hooks/index.js






//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/shared/connect.js
var connect_assign = (undefined && undefined.__assign) || function () {
    connect_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return connect_assign.apply(this, arguments);
};






function mapProps() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (target) {
        return observer(function (props) {
            var field = useField();
            var results = args.reduce(function (props, mapper) {
                if (checkers_isFn(mapper)) {
                    props = Object.assign(props, mapper(props, field));
                }
                else {
                    array_each(mapper, function (to, extract) {
                        var extractValue = Path.getIn(field, extract);
                        var targetValue = checkers_isStr(to) ? to : extract;
                        var originalValue = Path.getIn(props, targetValue);
                        if (extract === 'value') {
                            if (to !== extract) {
                                delete props.value;
                            }
                        }
                        if (isEmpty_isValid(originalValue) && !isEmpty_isValid(extractValue))
                            return;
                        Path.setIn(props, targetValue, extractValue);
                    });
                }
                return props;
            }, connect_assign({}, props));
            return external_React_default().createElement(target, results);
        }, {
            forwardRef: true,
        });
    };
}
function mapReadPretty(component, readPrettyProps) {
    return function (target) {
        return observer(function (props) {
            var field = useField();
            if (!isVoidField(field) && (field === null || field === void 0 ? void 0 : field.pattern) === 'readPretty') {
                return external_React_default().createElement(component, connect_assign(connect_assign({}, readPrettyProps), props));
            }
            return external_React_default().createElement(target, props);
        }, {
            forwardRef: true,
        });
    };
}
function connect(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var Target = args.reduce(function (target, mapper) {
        return mapper(target);
    }, target);
    var Destination = external_React_default().forwardRef(function (props, ref) {
        return external_React_default().createElement(Target, connect_assign(connect_assign({}, props), { ref: ref }));
    });
    if (target)
        hoist_non_react_statics_cjs_default()(Destination, target);
    return Destination;
}

//# sourceMappingURL=connect.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/shared/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/FormProvider.js



var FormProvider = function (props) {
    var form = useAttach(props.form);
    return (external_React_default().createElement(ContextCleaner, null,
        external_React_default().createElement(FormContext.Provider, { value: form }, props.children)));
};
FormProvider.displayName = 'FormProvider';
//# sourceMappingURL=FormProvider.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/FormConsumer.js




var FormConsumer = observer(function (props) {
    var children = checkers_isFn(props.children) ? props.children(useForm()) : null;
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, children);
});
FormConsumer.displayName = 'FormConsumer';
//# sourceMappingURL=FormConsumer.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/ReactiveField.js
var ReactiveField_assign = (undefined && undefined.__assign) || function () {
    ReactiveField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ReactiveField_assign.apply(this, arguments);
};
var ReactiveField_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var ReactiveField_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};






var mergeChildren = function (children, content) {
    if (!children && !content)
        return;
    if (checkers_isFn(children))
        return;
    return (external_React_default().createElement(external_React_namespaceObject.Fragment, null,
        children,
        content));
};
var isValidComponent = function (target) {
    return target && (typeof target === 'object' || typeof target === 'function');
};
var renderChildren = function (children, field, form) { return (checkers_isFn(children) ? children(field, form) : children); };
var ReactiveInternal = function (props) {
    var _a;
    var components = (0,external_React_namespaceObject.useContext)(SchemaComponentsContext);
    if (!props.field) {
        return external_React_default().createElement(external_React_namespaceObject.Fragment, null, renderChildren(props.children));
    }
    var field = props.field;
    var content = mergeChildren(renderChildren(props.children, field, field.form), (_a = field.content) !== null && _a !== void 0 ? _a : field.componentProps.children);
    if (field.display !== 'visible')
        return null;
    var getComponent = function (target) {
        var _a;
        return isValidComponent(target)
            ? target
            : (_a = Path.getIn(components, target)) !== null && _a !== void 0 ? _a : target;
    };
    var renderDecorator = function (children) {
        if (!field.decoratorType) {
            return external_React_default().createElement(external_React_namespaceObject.Fragment, null, children);
        }
        return external_React_default().createElement(getComponent(field.decoratorType), toJS(field.decoratorProps), children);
    };
    var renderComponent = function () {
        var _a, _b, _c;
        if (!field.componentType)
            return content;
        var value = !isVoidField(field) ? field.value : undefined;
        var onChange = !isVoidField(field)
            ? function () {
                var _a, _b;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                field.onInput.apply(field, ReactiveField_spreadArray([], ReactiveField_read(args), false));
                (_b = (_a = field.componentProps) === null || _a === void 0 ? void 0 : _a.onChange) === null || _b === void 0 ? void 0 : _b.call.apply(_b, ReactiveField_spreadArray([_a], ReactiveField_read(args), false));
            }
            : (_a = field.componentProps) === null || _a === void 0 ? void 0 : _a.onChange;
        var onFocus = !isVoidField(field)
            ? function () {
                var _a, _b;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                field.onFocus.apply(field, ReactiveField_spreadArray([], ReactiveField_read(args), false));
                (_b = (_a = field.componentProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call.apply(_b, ReactiveField_spreadArray([_a], ReactiveField_read(args), false));
            }
            : (_b = field.componentProps) === null || _b === void 0 ? void 0 : _b.onFocus;
        var onBlur = !isVoidField(field)
            ? function () {
                var _a, _b;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                field.onBlur.apply(field, ReactiveField_spreadArray([], ReactiveField_read(args), false));
                (_b = (_a = field.componentProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call.apply(_b, ReactiveField_spreadArray([_a], ReactiveField_read(args), false));
            }
            : (_c = field.componentProps) === null || _c === void 0 ? void 0 : _c.onBlur;
        var disabled = !isVoidField(field)
            ? field.pattern === 'disabled' || field.pattern === 'readPretty'
            : undefined;
        var readOnly = !isVoidField(field)
            ? field.pattern === 'readOnly'
            : undefined;
        return external_React_default().createElement(getComponent(field.componentType), ReactiveField_assign(ReactiveField_assign({ disabled: disabled, readOnly: readOnly }, toJS(field.componentProps)), { value: value, onChange: onChange, onFocus: onFocus, onBlur: onBlur }), content);
    };
    return renderDecorator(renderComponent());
};
ReactiveInternal.displayName = 'ReactiveField';
var ReactiveField = observer(ReactiveInternal, {
    forwardRef: true,
});
//# sourceMappingURL=ReactiveField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/ArrayField.js
var ArrayField_assign = (undefined && undefined.__assign) || function () {
    ArrayField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ArrayField_assign.apply(this, arguments);
};





var ArrayField_ArrayField = function (props) {
    var form = useForm();
    var parent = useField();
    var field = useAttach(form.createArrayField(ArrayField_assign({ basePath: parent === null || parent === void 0 ? void 0 : parent.address }, props)));
    return (external_React_default().createElement(FieldContext.Provider, { value: field },
        external_React_default().createElement(ReactiveField, { field: field }, props.children)));
};
ArrayField_ArrayField.displayName = 'ArrayField';
//# sourceMappingURL=ArrayField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/ObjectField.js
var ObjectField_assign = (undefined && undefined.__assign) || function () {
    ObjectField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ObjectField_assign.apply(this, arguments);
};





var ObjectField_ObjectField = function (props) {
    var form = useForm();
    var parent = useField();
    var field = useAttach(form.createObjectField(ObjectField_assign({ basePath: parent === null || parent === void 0 ? void 0 : parent.address }, props)));
    return (external_React_default().createElement(FieldContext.Provider, { value: field },
        external_React_default().createElement(ReactiveField, { field: field }, props.children)));
};
ObjectField_ObjectField.displayName = 'ObjectField';
//# sourceMappingURL=ObjectField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/VoidField.js
var VoidField_assign = (undefined && undefined.__assign) || function () {
    VoidField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return VoidField_assign.apply(this, arguments);
};





var VoidField_VoidField = function (props) {
    var form = useForm();
    var parent = useField();
    var field = useAttach(form.createVoidField(VoidField_assign({ basePath: parent === null || parent === void 0 ? void 0 : parent.address }, props)));
    return (external_React_default().createElement(FieldContext.Provider, { value: field },
        external_React_default().createElement(ReactiveField, { field: field }, props.children)));
};
VoidField_VoidField.displayName = 'VoidField';
//# sourceMappingURL=VoidField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/Field.js
var Field_assign = (undefined && undefined.__assign) || function () {
    Field_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Field_assign.apply(this, arguments);
};




var Field_Field = function (props) {
    var form = useForm();
    var parent = useField();
    var field = form.createField(Field_assign({ basePath: parent === null || parent === void 0 ? void 0 : parent.address }, props));
    (0,external_React_namespaceObject.useEffect)(function () {
        field === null || field === void 0 ? void 0 : field.onMount();
        return function () {
            field === null || field === void 0 ? void 0 : field.onUnmount();
        };
    }, [field]);
    return (external_React_default().createElement(FieldContext.Provider, { value: field },
        external_React_default().createElement(ReactiveField, { field: field }, props.children)));
};
Field_Field.displayName = 'Field';
//# sourceMappingURL=Field.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/RecursionField.js
var RecursionField_assign = (undefined && undefined.__assign) || function () {
    RecursionField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return RecursionField_assign.apply(this, arguments);
};









var useFieldProps = function (schema) {
    var scope = useExpressionScope();
    return schema.toFieldProps({
        scope: scope,
    });
};
var useBasePath = function (props) {
    var parent = useField();
    if (props.onlyRenderProperties) {
        return props.basePath || (parent === null || parent === void 0 ? void 0 : parent.address.concat(props.name));
    }
    return props.basePath || (parent === null || parent === void 0 ? void 0 : parent.address);
};
var RecursionField = function (props) {
    var basePath = useBasePath(props);
    var fieldSchema = (0,external_React_namespaceObject.useMemo)(function () { return new Schema(props.schema); }, [props.schema]);
    var fieldProps = useFieldProps(fieldSchema);
    var renderProperties = function (field) {
        if (props.onlyRenderSelf)
            return;
        var properties = Schema.getOrderProperties(fieldSchema);
        if (!properties.length)
            return;
        return (external_React_default().createElement(external_React_namespaceObject.Fragment, null, properties.map(function (_a, index) {
            var item = _a.schema, name = _a.key;
            var base = (field === null || field === void 0 ? void 0 : field.address) || basePath;
            var schema = item;
            if (checkers_isFn(props.mapProperties)) {
                var mapped = props.mapProperties(item, name);
                if (mapped) {
                    schema = mapped;
                }
            }
            if (checkers_isFn(props.filterProperties)) {
                if (props.filterProperties(schema, name) === false) {
                    return null;
                }
            }
            if (isBool(props.propsRecursion) && props.propsRecursion) {
                return (external_React_default().createElement(RecursionField, { propsRecursion: true, filterProperties: props.filterProperties, mapProperties: props.mapProperties, schema: schema, key: "".concat(index, "-").concat(name), name: name, basePath: base }));
            }
            return (external_React_default().createElement(RecursionField, { schema: schema, key: "".concat(index, "-").concat(name), name: name, basePath: base }));
        })));
    };
    var render = function () {
        if (!isEmpty_isValid(props.name))
            return renderProperties();
        if (fieldSchema.type === 'object') {
            if (props.onlyRenderProperties)
                return renderProperties();
            return (external_React_default().createElement(ObjectField_ObjectField, RecursionField_assign({}, fieldProps, { name: props.name, basePath: basePath }), renderProperties));
        }
        else if (fieldSchema.type === 'array') {
            return (external_React_default().createElement(ArrayField_ArrayField, RecursionField_assign({}, fieldProps, { name: props.name, basePath: basePath })));
        }
        else if (fieldSchema.type === 'void') {
            if (props.onlyRenderProperties)
                return renderProperties();
            return (external_React_default().createElement(VoidField_VoidField, RecursionField_assign({}, fieldProps, { name: props.name, basePath: basePath }), renderProperties));
        }
        return external_React_default().createElement(Field_Field, RecursionField_assign({}, fieldProps, { name: props.name, basePath: basePath }));
    };
    if (!fieldSchema)
        return external_React_default().createElement(external_React_namespaceObject.Fragment, null);
    return (external_React_default().createElement(SchemaContext.Provider, { value: fieldSchema }, render()));
};
//# sourceMappingURL=RecursionField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/ExpressionScope.js



var ExpressionScope = function (props) {
    var scope = (0,external_React_namespaceObject.useContext)(SchemaExpressionScopeContext);
    return (external_React_default().createElement(SchemaExpressionScopeContext.Provider, { value: lazyMerge(scope, props.value) }, props.children));
};
//# sourceMappingURL=ExpressionScope.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/RecordsScope.js


var RecordsScope = function (props) {
    return (external_React_default().createElement(ExpressionScope, { value: {
            get $records() {
                var _a, _b;
                return (_b = (_a = props.getRecords) === null || _a === void 0 ? void 0 : _a.call(props)) !== null && _b !== void 0 ? _b : [];
            },
        } }, props.children));
};
//# sourceMappingURL=RecordsScope.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/RecordScope.js




var RecordScope = function (props) {
    var scope = useExpressionScope();
    return (external_React_default().createElement(ExpressionScope, { value: {
            get $lookup() {
                return scope === null || scope === void 0 ? void 0 : scope.$record;
            },
            get $record() {
                var _a;
                var record = (_a = props.getRecord) === null || _a === void 0 ? void 0 : _a.call(props);
                if (typeof record === 'object') {
                    return lazyMerge(record, {
                        get $lookup() {
                            return scope === null || scope === void 0 ? void 0 : scope.$record;
                        },
                        get $index() {
                            var _a;
                            return (_a = props.getIndex) === null || _a === void 0 ? void 0 : _a.call(props);
                        },
                    });
                }
                return record;
            },
            get $index() {
                var _a;
                return (_a = props.getIndex) === null || _a === void 0 ? void 0 : _a.call(props);
            },
        } }, props.children));
};
//# sourceMappingURL=RecordScope.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/shared/render.js
var render_a, _b, _c;


var env = {
    portalDOM: (_b = (render_a = globalThisPolyfill === null || globalThisPolyfill === void 0 ? void 0 : globalThisPolyfill.document) === null || render_a === void 0 ? void 0 : render_a.createElement) === null || _b === void 0 ? void 0 : _b.call(render_a, 'div'),
    createPortal: (_c = globalThisPolyfill === null || globalThisPolyfill === void 0 ? void 0 : globalThisPolyfill['ReactDOM']) === null || _c === void 0 ? void 0 : _c.createPortal,
};
/* istanbul ignore next */
var loadCreatePortal = function () {
    var _a, _b;
    if (!env.createPortal) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            (_a = env.createPortal) !== null && _a !== void 0 ? _a : (env.createPortal = (_b = __webpack_require__(280)) === null || _b === void 0 ? void 0 : _b.createPortal);
        }
        catch (_c) { }
    }
    if (!env.createPortal) {
        try {
            // @ts-ignore
            Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 280, 23))
                .then(function (module) { var _a; return ((_a = env.createPortal) !== null && _a !== void 0 ? _a : (env.createPortal = module === null || module === void 0 ? void 0 : module.createPortal)); })
                .catch();
        }
        catch (_d) { }
    }
};
var render_render = function (element) {
    var _a;
    if (((_a = globalThisPolyfill.navigator) === null || _a === void 0 ? void 0 : _a.product) === 'ReactNative')
        return null;
    if (env.portalDOM && env.createPortal) {
        return env.createPortal(element, env.portalDOM);
    }
    else {
        return external_React_default().createElement('template', {}, element);
    }
};
loadCreatePortal();
//# sourceMappingURL=render.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/SchemaField.js
var SchemaField_assign = (undefined && undefined.__assign) || function () {
    SchemaField_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return SchemaField_assign.apply(this, arguments);
};







var SchemaField_env = {
    nonameId: 0,
};
var getRandomName = function () {
    return "NO_NAME_FIELD_$".concat(SchemaField_env.nonameId++);
};
function createSchemaField(options) {
    if (options === void 0) { options = {}; }
    function SchemaField(props) {
        var schema = Schema.isSchemaInstance(props.schema)
            ? props.schema
            : new Schema(SchemaField_assign({ type: 'object' }, props.schema));
        var renderMarkup = function () {
            SchemaField_env.nonameId = 0;
            if (props.schema)
                return null;
            return render_render(external_React_default().createElement(SchemaMarkupContext.Provider, { value: schema }, props.children));
        };
        var renderChildren = function () {
            return external_React_default().createElement(RecursionField, SchemaField_assign({}, props, { schema: schema }));
        };
        return (external_React_default().createElement(SchemaOptionsContext.Provider, { value: options },
            external_React_default().createElement(SchemaComponentsContext.Provider, { value: lazyMerge(options.components, props.components) },
                external_React_default().createElement(ExpressionScope, { value: lazyMerge(options.scope, props.scope) },
                    renderMarkup(),
                    renderChildren()))));
    }
    SchemaField.displayName = 'SchemaField';
    function MarkupRender(props) {
        var parent = (0,external_React_namespaceObject.useContext)(SchemaMarkupContext);
        if (!parent)
            return external_React_default().createElement(external_React_namespaceObject.Fragment, null);
        var renderChildren = function () {
            return external_React_default().createElement((external_React_default()).Fragment, null, props.children);
        };
        var appendArraySchema = function (schema) {
            var items = parent.items;
            if (items && items.name !== props.name) {
                return parent.addProperty(props.name, schema);
            }
            else {
                return parent.setItems(schema);
            }
        };
        if (parent.type === 'object' || parent.type === 'void') {
            var schema = parent.addProperty(props.name, props);
            return (external_React_default().createElement(SchemaMarkupContext.Provider, { value: schema }, renderChildren()));
        }
        else if (parent.type === 'array') {
            var schema = appendArraySchema(props);
            return (external_React_default().createElement(SchemaMarkupContext.Provider, { value: Array.isArray(schema) ? schema[0] : schema }, props.children));
        }
        else {
            return renderChildren();
        }
    }
    function MarkupField(props) {
        return external_React_default().createElement(MarkupRender, SchemaField_assign({}, props, { name: props.name || getRandomName() }));
    }
    MarkupField.displayName = 'MarkupField';
    function StringField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "string" }));
    }
    StringField.displayName = 'StringField';
    function ObjectField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "object" }));
    }
    ObjectField.displayName = 'ObjectField';
    function ArrayField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "array" }));
    }
    ArrayField.displayName = 'ArrayField';
    function BooleanField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "boolean" }));
    }
    BooleanField.displayName = 'BooleanField';
    function NumberField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "number" }));
    }
    NumberField.displayName = 'NumberField';
    function DateField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "date" }));
    }
    DateField.displayName = 'DateField';
    function DateTimeField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "datetime" }));
    }
    DateTimeField.displayName = 'DateTimeField';
    function VoidField(props) {
        return external_React_default().createElement(MarkupField, SchemaField_assign({}, props, { type: "void" }));
    }
    VoidField.displayName = 'VoidField';
    SchemaField.Markup = MarkupField;
    SchemaField.String = StringField;
    SchemaField.Object = ObjectField;
    SchemaField.Array = ArrayField;
    SchemaField.Boolean = BooleanField;
    SchemaField.Date = DateField;
    SchemaField.DateTime = DateTimeField;
    SchemaField.Void = VoidField;
    SchemaField.Number = NumberField;
    return SchemaField;
}
//# sourceMappingURL=SchemaField.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/components/index.js











//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+react@2.3.1_@types+react-dom@18.3.0_@types+react@18.3.3_react-dom@18.3.1_react@18.3._kjkfsyrgrkvlqhlobaa2utth6m/node_modules/@formily/react/esm/index.js





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: external "icons"
const external_icons_namespaceObject = globalThis["icons"];
;// CONCATENATED MODULE: external "antd"
const external_antd_namespaceObject = globalThis["antd"];
// EXTERNAL MODULE: ./node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js
var classnames = __webpack_require__(500);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: external "ReactDOM"
var external_ReactDOM_ = __webpack_require__(280);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@dnd-kit+utilities@3.2.1_react@18.3.1/node_modules/@dnd-kit/utilities/dist/utilities.esm.js


function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  return (0,external_React_namespaceObject.useMemo)(() => node => {
    refs.forEach(ref => ref(node));
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  refs);
}

// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js
const canUseDOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';

function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === '[object Window]' || // In Electron context the Window object serializes to [object global]
  elementString === '[object global]';
}

function isNode(node) {
  return 'nodeType' in node;
}

function utilities_esm_getWindow(target) {
  var _target$ownerDocument, _target$ownerDocument2;

  if (!target) {
    return window;
  }

  if (isWindow(target)) {
    return target;
  }

  if (!isNode(target)) {
    return window;
  }

  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}

function isDocument(node) {
  const {
    Document
  } = utilities_esm_getWindow(node);
  return node instanceof Document;
}

function utilities_esm_isHTMLElement(node) {
  if (isWindow(node)) {
    return false;
  }

  return node instanceof utilities_esm_getWindow(node).HTMLElement;
}

function isSVGElement(node) {
  return node instanceof utilities_esm_getWindow(node).SVGElement;
}

function getOwnerDocument(target) {
  if (!target) {
    return document;
  }

  if (isWindow(target)) {
    return target.document;
  }

  if (!isNode(target)) {
    return document;
  }

  if (isDocument(target)) {
    return target;
  }

  if (utilities_esm_isHTMLElement(target)) {
    return target.ownerDocument;
  }

  return document;
}

/**
 * A hook that resolves to useEffect on the server and useLayoutEffect on the client
 * @param callback {function} Callback function that is invoked when the dependencies of the hook change
 */

const utilities_esm_useIsomorphicLayoutEffect = canUseDOM ? external_React_namespaceObject.useLayoutEffect : external_React_namespaceObject.useEffect;

function utilities_esm_useEvent(handler) {
  const handlerRef = (0,external_React_namespaceObject.useRef)(handler);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    handlerRef.current = handler;
  });
  return (0,external_React_namespaceObject.useCallback)(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}

function useInterval() {
  const intervalRef = (0,external_React_namespaceObject.useRef)(null);
  const set = (0,external_React_namespaceObject.useCallback)((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = (0,external_React_namespaceObject.useCallback)(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set, clear];
}

function useLatestValue(value, dependencies) {
  if (dependencies === void 0) {
    dependencies = [value];
  }

  const valueRef = (0,external_React_namespaceObject.useRef)(value);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}

function useLazyMemo(callback, dependencies) {
  const valueRef = (0,external_React_namespaceObject.useRef)();
  return (0,external_React_namespaceObject.useMemo)(() => {
    const newValue = callback(valueRef.current);
    valueRef.current = newValue;
    return newValue;
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [...dependencies]);
}

function useNodeRef(onChange) {
  const onChangeHandler = utilities_esm_useEvent(onChange);
  const node = (0,external_React_namespaceObject.useRef)(null);
  const setNodeRef = (0,external_React_namespaceObject.useCallback)(element => {
    if (element !== node.current) {
      onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
    }

    node.current = element;
  }, //eslint-disable-next-line
  []);
  return [node, setNodeRef];
}

function utilities_esm_usePrevious(value) {
  const ref = (0,external_React_namespaceObject.useRef)();
  (0,external_React_namespaceObject.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}

let ids = {};
function useUniqueId(prefix, value) {
  return (0,external_React_namespaceObject.useMemo)(() => {
    if (value) {
      return value;
    }

    const id = ids[prefix] == null ? 0 : ids[prefix] + 1;
    ids[prefix] = id;
    return prefix + "-" + id;
  }, [prefix, value]);
}

function createAdjustmentFn(modifier) {
  return function (object) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }

    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);

      for (const [key, valueAdjustment] of entries) {
        const value = accumulator[key];

        if (value != null) {
          accumulator[key] = value + modifier * valueAdjustment;
        }
      }

      return accumulator;
    }, { ...object
    });
  };
}

const add = /*#__PURE__*/createAdjustmentFn(1);
const utilities_esm_subtract = /*#__PURE__*/createAdjustmentFn(-1);

function hasViewportRelativeCoordinates(event) {
  return 'clientX' in event && 'clientY' in event;
}

function utilities_esm_isKeyboardEvent(event) {
  if (!event) {
    return false;
  }

  const {
    KeyboardEvent
  } = utilities_esm_getWindow(event.target);
  return KeyboardEvent && event instanceof KeyboardEvent;
}

function isTouchEvent(event) {
  if (!event) {
    return false;
  }

  const {
    TouchEvent
  } = utilities_esm_getWindow(event.target);
  return TouchEvent && event instanceof TouchEvent;
}

/**
 * Returns the normalized x and y coordinates for mouse and touch events.
 */

function utilities_esm_getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x,
        clientY: y
      } = event.touches[0];
      return {
        x,
        y
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x,
        clientY: y
      } = event.changedTouches[0];
      return {
        x,
        y
      };
    }
  }

  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }

  return null;
}

const utilities_esm_CSS = /*#__PURE__*/Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }

      const {
        x,
        y
      } = transform;
      return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
    }

  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }

      const {
        scaleX,
        scaleY
      } = transform;
      return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
    }

  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }

      return [utilities_esm_CSS.Translate.toString(transform), utilities_esm_CSS.Scale.toString(transform)].join(' ');
    }

  },
  Transition: {
    toString(_ref) {
      let {
        property,
        duration,
        easing
      } = _ref;
      return property + " " + duration + "ms " + easing;
    }

  }
});

const SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]';
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }

  return element.querySelector(SELECTOR);
}


//# sourceMappingURL=utilities.esm.js.map

;// CONCATENATED MODULE: ./node_modules/.pnpm/@dnd-kit+accessibility@3.0.1_react@18.3.1/node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js


const hiddenStyles = {
  display: 'none'
};
function HiddenText(_ref) {
  let {
    id,
    value
  } = _ref;
  return external_React_default().createElement("div", {
    id: id,
    style: hiddenStyles
  }, value);
}

const visuallyHidden = {
  position: 'fixed',
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: 'hidden',
  clip: 'rect(0 0 0 0)',
  clipPath: 'inset(100%)',
  whiteSpace: 'nowrap'
};
function LiveRegion(_ref) {
  let {
    id,
    announcement
  } = _ref;
  return external_React_default().createElement("div", {
    id: id,
    style: visuallyHidden,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": true
  }, announcement);
}

function useAnnouncement() {
  const [announcement, setAnnouncement] = (0,external_React_namespaceObject.useState)('');
  const announce = (0,external_React_namespaceObject.useCallback)(value => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}


//# sourceMappingURL=accessibility.esm.js.map

;// CONCATENATED MODULE: ./node_modules/.pnpm/@dnd-kit+core@6.0.8_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@dnd-kit/core/dist/core.esm.js





const DndMonitorContext = /*#__PURE__*/(0,external_React_namespaceObject.createContext)(null);

function useDndMonitor(listener) {
  const registerListener = (0,external_React_namespaceObject.useContext)(DndMonitorContext);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (!registerListener) {
      throw new Error('useDndMonitor must be used within a children of <DndContext>');
    }

    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}

function useDndMonitorProvider() {
  const [listeners] = (0,external_React_namespaceObject.useState)(() => new Set());
  const registerListener = (0,external_React_namespaceObject.useCallback)(listener => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }, [listeners]);
  const dispatch = (0,external_React_namespaceObject.useCallback)(_ref => {
    let {
      type,
      event
    } = _ref;
    listeners.forEach(listener => {
      var _listener$type;

      return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
    });
  }, [listeners]);
  return [dispatch, registerListener];
}

const defaultScreenReaderInstructions = {
  draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
};
const defaultAnnouncements = {
  onDragStart(_ref) {
    let {
      active
    } = _ref;
    return "Picked up draggable item " + active.id + ".";
  },

  onDragOver(_ref2) {
    let {
      active,
      over
    } = _ref2;

    if (over) {
      return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
    }

    return "Draggable item " + active.id + " is no longer over a droppable area.";
  },

  onDragEnd(_ref3) {
    let {
      active,
      over
    } = _ref3;

    if (over) {
      return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
    }

    return "Draggable item " + active.id + " was dropped.";
  },

  onDragCancel(_ref4) {
    let {
      active
    } = _ref4;
    return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
  }

};

function Accessibility(_ref) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId("DndLiveRegion");
  const [mounted, setMounted] = (0,external_React_namespaceObject.useState)(false);
  (0,external_React_namespaceObject.useEffect)(() => {
    setMounted(true);
  }, []);
  useDndMonitor((0,external_React_namespaceObject.useMemo)(() => ({
    onDragStart(_ref2) {
      let {
        active
      } = _ref2;
      announce(announcements.onDragStart({
        active
      }));
    },

    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;

      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },

    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },

    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },

    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }

  }), [announce, announcements]));

  if (!mounted) {
    return null;
  }

  const markup = external_React_default().createElement((external_React_default()).Fragment, null, external_React_default().createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), external_React_default().createElement(LiveRegion, {
    id: liveRegionId,
    announcement: announcement
  }));
  return container ? (0,external_ReactDOM_.createPortal)(markup, container) : markup;
}

var Action;

(function (Action) {
  Action["DragStart"] = "dragStart";
  Action["DragMove"] = "dragMove";
  Action["DragEnd"] = "dragEnd";
  Action["DragCancel"] = "dragCancel";
  Action["DragOver"] = "dragOver";
  Action["RegisterDroppable"] = "registerDroppable";
  Action["SetDroppableDisabled"] = "setDroppableDisabled";
  Action["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));

function noop() {}

function useSensor(sensor, options) {
  return useMemo(() => ({
    sensor,
    options: options != null ? options : {}
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [sensor, options]);
}

function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }

  return useMemo(() => [...sensors].filter(sensor => sensor != null), // eslint-disable-next-line react-hooks/exhaustive-deps
  [...sensors]);
}

const defaultCoordinates = /*#__PURE__*/Object.freeze({
  x: 0,
  y: 0
});

/**
 * Returns the distance between two points
 */
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}

function getRelativeTransformOrigin(event, rect) {
  const eventCoordinates = getEventCoordinates(event);

  if (!eventCoordinates) {
    return '0 0';
  }

  const transformOrigin = {
    x: (eventCoordinates.x - rect.left) / rect.width * 100,
    y: (eventCoordinates.y - rect.top) / rect.height * 100
  };
  return transformOrigin.x + "% " + transformOrigin.y + "%";
}

/**
 * Sort collisions from smallest to greatest value
 */
function sortCollisionsAsc(_ref, _ref2) {
  let {
    data: {
      value: a
    }
  } = _ref;
  let {
    data: {
      value: b
    }
  } = _ref2;
  return a - b;
}
/**
 * Sort collisions from greatest to smallest value
 */

function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a
    }
  } = _ref3;
  let {
    data: {
      value: b
    }
  } = _ref4;
  return b - a;
}
/**
 * Returns the coordinates of the corners of a given rectangle:
 * [TopLeft {x, y}, TopRight {x, y}, BottomLeft {x, y}, BottomRight {x, y}]
 */

function cornersOfRectangle(_ref5) {
  let {
    left,
    top,
    height,
    width
  } = _ref5;
  return [{
    x: left,
    y: top
  }, {
    x: left + width,
    y: top
  }, {
    x: left,
    y: top + height
  }, {
    x: left + width,
    y: top + height
  }];
}
function core_esm_getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }

  const [firstCollision] = collisions;
  return property ? firstCollision[property] : firstCollision;
}

/**
 * Returns the coordinates of the center of a given ClientRect
 */

function centerOfRectangle(rect, left, top) {
  if (left === void 0) {
    left = rect.left;
  }

  if (top === void 0) {
    top = rect.top;
  }

  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
/**
 * Returns the closest rectangles from an array of rectangles to the center of a given
 * rectangle.
 */


const closestCenter = _ref => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  const collisions = [];

  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);

    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: distBetween
        }
      });
    }
  }

  return collisions.sort(sortCollisionsAsc);
};

/**
 * Returns the closest rectangles from an array of rectangles to the corners of
 * another rectangle.
 */

const core_esm_closestCorners = _ref => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const corners = cornersOfRectangle(collisionRect);
  const collisions = [];

  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);

    if (rect) {
      const rectCorners = cornersOfRectangle(rect);
      const distances = corners.reduce((accumulator, corner, index) => {
        return accumulator + distanceBetween(rectCorners[index], corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: effectiveDistance
        }
      });
    }
  }

  return collisions.sort(sortCollisionsAsc);
};

/**
 * Returns the intersecting rectangle area between two rectangles
 */

function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.top);
  const left = Math.max(target.left, entry.left);
  const right = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right - left;
  const height = bottom - top;

  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)


  return 0;
}
/**
 * Returns the rectangles that has the greatest intersection area with a given
 * rectangle in an array of rectangles.
 */

const rectIntersection = _ref => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const collisions = [];

  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);

    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);

      if (intersectionRatio > 0) {
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: intersectionRatio
          }
        });
      }
    }
  }

  return collisions.sort(sortCollisionsDesc);
};

/**
 * Check if a given point is contained within a bounding rectangle
 */

function isPointWithinRect(point, rect) {
  const {
    top,
    left,
    bottom,
    right
  } = rect;
  return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;
}
/**
 * Returns the rectangles that the pointer is hovering over
 */


const pointerWithin = _ref => {
  let {
    droppableContainers,
    droppableRects,
    pointerCoordinates
  } = _ref;

  if (!pointerCoordinates) {
    return [];
  }

  const collisions = [];

  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);

    if (rect && isPointWithinRect(pointerCoordinates, rect)) {
      /* There may be more than a single rectangle intersecting
       * with the pointer coordinates. In order to sort the
       * colliding rectangles, we measure the distance between
       * the pointer and the corners of the intersecting rectangle
       */
      const corners = cornersOfRectangle(rect);
      const distances = corners.reduce((accumulator, corner) => {
        return accumulator + distanceBetween(pointerCoordinates, corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: effectiveDistance
        }
      });
    }
  }

  return collisions.sort(sortCollisionsAsc);
};

function adjustScale(transform, rect1, rect2) {
  return { ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}

function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}

function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }

    return adjustments.reduce((acc, adjustment) => ({ ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), { ...rect
    });
  };
}
const getAdjustedRect = /*#__PURE__*/createRectAdjustmentFn(1);

function parseTransform(transform) {
  if (transform.startsWith('matrix3d(')) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith('matrix(')) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }

  return null;
}

function inverseTransform(rect, transform, transformOrigin) {
  const parsedTransform = parseTransform(transform);

  if (!parsedTransform) {
    return rect;
  }

  const {
    scaleX,
    scaleY,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(' ') + 1));
  const w = scaleX ? rect.width / scaleX : rect.width;
  const h = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w,
    height: h,
    top: y,
    right: x + w,
    bottom: y + h,
    left: x
  };
}

const defaultOptions = {
  ignoreTransform: false
};
/**
 * Returns the bounding client rect of an element relative to the viewport.
 */

function getClientRect(element, options) {
  if (options === void 0) {
    options = defaultOptions;
  }

  let rect = element.getBoundingClientRect();

  if (options.ignoreTransform) {
    const {
      transform,
      transformOrigin
    } = utilities_esm_getWindow(element).getComputedStyle(element);

    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin);
    }
  }

  const {
    top,
    left,
    width,
    height,
    bottom,
    right
  } = rect;
  return {
    top,
    left,
    width,
    height,
    bottom,
    right
  };
}
/**
 * Returns the bounding client rect of an element relative to the viewport.
 *
 * @remarks
 * The ClientRect returned by this method does not take into account transforms
 * applied to the element it measures.
 *
 */

function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}

function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}

function isFixed(node, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = utilities_esm_getWindow(node).getComputedStyle(node);
  }

  return computedStyle.position === 'fixed';
}

function isScrollable(element, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = utilities_esm_getWindow(element).getComputedStyle(element);
  }

  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ['overflow', 'overflowX', 'overflowY'];
  return properties.some(property => {
    const value = computedStyle[property];
    return typeof value === 'string' ? overflowRegex.test(value) : false;
  });
}

function core_esm_getScrollableAncestors(element, limit) {
  const scrollParents = [];

  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }

    if (!node) {
      return scrollParents;
    }

    if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
      scrollParents.push(node.scrollingElement);
      return scrollParents;
    }

    if (!utilities_esm_isHTMLElement(node) || isSVGElement(node)) {
      return scrollParents;
    }

    if (scrollParents.includes(node)) {
      return scrollParents;
    }

    const computedStyle = utilities_esm_getWindow(element).getComputedStyle(node);

    if (node !== element) {
      if (isScrollable(node, computedStyle)) {
        scrollParents.push(node);
      }
    }

    if (isFixed(node, computedStyle)) {
      return scrollParents;
    }

    return findScrollableAncestors(node.parentNode);
  }

  if (!element) {
    return scrollParents;
  }

  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = core_esm_getScrollableAncestors(node, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}

function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }

  if (isWindow(element)) {
    return element;
  }

  if (!isNode(element)) {
    return null;
  }

  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }

  if (utilities_esm_isHTMLElement(element)) {
    return element;
  }

  return null;
}

function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }

  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }

  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}

var Direction;

(function (Direction) {
  Direction[Direction["Forward"] = 1] = "Forward";
  Direction[Direction["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));

function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }

  return element === document.scrollingElement;
}

function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}

const defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
  let {
    top,
    left,
    right,
    bottom
  } = _ref;

  if (acceleration === void 0) {
    acceleration = 10;
  }

  if (thresholdPercentage === void 0) {
    thresholdPercentage = defaultThreshold;
  }

  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };

  if (!isTop && top <= scrollContainerRect.top + threshold.height) {
    // Scroll Up
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
    // Scroll Down
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }

  if (!isRight && right >= scrollContainerRect.right - threshold.width) {
    // Scroll Right
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
    // Scroll Left
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
  }

  return {
    direction,
    speed
  };
}

function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }

  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}

function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return add(acc, getScrollCoordinates(node));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollXCoordinate(node);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollYCoordinate(node);
  }, 0);
}

function scrollIntoViewIfNeeded(element, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }

  if (!element) {
    return;
  }

  const {
    top,
    left,
    bottom,
    right
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);

  if (!firstScrollableAncestor) {
    return;
  }

  if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
    element.scrollIntoView({
      block: 'center',
      inline: 'center'
    });
  }
}

const properties = [['x', ['left', 'right'], getScrollXOffset], ['y', ['top', 'bottom'], getScrollYOffset]];
class Rect {
  constructor(rect, element) {
    this.rect = void 0;
    this.width = void 0;
    this.height = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.right = void 0;
    this.left = void 0;
    const scrollableAncestors = core_esm_getScrollableAncestors(element);
    const scrollOffsets = getScrollOffsets(scrollableAncestors);
    this.rect = { ...rect
    };
    this.width = rect.width;
    this.height = rect.height;

    for (const [axis, keys, getScrollOffset] of properties) {
      for (const key of keys) {
        Object.defineProperty(this, key, {
          get: () => {
            const currentOffsets = getScrollOffset(scrollableAncestors);
            const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
            return this.rect[key] + scrollOffsetsDeltla;
          },
          enumerable: true
        });
      }
    }

    Object.defineProperty(this, 'rect', {
      enumerable: false
    });
  }

}

class Listeners {
  constructor(target) {
    this.target = void 0;
    this.listeners = [];

    this.removeAll = () => {
      this.listeners.forEach(listener => {
        var _this$target;

        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };

    this.target = target;
  }

  add(eventName, handler, options) {
    var _this$target2;

    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }

}

function getEventListenerTarget(target) {
  // If the `event.target` element is removed from the document events will still be targeted
  // at it, and hence won't always bubble up to the window or document anymore.
  // If there is any risk of an element being removed while it is being dragged,
  // the best practice is to attach the event listeners directly to the target.
  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
  const {
    EventTarget
  } = utilities_esm_getWindow(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}

function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);

  if (typeof measurement === 'number') {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }

  if ('x' in measurement && 'y' in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }

  if ('x' in measurement) {
    return dx > measurement.x;
  }

  if ('y' in measurement) {
    return dy > measurement.y;
  }

  return false;
}

var EventName;

(function (EventName) {
  EventName["Click"] = "click";
  EventName["DragStart"] = "dragstart";
  EventName["Keydown"] = "keydown";
  EventName["ContextMenu"] = "contextmenu";
  EventName["Resize"] = "resize";
  EventName["SelectionChange"] = "selectionchange";
  EventName["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));

function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation(event) {
  event.stopPropagation();
}

var core_esm_KeyboardCode;

(function (KeyboardCode) {
  KeyboardCode["Space"] = "Space";
  KeyboardCode["Down"] = "ArrowDown";
  KeyboardCode["Right"] = "ArrowRight";
  KeyboardCode["Left"] = "ArrowLeft";
  KeyboardCode["Up"] = "ArrowUp";
  KeyboardCode["Esc"] = "Escape";
  KeyboardCode["Enter"] = "Enter";
})(core_esm_KeyboardCode || (core_esm_KeyboardCode = {}));

const defaultKeyboardCodes = {
  start: [core_esm_KeyboardCode.Space, core_esm_KeyboardCode.Enter],
  cancel: [core_esm_KeyboardCode.Esc],
  end: [core_esm_KeyboardCode.Space, core_esm_KeyboardCode.Enter]
};
const defaultKeyboardCoordinateGetter = (event, _ref) => {
  let {
    currentCoordinates
  } = _ref;

  switch (event.code) {
    case core_esm_KeyboardCode.Right:
      return { ...currentCoordinates,
        x: currentCoordinates.x + 25
      };

    case core_esm_KeyboardCode.Left:
      return { ...currentCoordinates,
        x: currentCoordinates.x - 25
      };

    case core_esm_KeyboardCode.Down:
      return { ...currentCoordinates,
        y: currentCoordinates.y + 25
      };

    case core_esm_KeyboardCode.Up:
      return { ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }

  return undefined;
};

class KeyboardSensor {
  constructor(props) {
    this.props = void 0;
    this.autoScrollEnabled = false;
    this.referenceCoordinates = void 0;
    this.listeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(utilities_esm_getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }

  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }

  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    const node = activeNode.node.current;

    if (node) {
      scrollIntoViewIfNeeded(node);
    }

    onStart(defaultCoordinates);
  }

  handleKeyDown(event) {
    if (utilities_esm_isKeyboardEvent(event)) {
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = 'smooth'
      } = options;
      const {
        code
      } = event;

      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }

      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }

      const {
        collisionRect
      } = context.current;
      const currentCoordinates = collisionRect ? {
        x: collisionRect.left,
        y: collisionRect.top
      } : defaultCoordinates;

      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }

      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates
      });

      if (newCoordinates) {
        const coordinatesDelta = utilities_esm_subtract(newCoordinates, currentCoordinates);
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;

        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === core_esm_KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === core_esm_KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === core_esm_KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === core_esm_KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === core_esm_KeyboardCode.Right && !isRight || direction === core_esm_KeyboardCode.Left && !isLeft;
          const canScrollY = direction === core_esm_KeyboardCode.Down && !isBottom || direction === core_esm_KeyboardCode.Up && !isTop;

          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
            const canScrollToNewCoordinates = direction === core_esm_KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === core_esm_KeyboardCode.Left && newScrollCoordinates >= minScroll.x;

            if (canScrollToNewCoordinates && !coordinatesDelta.y) {
              // We don't need to update coordinates, the scroll adjustment alone will trigger
              // logic to auto-detect the new container we are over
              scrollContainer.scrollTo({
                left: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }

            if (canScrollToNewCoordinates) {
              scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
            } else {
              scrollDelta.x = direction === core_esm_KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            }

            if (scrollDelta.x) {
              scrollContainer.scrollBy({
                left: -scrollDelta.x,
                behavior: scrollBehavior
              });
            }

            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
            const canScrollToNewCoordinates = direction === core_esm_KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === core_esm_KeyboardCode.Up && newScrollCoordinates >= minScroll.y;

            if (canScrollToNewCoordinates && !coordinatesDelta.x) {
              // We don't need to update coordinates, the scroll adjustment alone will trigger
              // logic to auto-detect the new container we are over
              scrollContainer.scrollTo({
                top: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }

            if (canScrollToNewCoordinates) {
              scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
            } else {
              scrollDelta.y = direction === core_esm_KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            }

            if (scrollDelta.y) {
              scrollContainer.scrollBy({
                top: -scrollDelta.y,
                behavior: scrollBehavior
              });
            }

            break;
          }
        }

        this.handleMove(event, add(utilities_esm_subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
      }
    }
  }

  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
  }

  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }

  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }

  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }

}
KeyboardSensor.activators = [{
  eventName: 'onKeyDown',
  handler: (event, _ref, _ref2) => {
    let {
      keyboardCodes = defaultKeyboardCodes,
      onActivation
    } = _ref;
    let {
      active
    } = _ref2;
    const {
      code
    } = event.nativeEvent;

    if (keyboardCodes.start.includes(code)) {
      const activator = active.activatorNode.current;

      if (activator && event.target !== activator) {
        return false;
      }

      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }

    return false;
  }
}];

function isDistanceConstraint(constraint) {
  return Boolean(constraint && 'distance' in constraint);
}

function isDelayConstraint(constraint) {
  return Boolean(constraint && 'delay' in constraint);
}

class AbstractPointerSensor {
  constructor(props, events, listenerTarget) {
    var _getEventCoordinates;

    if (listenerTarget === void 0) {
      listenerTarget = getEventListenerTarget(props.event.target);
    }

    this.props = void 0;
    this.events = void 0;
    this.autoScrollEnabled = true;
    this.document = void 0;
    this.activated = false;
    this.initialCoordinates = void 0;
    this.timeoutId = null;
    this.listeners = void 0;
    this.documentListeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    this.events = events;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events;
    this.document = getOwnerDocument(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(utilities_esm_getWindow(target));
    this.initialCoordinates = (_getEventCoordinates = utilities_esm_getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }

  attach() {
    const {
      events,
      props: {
        options: {
          activationConstraint
        }
      }
    } = this;
    this.listeners.add(events.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events.end.name, this.handleEnd);
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);

    if (activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        return;
      }

      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        return;
      }
    }

    this.handleStart();
  }

  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners
    // This is necessary because we listen for `click` and `selection` events on the document

    setTimeout(this.documentListeners.removeAll, 50);

    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }

  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;

    if (initialCoordinates) {
      this.activated = true; // Stop propagation of click events once activation constraints are met

      this.documentListeners.add(EventName.Click, stopPropagation, {
        capture: true
      }); // Remove any text selection from the document

      this.removeTextSelection(); // Prevent further text selection while dragging

      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }

  handleMove(event) {
    var _getEventCoordinates2;

    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;

    if (!initialCoordinates) {
      return;
    }

    const coordinates = (_getEventCoordinates2 = utilities_esm_getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
    const delta = utilities_esm_subtract(initialCoordinates, coordinates);

    if (!activated && activationConstraint) {
      // Constraint validation
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }

        return;
      }

      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }

        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }

        return;
      }
    }

    if (event.cancelable) {
      event.preventDefault();
    }

    onMove(coordinates);
  }

  handleEnd() {
    const {
      onEnd
    } = this.props;
    this.detach();
    onEnd();
  }

  handleCancel() {
    const {
      onCancel
    } = this.props;
    this.detach();
    onCancel();
  }

  handleKeydown(event) {
    if (event.code === core_esm_KeyboardCode.Esc) {
      this.handleCancel();
    }
  }

  removeTextSelection() {
    var _this$document$getSel;

    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }

}

const events = {
  move: {
    name: 'pointermove'
  },
  end: {
    name: 'pointerup'
  }
};
class PointerSensor extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props; // Pointer events stop firing if the target is unmounted while dragging
    // Therefore we attach listeners to the owner document instead

    const listenerTarget = getOwnerDocument(event.target);
    super(props, events, listenerTarget);
  }

}
PointerSensor.activators = [{
  eventName: 'onPointerDown',
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;

    if (!event.isPrimary || event.button !== 0) {
      return false;
    }

    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];

const events$1 = {
  move: {
    name: 'mousemove'
  },
  end: {
    name: 'mouseup'
  }
};
var MouseButton;

(function (MouseButton) {
  MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));

class MouseSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }

}
MouseSensor.activators = [{
  eventName: 'onMouseDown',
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;

    if (event.button === MouseButton.RightClick) {
      return false;
    }

    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];

const events$2 = {
  move: {
    name: 'touchmove'
  },
  end: {
    name: 'touchend'
  }
};
class TouchSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }

  static setup() {
    // Adding a non-capture and non-passive `touchmove` listener in order
    // to force `event.preventDefault()` calls to work in dynamically added
    // touchmove event handlers. This is required for iOS Safari.
    window.addEventListener(events$2.move.name, noop, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop);
    }; // We create a new handler because the teardown function of another sensor
    // could remove our event listener if we use a referentially equal listener.

    function noop() {}
  }

}
TouchSensor.activators = [{
  eventName: 'onTouchStart',
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    const {
      touches
    } = event;

    if (touches.length > 1) {
      return false;
    }

    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];

var AutoScrollActivator;

(function (AutoScrollActivator) {
  AutoScrollActivator[AutoScrollActivator["Pointer"] = 0] = "Pointer";
  AutoScrollActivator[AutoScrollActivator["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));

var TraversalOrder;

(function (TraversalOrder) {
  TraversalOrder[TraversalOrder["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder[TraversalOrder["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));

function useAutoScroller(_ref) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval = 5,
    order = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = (0,external_React_namespaceObject.useRef)({
    x: 0,
    y: 0
  });
  const scrollDirection = (0,external_React_namespaceObject.useRef)({
    x: 0,
    y: 0
  });
  const rect = (0,external_React_namespaceObject.useMemo)(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;

      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = (0,external_React_namespaceObject.useRef)(null);
  const autoScroll = (0,external_React_namespaceObject.useCallback)(() => {
    const scrollContainer = scrollContainerRef.current;

    if (!scrollContainer) {
      return;
    }

    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = (0,external_React_namespaceObject.useMemo)(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (!enabled || !scrollableAncestors.length || !rect) {
      clearAutoScrollInterval();
      return;
    }

    for (const scrollContainer of sortedScrollableAncestors) {
      if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
        continue;
      }

      const index = scrollableAncestors.indexOf(scrollContainer);
      const scrollContainerRect = scrollableAncestorRects[index];

      if (!scrollContainerRect) {
        continue;
      }

      const {
        direction,
        speed
      } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);

      for (const axis of ['x', 'y']) {
        if (!scrollIntent[axis][direction[axis]]) {
          speed[axis] = 0;
          direction[axis] = 0;
        }
      }

      if (speed.x > 0 || speed.y > 0) {
        clearAutoScrollInterval();
        scrollContainerRef.current = scrollContainer;
        setAutoScrollInterval(autoScroll, interval);
        scrollSpeed.current = speed;
        scrollDirection.current = direction;
        return;
      }
    }

    scrollSpeed.current = {
      x: 0,
      y: 0
    };
    scrollDirection.current = {
      x: 0,
      y: 0
    };
    clearAutoScrollInterval();
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [acceleration, autoScroll, canScroll, clearAutoScrollInterval, enabled, interval, // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(rect), // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(scrollIntent), setAutoScrollInterval, scrollableAncestors, sortedScrollableAncestors, scrollableAncestorRects, // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(threshold)]);
}
const defaultScrollIntent = {
  x: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  },
  y: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  }
};

function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = utilities_esm_usePrevious(delta);
  return useLazyMemo(previousIntent => {
    if (disabled || !previousDelta || !previousIntent) {
      // Reset scroll intent tracking when auto-scrolling is disabled
      return defaultScrollIntent;
    }

    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    }; // Keep track of the user intent to scroll in each direction for both axis

    return {
      x: {
        [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
        [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
      },
      y: {
        [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
        [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}

function useCachedNode(draggableNodes, id) {
  const draggableNode = id !== null ? draggableNodes.get(id) : undefined;
  const node = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo(cachedNode => {
    var _ref;

    if (id === null) {
      return null;
    } // In some cases, the draggable node can unmount while dragging
    // This is the case for virtualized lists. In those situations,
    // we fall back to the last known value for that node.


    return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
  }, [node, id]);
}

function useCombineActivators(sensors, getSyntheticHandler) {
  return (0,external_React_namespaceObject.useMemo)(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map(activator => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}

var MeasuringStrategy;

(function (MeasuringStrategy) {
  MeasuringStrategy[MeasuringStrategy["Always"] = 0] = "Always";
  MeasuringStrategy[MeasuringStrategy["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy[MeasuringStrategy["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));

var MeasuringFrequency;

(function (MeasuringFrequency) {
  MeasuringFrequency["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));

const defaultValue = /*#__PURE__*/new Map();
function useDroppableMeasuring(containers, _ref) {
  let {
    dragging,
    dependencies,
    config
  } = _ref;
  const [queue, setQueue] = (0,external_React_namespaceObject.useState)(null);
  const {
    frequency,
    measure,
    strategy
  } = config;
  const containersRef = (0,external_React_namespaceObject.useRef)(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = (0,external_React_namespaceObject.useCallback)(function (ids) {
    if (ids === void 0) {
      ids = [];
    }

    if (disabledRef.current) {
      return;
    }

    setQueue(value => {
      if (value === null) {
        return ids;
      }

      return value.concat(ids.filter(id => !value.includes(id)));
    });
  }, [disabledRef]);
  const timeoutId = (0,external_React_namespaceObject.useRef)(null);
  const droppableRects = useLazyMemo(previousValue => {
    if (disabled && !dragging) {
      return defaultValue;
    }

    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
      const map = new Map();

      for (let container of containers) {
        if (!container) {
          continue;
        }

        if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
          // This container does not need to be re-measured
          map.set(container.id, container.rect.current);
          continue;
        }

        const node = container.node.current;
        const rect = node ? new Rect(measure(node), node) : null;
        container.rect.current = rect;

        if (rect) {
          map.set(container.id, rect);
        }
      }

      return map;
    }

    return previousValue;
  }, [containers, queue, dragging, disabled, measure]);
  (0,external_React_namespaceObject.useEffect)(() => {
    containersRef.current = containers;
  }, [containers]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (disabled) {
      return;
    }

    measureDroppableContainers();
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [dragging, disabled]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (queue && queue.length > 0) {
      setQueue(null);
    }
  }, //eslint-disable-next-line react-hooks/exhaustive-deps
  [JSON.stringify(queue)]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (disabled || typeof frequency !== 'number' || timeoutId.current !== null) {
      return;
    }

    timeoutId.current = setTimeout(() => {
      measureDroppableContainers();
      timeoutId.current = null;
    }, frequency);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [frequency, disabled, measureDroppableContainers, ...dependencies]);
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled: queue != null
  };

  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;

      case MeasuringStrategy.BeforeDragging:
        return dragging;

      default:
        return !dragging;
    }
  }
}

function useInitialValue(value, computeFn) {
  return useLazyMemo(previousValue => {
    if (!value) {
      return null;
    }

    if (previousValue) {
      return previousValue;
    }

    return typeof computeFn === 'function' ? computeFn(value) : value;
  }, [computeFn, value]);
}

function useInitialRect(node, measure) {
  return useInitialValue(node, measure);
}

/**
 * Returns a new MutationObserver instance.
 * If `MutationObserver` is undefined in the execution environment, returns `undefined`.
 */

function useMutationObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleMutations = utilities_esm_useEvent(callback);
  const mutationObserver = (0,external_React_namespaceObject.useMemo)(() => {
    if (disabled || typeof window === 'undefined' || typeof window.MutationObserver === 'undefined') {
      return undefined;
    }

    const {
      MutationObserver
    } = window;
    return new MutationObserver(handleMutations);
  }, [handleMutations, disabled]);
  (0,external_React_namespaceObject.useEffect)(() => {
    return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}

/**
 * Returns a new ResizeObserver instance bound to the `onResize` callback.
 * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.
 */

function useResizeObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleResize = utilities_esm_useEvent(callback);
  const resizeObserver = (0,external_React_namespaceObject.useMemo)(() => {
    if (disabled || typeof window === 'undefined' || typeof window.ResizeObserver === 'undefined') {
      return undefined;
    }

    const {
      ResizeObserver
    } = window;
    return new ResizeObserver(handleResize);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [disabled]);
  (0,external_React_namespaceObject.useEffect)(() => {
    return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}

function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}

function useRect(element, measure, fallbackRect) {
  if (measure === void 0) {
    measure = defaultMeasure;
  }

  const [rect, measureRect] = (0,external_React_namespaceObject.useReducer)(reducer, null);
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }

      for (const record of records) {
        const {
          type,
          target
        } = record;

        if (type === 'childList' && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }

  });
  const resizeObserver = useResizeObserver({
    callback: measureRect
  });
  utilities_esm_useIsomorphicLayoutEffect(() => {
    measureRect();

    if (element) {
      resizeObserver == null ? void 0 : resizeObserver.observe(element);
      mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }
  }, [element]);
  return rect;

  function reducer(currentRect) {
    if (!element) {
      return null;
    }

    if (element.isConnected === false) {
      var _ref;

      // Fall back to last rect we measured if the element is
      // no longer connected to the DOM.
      return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
    }

    const newRect = measure(element);

    if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
      return currentRect;
    }

    return newRect;
  }
}

function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}

const defaultValue$1 = [];
function useScrollableAncestors(node) {
  const previousNode = (0,external_React_namespaceObject.useRef)(node);
  const ancestors = useLazyMemo(previousValue => {
    if (!node) {
      return defaultValue$1;
    }

    if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }

    return core_esm_getScrollableAncestors(node);
  }, [node]);
  (0,external_React_namespaceObject.useEffect)(() => {
    previousNode.current = node;
  }, [node]);
  return ancestors;
}

function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = (0,external_React_namespaceObject.useState)(null);
  const prevElements = (0,external_React_namespaceObject.useRef)(elements); // To-do: Throttle the handleScroll callback

  const handleScroll = (0,external_React_namespaceObject.useCallback)(event => {
    const scrollingElement = getScrollableElement(event.target);

    if (!scrollingElement) {
      return;
    }

    setScrollCoordinates(scrollCoordinates => {
      if (!scrollCoordinates) {
        return null;
      }

      scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates);
    });
  }, []);
  (0,external_React_namespaceObject.useEffect)(() => {
    const previousElements = prevElements.current;

    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map(element => {
        const scrollableElement = getScrollableElement(element);

        if (scrollableElement) {
          scrollableElement.addEventListener('scroll', handleScroll, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }

        return null;
      }).filter(entry => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }

    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };

    function cleanup(elements) {
      elements.forEach(element => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener('scroll', handleScroll);
      });
    }
  }, [handleScroll, elements]);
  return (0,external_React_namespaceObject.useMemo)(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }

    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}

function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }

  const initialScrollOffsets = (0,external_React_namespaceObject.useRef)(null);
  (0,external_React_namespaceObject.useEffect)(() => {
    initialScrollOffsets.current = null;
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  dependencies);
  (0,external_React_namespaceObject.useEffect)(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;

    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }

    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? utilities_esm_subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}

function useSensorSetup(sensors) {
  (0,external_React_namespaceObject.useEffect)(() => {
    if (!canUseDOM) {
      return;
    }

    const teardownFns = sensors.map(_ref => {
      let {
        sensor
      } = _ref;
      return sensor.setup == null ? void 0 : sensor.setup();
    });
    return () => {
      for (const teardown of teardownFns) {
        teardown == null ? void 0 : teardown();
      }
    };
  }, // TO-DO: Sensors length could theoretically change which would not be a valid dependency
  // eslint-disable-next-line react-hooks/exhaustive-deps
  sensors.map(_ref2 => {
    let {
      sensor
    } = _ref2;
    return sensor;
  }));
}

function useSyntheticListeners(listeners, id) {
  return (0,external_React_namespaceObject.useMemo)(() => {
    return listeners.reduce((acc, _ref) => {
      let {
        eventName,
        handler
      } = _ref;

      acc[eventName] = event => {
        handler(event, id);
      };

      return acc;
    }, {});
  }, [listeners, id]);
}

function useWindowRect(element) {
  return (0,external_React_namespaceObject.useMemo)(() => element ? getWindowClientRect(element) : null, [element]);
}

const defaultValue$2 = [];
function useRects(elements, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }

  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? utilities_esm_getWindow(firstElement) : null);
  const [rects, measureRects] = (0,external_React_namespaceObject.useReducer)(reducer, defaultValue$2);
  const resizeObserver = useResizeObserver({
    callback: measureRects
  });

  if (elements.length > 0 && rects === defaultValue$2) {
    measureRects();
  }

  utilities_esm_useIsomorphicLayoutEffect(() => {
    if (elements.length) {
      elements.forEach(element => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
    }
  }, [elements]);
  return rects;

  function reducer() {
    if (!elements.length) {
      return defaultValue$2;
    }

    return elements.map(element => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
  }
}

function getMeasurableNode(node) {
  if (!node) {
    return null;
  }

  if (node.children.length > 1) {
    return node;
  }

  const firstChild = node.children[0];
  return utilities_esm_isHTMLElement(firstChild) ? firstChild : node;
}

function useDragOverlayMeasuring(_ref) {
  let {
    measure
  } = _ref;
  const [rect, setRect] = (0,external_React_namespaceObject.useState)(null);
  const handleResize = (0,external_React_namespaceObject.useCallback)(entries => {
    for (const {
      target
    } of entries) {
      if (utilities_esm_isHTMLElement(target)) {
        setRect(rect => {
          const newRect = measure(target);
          return rect ? { ...rect,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver({
    callback: handleResize
  });
  const handleNodeChange = (0,external_React_namespaceObject.useCallback)(element => {
    const node = getMeasurableNode(element);
    resizeObserver == null ? void 0 : resizeObserver.disconnect();

    if (node) {
      resizeObserver == null ? void 0 : resizeObserver.observe(node);
    }

    setRect(node ? measure(node) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef] = useNodeRef(handleNodeChange);
  return (0,external_React_namespaceObject.useMemo)(() => ({
    nodeRef,
    rect,
    setRef
  }), [rect, nodeRef, setRef]);
}

const defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
const defaultData = {
  current: {}
};
const defaultMeasuringConfiguration = {
  draggable: {
    measure: getTransformAgnosticClientRect
  },
  droppable: {
    measure: getTransformAgnosticClientRect,
    strategy: MeasuringStrategy.WhileDragging,
    frequency: MeasuringFrequency.Optimized
  },
  dragOverlay: {
    measure: getClientRect
  }
};

class DroppableContainersMap extends Map {
  get(id) {
    var _super$get;

    return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;
  }

  toArray() {
    return Array.from(this.values());
  }

  getEnabled() {
    return this.toArray().filter(_ref => {
      let {
        disabled
      } = _ref;
      return !disabled;
    });
  }

  getNodeFor(id) {
    var _this$get$node$curren, _this$get;

    return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;
  }

}

const defaultPublicContext = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /*#__PURE__*/new Map(),
  droppableRects: /*#__PURE__*/new Map(),
  droppableContainers: /*#__PURE__*/new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: defaultMeasuringConfiguration,
  measureDroppableContainers: noop,
  windowRect: null,
  measuringScheduled: false
};
const defaultInternalContext = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ''
  },
  dispatch: noop,
  draggableNodes: /*#__PURE__*/new Map(),
  over: null,
  measureDroppableContainers: noop
};
const InternalContext = /*#__PURE__*/(0,external_React_namespaceObject.createContext)(defaultInternalContext);
const PublicContext = /*#__PURE__*/(0,external_React_namespaceObject.createContext)(defaultPublicContext);

function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return { ...state,
        draggable: { ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };

    case Action.DragMove:
      if (!state.draggable.active) {
        return state;
      }

      return { ...state,
        draggable: { ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };

    case Action.DragEnd:
    case Action.DragCancel:
      return { ...state,
        draggable: { ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };

    case Action.RegisterDroppable:
      {
        const {
          element
        } = action;
        const {
          id
        } = element;
        const containers = new DroppableContainersMap(state.droppable.containers);
        containers.set(id, element);
        return { ...state,
          droppable: { ...state.droppable,
            containers
          }
        };
      }

    case Action.SetDroppableDisabled:
      {
        const {
          id,
          key,
          disabled
        } = action;
        const element = state.droppable.containers.get(id);

        if (!element || key !== element.key) {
          return state;
        }

        const containers = new DroppableContainersMap(state.droppable.containers);
        containers.set(id, { ...element,
          disabled
        });
        return { ...state,
          droppable: { ...state.droppable,
            containers
          }
        };
      }

    case Action.UnregisterDroppable:
      {
        const {
          id,
          key
        } = action;
        const element = state.droppable.containers.get(id);

        if (!element || key !== element.key) {
          return state;
        }

        const containers = new DroppableContainersMap(state.droppable.containers);
        containers.delete(id);
        return { ...state,
          droppable: { ...state.droppable,
            containers
          }
        };
      }

    default:
      {
        return state;
      }
  }
}

function RestoreFocus(_ref) {
  let {
    disabled
  } = _ref;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = (0,external_React_namespaceObject.useContext)(InternalContext);
  const previousActivatorEvent = utilities_esm_usePrevious(activatorEvent);
  const previousActiveId = utilities_esm_usePrevious(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node

  (0,external_React_namespaceObject.useEffect)(() => {
    if (disabled) {
      return;
    }

    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!utilities_esm_isKeyboardEvent(previousActivatorEvent)) {
        return;
      }

      if (document.activeElement === previousActivatorEvent.target) {
        // No need to restore focus
        return;
      }

      const draggableNode = draggableNodes.get(previousActiveId);

      if (!draggableNode) {
        return;
      }

      const {
        activatorNode,
        node
      } = draggableNode;

      if (!activatorNode.current && !node.current) {
        return;
      }

      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node.current]) {
          if (!element) {
            continue;
          }

          const focusableNode = findFirstFocusableNode(element);

          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}

function applyModifiers(modifiers, _ref) {
  let {
    transform,
    ...args
  } = _ref;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}

function useMeasuringConfiguration(config) {
  return (0,external_React_namespaceObject.useMemo)(() => ({
    draggable: { ...defaultMeasuringConfiguration.draggable,
      ...(config == null ? void 0 : config.draggable)
    },
    droppable: { ...defaultMeasuringConfiguration.droppable,
      ...(config == null ? void 0 : config.droppable)
    },
    dragOverlay: { ...defaultMeasuringConfiguration.dragOverlay,
      ...(config == null ? void 0 : config.dragOverlay)
    }
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]);
}

function useLayoutShiftScrollCompensation(_ref) {
  let {
    activeNode,
    measure,
    initialRect,
    config = true
  } = _ref;
  const initialized = (0,external_React_namespaceObject.useRef)(false);
  const {
    x,
    y
  } = typeof config === 'boolean' ? {
    x: config,
    y: config
  } : config;
  utilities_esm_useIsomorphicLayoutEffect(() => {
    const disabled = !x && !y;

    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }

    if (initialized.current || !initialRect) {
      // Return early if layout shift scroll compensation was already attempted
      // or if there is no initialRect to compare to.
      return;
    } // Get the most up to date node ref for the active draggable


    const node = activeNode == null ? void 0 : activeNode.node.current;

    if (!node || node.isConnected === false) {
      // Return early if there is no attached node ref or if the node is
      // disconnected from the document.
      return;
    }

    const rect = measure(node);
    const rectDelta = getRectDelta(rect, initialRect);

    if (!x) {
      rectDelta.x = 0;
    }

    if (!y) {
      rectDelta.y = 0;
    } // Only perform layout shift scroll compensation once


    initialized.current = true;

    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node);

      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x, y, initialRect, measure]);
}

const ActiveDraggableContext = /*#__PURE__*/(0,external_React_namespaceObject.createContext)({ ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var Status;

(function (Status) {
  Status[Status["Uninitialized"] = 0] = "Uninitialized";
  Status[Status["Initializing"] = 1] = "Initializing";
  Status[Status["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));

const DndContext = /*#__PURE__*/(0,external_React_namespaceObject.memo)(function DndContext(_ref) {
  var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;

  let {
    id,
    accessibility,
    autoScroll = true,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers,
    ...props
  } = _ref;
  const store = (0,external_React_namespaceObject.useReducer)(reducer, undefined, getInitialState);
  const [state, dispatch] = store;
  const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
  const [status, setStatus] = (0,external_React_namespaceObject.useState)(Status.Uninitialized);
  const isInitialized = status === Status.Initialized;
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node = activeId ? draggableNodes.get(activeId) : null;
  const activeRects = (0,external_React_namespaceObject.useRef)({
    initial: null,
    translated: null
  });
  const active = (0,external_React_namespaceObject.useMemo)(() => {
    var _node$data;

    return activeId != null ? {
      id: activeId,
      // It's possible for the active node to unmount while dragging
      data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node]);
  const activeRef = (0,external_React_namespaceObject.useRef)(null);
  const [activeSensor, setActiveSensor] = (0,external_React_namespaceObject.useState)(null);
  const [activatorEvent, setActivatorEvent] = (0,external_React_namespaceObject.useState)(null);
  const latestProps = useLatestValue(props, Object.values(props));
  const draggableDescribedById = useUniqueId("DndDescribedBy", id);
  const enabledDroppableContainers = (0,external_React_namespaceObject.useMemo)(() => droppableContainers.getEnabled(), [droppableContainers]);
  const measuringConfiguration = useMeasuringConfiguration(measuring);
  const {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isInitialized,
    dependencies: [translate.x, translate.y],
    config: measuringConfiguration.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = (0,external_React_namespaceObject.useMemo)(() => activatorEvent ? utilities_esm_getEventCoordinates(activatorEvent) : null, [activatorEvent]);
  const autoScrollOptions = getAutoScrollerOptions();
  const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
  useLayoutShiftScrollCompensation({
    activeNode: activeId ? draggableNodes.get(activeId) : null,
    config: autoScrollOptions.layoutShiftCompensation,
    initialRect: initialActiveNodeRect,
    measure: measuringConfiguration.draggable.measure
  });
  const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
  const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
  const sensorContext = (0,external_React_namespaceObject.useRef)({
    activatorEvent: null,
    active: null,
    activeNode,
    collisionRect: null,
    collisions: null,
    droppableRects,
    draggableNodes,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const dragOverlay = useDragOverlayMeasuring({
    measure: measuringConfiguration.dragOverlay.measure
  }); // Use the rect of the drag overlay if it is mounted

  const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
  const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
  const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node
  // is only relevant when there is no drag overlay

  const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node

  const windowRect = useWindowRect(draggingNode ? utilities_esm_getWindow(draggingNode) : null); // Get scrollable ancestors of the dragging node

  const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers

  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated

  const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured

  const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisions = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null;
  const overId = core_esm_getFirstCollision(collisions, 'id');
  const [over, setOver] = (0,external_React_namespaceObject.useState)(null); // When there is no drag overlay used, we need to account for the
  // window scroll delta

  const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
  const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const instantiateSensor = (0,external_React_namespaceObject.useCallback)((event, _ref2) => {
    let {
      sensor: Sensor,
      options
    } = _ref2;

    if (activeRef.current == null) {
      return;
    }

    const activeNode = draggableNodes.get(activeRef.current);

    if (!activeNode) {
      return;
    }

    const activatorEvent = event.nativeEvent;
    const sensorInstance = new Sensor({
      active: activeRef.current,
      activeNode,
      event: activatorEvent,
      options,
      // Sensors need to be instantiated with refs for arguments that change over time
      // otherwise they are frozen in time with the stale arguments
      context: sensorContext,

      onStart(initialCoordinates) {
        const id = activeRef.current;

        if (id == null) {
          return;
        }

        const draggableNode = draggableNodes.get(id);

        if (!draggableNode) {
          return;
        }

        const {
          onDragStart
        } = latestProps.current;
        const event = {
          active: {
            id,
            data: draggableNode.data,
            rect: activeRects
          }
        };
        (0,external_ReactDOM_.unstable_batchedUpdates)(() => {
          onDragStart == null ? void 0 : onDragStart(event);
          setStatus(Status.Initializing);
          dispatch({
            type: Action.DragStart,
            initialCoordinates,
            active: id
          });
          dispatchMonitorEvent({
            type: 'onDragStart',
            event
          });
        });
      },

      onMove(coordinates) {
        dispatch({
          type: Action.DragMove,
          coordinates
        });
      },

      onEnd: createHandler(Action.DragEnd),
      onCancel: createHandler(Action.DragCancel)
    });
    (0,external_ReactDOM_.unstable_batchedUpdates)(() => {
      setActiveSensor(sensorInstance);
      setActivatorEvent(event.nativeEvent);
    });

    function createHandler(type) {
      return async function handler() {
        const {
          active,
          collisions,
          over,
          scrollAdjustedTranslate
        } = sensorContext.current;
        let event = null;

        if (active && scrollAdjustedTranslate) {
          const {
            cancelDrop
          } = latestProps.current;
          event = {
            activatorEvent,
            active: active,
            collisions,
            delta: scrollAdjustedTranslate,
            over
          };

          if (type === Action.DragEnd && typeof cancelDrop === 'function') {
            const shouldCancel = await Promise.resolve(cancelDrop(event));

            if (shouldCancel) {
              type = Action.DragCancel;
            }
          }
        }

        activeRef.current = null;
        (0,external_ReactDOM_.unstable_batchedUpdates)(() => {
          dispatch({
            type
          });
          setStatus(Status.Uninitialized);
          setOver(null);
          setActiveSensor(null);
          setActivatorEvent(null);
          const eventName = type === Action.DragEnd ? 'onDragEnd' : 'onDragCancel';

          if (event) {
            const handler = latestProps.current[eventName];
            handler == null ? void 0 : handler(event);
            dispatchMonitorEvent({
              type: eventName,
              event
            });
          }
        });
      };
    }
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [draggableNodes]);
  const bindActivatorToSensorInstantiator = (0,external_React_namespaceObject.useCallback)((handler, sensor) => {
    return (event, active) => {
      const nativeEvent = event.nativeEvent;
      const activeDraggableNode = draggableNodes.get(active);

      if ( // Another sensor is already instantiating
      activeRef.current !== null || // No active draggable
      !activeDraggableNode || // Event has already been captured
      nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }

      const activationContext = {
        active: activeDraggableNode
      };
      const shouldActivate = handler(event, sensor.options, activationContext);

      if (shouldActivate === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active;
        instantiateSensor(event, sensor);
      }
    };
  }, [draggableNodes, instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    if (activeNodeRect && status === Status.Initializing) {
      setStatus(Status.Initialized);
    }
  }, [activeNodeRect, status]);
  (0,external_React_namespaceObject.useEffect)(() => {
    const {
      onDragMove
    } = latestProps.current;
    const {
      active,
      activatorEvent,
      collisions,
      over
    } = sensorContext.current;

    if (!active || !activatorEvent) {
      return;
    }

    const event = {
      active,
      activatorEvent,
      collisions,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over
    };
    (0,external_ReactDOM_.unstable_batchedUpdates)(() => {
      onDragMove == null ? void 0 : onDragMove(event);
      dispatchMonitorEvent({
        type: 'onDragMove',
        event
      });
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
  (0,external_React_namespaceObject.useEffect)(() => {
    const {
      active,
      activatorEvent,
      collisions,
      droppableContainers,
      scrollAdjustedTranslate
    } = sensorContext.current;

    if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {
      return;
    }

    const {
      onDragOver
    } = latestProps.current;
    const overContainer = droppableContainers.get(overId);
    const over = overContainer && overContainer.rect.current ? {
      id: overContainer.id,
      rect: overContainer.rect.current,
      data: overContainer.data,
      disabled: overContainer.disabled
    } : null;
    const event = {
      active,
      activatorEvent,
      collisions,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over
    };
    (0,external_ReactDOM_.unstable_batchedUpdates)(() => {
      setOver(over);
      onDragOver == null ? void 0 : onDragOver(event);
      dispatchMonitorEvent({
        type: 'onDragOver',
        event
      });
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [overId]);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    sensorContext.current = {
      activatorEvent,
      active,
      activeNode,
      collisionRect,
      collisions,
      droppableRects,
      draggableNodes,
      draggingNode,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: collisionRect
    };
  }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
  useAutoScroller({ ...autoScrollOptions,
    delta: translate,
    draggingRect: collisionRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const publicContext = (0,external_React_namespaceObject.useMemo)(() => {
    const context = {
      active,
      activeNode,
      activeNodeRect,
      activatorEvent,
      collisions,
      containerNodeRect,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      measureDroppableContainers,
      scrollableAncestors,
      scrollableAncestorRects,
      measuringConfiguration,
      measuringScheduled,
      windowRect
    };
    return context;
  }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
  const internalContext = (0,external_React_namespaceObject.useMemo)(() => {
    const context = {
      activatorEvent,
      activators,
      active,
      activeNodeRect,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      dispatch,
      draggableNodes,
      over,
      measureDroppableContainers
    };
    return context;
  }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
  return external_React_default().createElement(DndMonitorContext.Provider, {
    value: registerMonitorListener
  }, external_React_default().createElement(InternalContext.Provider, {
    value: internalContext
  }, external_React_default().createElement(PublicContext.Provider, {
    value: publicContext
  }, external_React_default().createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), external_React_default().createElement(RestoreFocus, {
    disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
  })), external_React_default().createElement(Accessibility, { ...accessibility,
    hiddenTextDescribedById: draggableDescribedById
  }));

  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === 'object' ? autoScroll.enabled === false : autoScroll === false;
    const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;

    if (typeof autoScroll === 'object') {
      return { ...autoScroll,
        enabled
      };
    }

    return {
      enabled
    };
  }
});

const NullContext = /*#__PURE__*/(0,external_React_namespaceObject.createContext)(null);
const defaultRole = 'button';
const ID_PREFIX = 'Droppable';
function useDraggable(_ref) {
  let {
    id,
    data,
    disabled = false,
    attributes
  } = _ref;
  const key = useUniqueId(ID_PREFIX);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = (0,external_React_namespaceObject.useContext)(InternalContext);
  const {
    role = defaultRole,
    roleDescription = 'draggable',
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id;
  const transform = (0,external_React_namespaceObject.useContext)(isDragging ? ActiveDraggableContext : NullContext);
  const [node, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id);
  const dataRef = useLatestValue(data);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    draggableNodes.set(id, {
      id,
      key,
      node,
      activatorNode,
      data: dataRef
    });
    return () => {
      const node = draggableNodes.get(id);

      if (node && node.key === key) {
        draggableNodes.delete(id);
      }
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [draggableNodes, id]);
  const memoizedAttributes = (0,external_React_namespaceObject.useMemo)(() => ({
    role,
    tabIndex,
    'aria-disabled': disabled,
    'aria-pressed': isDragging && role === defaultRole ? true : undefined,
    'aria-roledescription': roleDescription,
    'aria-describedby': ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? undefined : listeners,
    node,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}

function useDndContext() {
  return (0,external_React_namespaceObject.useContext)(PublicContext);
}

const ID_PREFIX$1 = 'Droppable';
const defaultResizeObserverConfig = {
  timeout: 25
};
function useDroppable(_ref) {
  let {
    data,
    disabled = false,
    id,
    resizeObserverConfig
  } = _ref;
  const key = useUniqueId(ID_PREFIX$1);
  const {
    active,
    dispatch,
    over,
    measureDroppableContainers
  } = (0,external_React_namespaceObject.useContext)(InternalContext);
  const previous = (0,external_React_namespaceObject.useRef)({
    disabled
  });
  const resizeObserverConnected = (0,external_React_namespaceObject.useRef)(false);
  const rect = (0,external_React_namespaceObject.useRef)(null);
  const callbackId = (0,external_React_namespaceObject.useRef)(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = { ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
  const handleResize = (0,external_React_namespaceObject.useCallback)(() => {
    if (!resizeObserverConnected.current) {
      // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,
      // assuming the element is rendered and displayed.
      resizeObserverConnected.current = true;
      return;
    }

    if (callbackId.current != null) {
      clearTimeout(callbackId.current);
    }

    callbackId.current = setTimeout(() => {
      measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [ids.current]);
      callbackId.current = null;
    }, resizeObserverTimeout);
  }, //eslint-disable-next-line react-hooks/exhaustive-deps
  [resizeObserverTimeout]);
  const resizeObserver = useResizeObserver({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = (0,external_React_namespaceObject.useCallback)((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }

    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }

    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }

    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    dispatch({
      type: Action.RegisterDroppable,
      element: {
        id,
        key,
        disabled,
        node: nodeRef,
        rect,
        data: dataRef
      }
    });
    return () => dispatch({
      type: Action.UnregisterDroppable,
      key,
      id
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [id]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (disabled !== previous.current.disabled) {
      dispatch({
        type: Action.SetDroppableDisabled,
        id,
        key,
        disabled
      });
      previous.current.disabled = disabled;
    }
  }, [id, key, disabled, dispatch]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id,
    node: nodeRef,
    over,
    setNodeRef
  };
}

function AnimationManager(_ref) {
  let {
    animation,
    children
  } = _ref;
  const [clonedChildren, setClonedChildren] = useState(null);
  const [element, setElement] = useState(null);
  const previousChildren = usePrevious(children);

  if (!children && !clonedChildren && previousChildren) {
    setClonedChildren(previousChildren);
  }

  useIsomorphicLayoutEffect(() => {
    if (!element) {
      return;
    }

    const key = clonedChildren == null ? void 0 : clonedChildren.key;
    const id = clonedChildren == null ? void 0 : clonedChildren.props.id;

    if (key == null || id == null) {
      setClonedChildren(null);
      return;
    }

    Promise.resolve(animation(id, element)).then(() => {
      setClonedChildren(null);
    });
  }, [animation, clonedChildren, element]);
  return React.createElement(React.Fragment, null, children, clonedChildren ? cloneElement(clonedChildren, {
    ref: setElement
  }) : null);
}

const defaultTransform = {
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1
};
function NullifiedContextProvider(_ref) {
  let {
    children
  } = _ref;
  return React.createElement(InternalContext.Provider, {
    value: defaultInternalContext
  }, React.createElement(ActiveDraggableContext.Provider, {
    value: defaultTransform
  }, children));
}

const baseStyles = {
  position: 'fixed',
  touchAction: 'none'
};

const defaultTransition = activatorEvent => {
  const isKeyboardActivator = isKeyboardEvent(activatorEvent);
  return isKeyboardActivator ? 'transform 250ms ease' : undefined;
};

const PositionedOverlay = /*#__PURE__*/(/* unused pure expression or super */ null && (forwardRef((_ref, ref) => {
  let {
    as,
    activatorEvent,
    adjustScale,
    children,
    className,
    rect,
    style,
    transform,
    transition = defaultTransition
  } = _ref;

  if (!rect) {
    return null;
  }

  const scaleAdjustedTransform = adjustScale ? transform : { ...transform,
    scaleX: 1,
    scaleY: 1
  };
  const styles = { ...baseStyles,
    width: rect.width,
    height: rect.height,
    top: rect.top,
    left: rect.left,
    transform: CSS.Transform.toString(scaleAdjustedTransform),
    transformOrigin: adjustScale && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : undefined,
    transition: typeof transition === 'function' ? transition(activatorEvent) : transition,
    ...style
  };
  return React.createElement(as, {
    className,
    style: styles,
    ref
  }, children);
})));

const defaultDropAnimationSideEffects = options => _ref => {
  let {
    active,
    dragOverlay
  } = _ref;
  const originalStyles = {};
  const {
    styles,
    className
  } = options;

  if (styles != null && styles.active) {
    for (const [key, value] of Object.entries(styles.active)) {
      if (value === undefined) {
        continue;
      }

      originalStyles[key] = active.node.style.getPropertyValue(key);
      active.node.style.setProperty(key, value);
    }
  }

  if (styles != null && styles.dragOverlay) {
    for (const [key, value] of Object.entries(styles.dragOverlay)) {
      if (value === undefined) {
        continue;
      }

      dragOverlay.node.style.setProperty(key, value);
    }
  }

  if (className != null && className.active) {
    active.node.classList.add(className.active);
  }

  if (className != null && className.dragOverlay) {
    dragOverlay.node.classList.add(className.dragOverlay);
  }

  return function cleanup() {
    for (const [key, value] of Object.entries(originalStyles)) {
      active.node.style.setProperty(key, value);
    }

    if (className != null && className.active) {
      active.node.classList.remove(className.active);
    }
  };
};

const defaultKeyframeResolver = _ref2 => {
  let {
    transform: {
      initial,
      final
    }
  } = _ref2;
  return [{
    transform: utilities_esm_CSS.Transform.toString(initial)
  }, {
    transform: utilities_esm_CSS.Transform.toString(final)
  }];
};

const defaultDropAnimationConfiguration = {
  duration: 250,
  easing: 'ease',
  keyframes: defaultKeyframeResolver,
  sideEffects: /*#__PURE__*/defaultDropAnimationSideEffects({
    styles: {
      active: {
        opacity: '0'
      }
    }
  })
};
function useDropAnimation(_ref3) {
  let {
    config,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  } = _ref3;
  return useEvent((id, node) => {
    if (config === null) {
      return;
    }

    const activeDraggable = draggableNodes.get(id);

    if (!activeDraggable) {
      return;
    }

    const activeNode = activeDraggable.node.current;

    if (!activeNode) {
      return;
    }

    const measurableNode = getMeasurableNode(node);

    if (!measurableNode) {
      return;
    }

    const {
      transform
    } = getWindow(node).getComputedStyle(node);
    const parsedTransform = parseTransform(transform);

    if (!parsedTransform) {
      return;
    }

    const animation = typeof config === 'function' ? config : createDefaultDropAnimation(config);
    scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);
    return animation({
      active: {
        id,
        data: activeDraggable.data,
        node: activeNode,
        rect: measuringConfiguration.draggable.measure(activeNode)
      },
      draggableNodes,
      dragOverlay: {
        node,
        rect: measuringConfiguration.dragOverlay.measure(measurableNode)
      },
      droppableContainers,
      measuringConfiguration,
      transform: parsedTransform
    });
  });
}

function createDefaultDropAnimation(options) {
  const {
    duration,
    easing,
    sideEffects,
    keyframes
  } = { ...defaultDropAnimationConfiguration,
    ...options
  };
  return _ref4 => {
    let {
      active,
      dragOverlay,
      transform,
      ...rest
    } = _ref4;

    if (!duration) {
      // Do not animate if animation duration is zero.
      return;
    }

    const delta = {
      x: dragOverlay.rect.left - active.rect.left,
      y: dragOverlay.rect.top - active.rect.top
    };
    const scale = {
      scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,
      scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1
    };
    const finalTransform = {
      x: transform.x - delta.x,
      y: transform.y - delta.y,
      ...scale
    };
    const animationKeyframes = keyframes({ ...rest,
      active,
      dragOverlay,
      transform: {
        initial: transform,
        final: finalTransform
      }
    });
    const [firstKeyframe] = animationKeyframes;
    const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];

    if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {
      // The start and end keyframes are the same, infer that there is no animation needed.
      return;
    }

    const cleanup = sideEffects == null ? void 0 : sideEffects({
      active,
      dragOverlay,
      ...rest
    });
    const animation = dragOverlay.node.animate(animationKeyframes, {
      duration,
      easing,
      fill: 'forwards'
    });
    return new Promise(resolve => {
      animation.onfinish = () => {
        cleanup == null ? void 0 : cleanup();
        resolve();
      };
    });
  };
}

let key = 0;
function useKey(id) {
  return useMemo(() => {
    if (id == null) {
      return;
    }

    key++;
    return key;
  }, [id]);
}

const DragOverlay = /*#__PURE__*/(/* unused pure expression or super */ null && (React.memo(_ref => {
  let {
    adjustScale = false,
    children,
    dropAnimation: dropAnimationConfig,
    style,
    transition,
    modifiers,
    wrapperElement = 'div',
    className,
    zIndex = 999
  } = _ref;
  const {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggableNodes,
    droppableContainers,
    dragOverlay,
    over,
    measuringConfiguration,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  } = useDndContext();
  const transform = useContext(ActiveDraggableContext);
  const key = useKey(active == null ? void 0 : active.id);
  const modifiedTransform = applyModifiers(modifiers, {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect: dragOverlay.rect,
    over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    transform,
    windowRect
  });
  const initialRect = useInitialValue(activeNodeRect);
  const dropAnimation = useDropAnimation({
    config: dropAnimationConfig,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  }); // We need to wait for the active node to be measured before connecting the drag overlay ref
  // otherwise collisions can be computed against a mispositioned drag overlay

  const ref = initialRect ? dragOverlay.setRef : undefined;
  return React.createElement(NullifiedContextProvider, null, React.createElement(AnimationManager, {
    animation: dropAnimation
  }, active && key ? React.createElement(PositionedOverlay, {
    key: key,
    id: active.id,
    ref: ref,
    as: wrapperElement,
    activatorEvent: activatorEvent,
    adjustScale: adjustScale,
    className: className,
    transition: transition,
    rect: initialRect,
    style: {
      zIndex,
      ...style
    },
    transform: modifiedTransform
  }, children) : null));
})));


//# sourceMappingURL=core.esm.js.map

;// CONCATENATED MODULE: ./node_modules/.pnpm/@dnd-kit+sortable@7.0.2_@dnd-kit+core@6.0.8_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/@dnd-kit/sortable/dist/sortable.esm.js




/**
 * Move an array item to a different position. Returns a new array with the item moved to the new position.
 */
function arrayMove(array, from, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}

/**
 * Swap an array item to a different position. Returns a new array with the item swapped to the new position.
 */
function arraySwap(array, from, to) {
  const newArray = array.slice();
  newArray[from] = array[to];
  newArray[to] = array[from];
  return newArray;
}

function getSortedRects(items, rects) {
  return items.reduce((accumulator, id, index) => {
    const rect = rects.get(id);

    if (rect) {
      accumulator[index] = rect;
    }

    return accumulator;
  }, Array(items.length));
}

function isValidIndex(index) {
  return index !== null && index >= 0;
}

function itemsEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
}

function normalizeDisabled(disabled) {
  if (typeof disabled === 'boolean') {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }

  return disabled;
}

// To-do: We should be calculating scale transformation
const defaultScale = {
  scaleX: 1,
  scaleY: 1
};
const horizontalListSortingStrategy = _ref => {
  var _rects$activeIndex;

  let {
    rects,
    activeNodeRect: fallbackActiveRect,
    activeIndex,
    overIndex,
    index
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;

  if (!activeNodeRect) {
    return null;
  }

  const itemGap = getItemGap(rects, index, activeIndex);

  if (index === activeIndex) {
    const newIndexRect = rects[overIndex];

    if (!newIndexRect) {
      return null;
    }

    return {
      x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,
      y: 0,
      ...defaultScale
    };
  }

  if (index > activeIndex && index <= overIndex) {
    return {
      x: -activeNodeRect.width - itemGap,
      y: 0,
      ...defaultScale
    };
  }

  if (index < activeIndex && index >= overIndex) {
    return {
      x: activeNodeRect.width + itemGap,
      y: 0,
      ...defaultScale
    };
  }

  return {
    x: 0,
    y: 0,
    ...defaultScale
  };
};

function getItemGap(rects, index, activeIndex) {
  const currentRect = rects[index];
  const previousRect = rects[index - 1];
  const nextRect = rects[index + 1];

  if (!currentRect || !previousRect && !nextRect) {
    return 0;
  }

  if (activeIndex < index) {
    return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);
  }

  return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);
}

const rectSortingStrategy = _ref => {
  let {
    rects,
    activeIndex,
    overIndex,
    index
  } = _ref;
  const newRects = arrayMove(rects, overIndex, activeIndex);
  const oldRect = rects[index];
  const newRect = newRects[index];

  if (!newRect || !oldRect) {
    return null;
  }

  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};

const rectSwappingStrategy = _ref => {
  let {
    activeIndex,
    index,
    rects,
    overIndex
  } = _ref;
  let oldRect;
  let newRect;

  if (index === activeIndex) {
    oldRect = rects[index];
    newRect = rects[overIndex];
  }

  if (index === overIndex) {
    oldRect = rects[index];
    newRect = rects[activeIndex];
  }

  if (!newRect || !oldRect) {
    return null;
  }

  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};

// To-do: We should be calculating scale transformation
const defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
const verticalListSortingStrategy = _ref => {
  var _rects$activeIndex;

  let {
    activeIndex,
    activeNodeRect: fallbackActiveRect,
    index,
    rects,
    overIndex
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;

  if (!activeNodeRect) {
    return null;
  }

  if (index === activeIndex) {
    const overIndexRect = rects[overIndex];

    if (!overIndexRect) {
      return null;
    }

    return {
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
      ...defaultScale$1
    };
  }

  const itemGap = getItemGap$1(rects, index, activeIndex);

  if (index > activeIndex && index <= overIndex) {
    return {
      x: 0,
      y: -activeNodeRect.height - itemGap,
      ...defaultScale$1
    };
  }

  if (index < activeIndex && index >= overIndex) {
    return {
      x: 0,
      y: activeNodeRect.height + itemGap,
      ...defaultScale$1
    };
  }

  return {
    x: 0,
    y: 0,
    ...defaultScale$1
  };
};

function getItemGap$1(clientRects, index, activeIndex) {
  const currentRect = clientRects[index];
  const previousRect = clientRects[index - 1];
  const nextRect = clientRects[index + 1];

  if (!currentRect) {
    return 0;
  }

  if (activeIndex < index) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }

  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}

const sortable_esm_ID_PREFIX = 'Sortable';
const Context = /*#__PURE__*/external_React_default().createContext({
  activeIndex: -1,
  containerId: sortable_esm_ID_PREFIX,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  disabled: {
    draggable: false,
    droppable: false
  }
});
function SortableContext(_ref) {
  let {
    children,
    id,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId(sortable_esm_ID_PREFIX, id);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = (0,external_React_namespaceObject.useMemo)(() => userDefinedItems.map(item => typeof item === 'object' && 'id' in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = (0,external_React_namespaceObject.useRef)(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  (0,external_React_namespaceObject.useEffect)(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = (0,external_React_namespaceObject.useMemo)(() => ({
    activeIndex,
    containerId,
    disabled,
    disableTransforms,
    items,
    overIndex,
    useDragOverlay,
    sortedRects: getSortedRects(items, droppableRects),
    strategy
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]);
  return external_React_default().createElement(Context.Provider, {
    value: contextValue
  }, children);
}

const defaultNewIndexGetter = _ref => {
  let {
    id,
    items,
    activeIndex,
    overIndex
  } = _ref;
  return arrayMove(items, activeIndex, overIndex).indexOf(id);
};
const defaultAnimateLayoutChanges = _ref2 => {
  let {
    containerId,
    isSorting,
    wasDragging,
    index,
    items,
    newIndex,
    previousItems,
    previousContainerId,
    transition
  } = _ref2;

  if (!transition || !wasDragging) {
    return false;
  }

  if (previousItems !== items && index === newIndex) {
    return false;
  }

  if (isSorting) {
    return true;
  }

  return newIndex !== index && containerId === previousContainerId;
};
const sortable_esm_defaultTransition = {
  duration: 200,
  easing: 'ease'
};
const transitionProperty = 'transform';
const disabledTransition = /*#__PURE__*/utilities_esm_CSS.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: 'linear'
});
const defaultAttributes = {
  roleDescription: 'sortable'
};

/*
 * When the index of an item changes while sorting,
 * we need to temporarily disable the transforms
 */

function useDerivedTransform(_ref) {
  let {
    disabled,
    index,
    node,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = (0,external_React_namespaceObject.useState)(null);
  const previousIndex = (0,external_React_namespaceObject.useRef)(index);
  utilities_esm_useIsomorphicLayoutEffect(() => {
    if (!disabled && index !== previousIndex.current && node.current) {
      const initial = rect.current;

      if (initial) {
        const current = getClientRect(node.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current.left,
          y: initial.top - current.top,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };

        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }

    if (index !== previousIndex.current) {
      previousIndex.current = index;
    }
  }, [disabled, index, node, rect]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}

function useSortable(_ref) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = sortable_esm_defaultTransition
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = (0,external_React_namespaceObject.useContext)(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index = items.indexOf(id);
  const data = (0,external_React_namespaceObject.useMemo)(() => ({
    sortable: {
      containerId,
      index,
      items
    },
    ...customData
  }), [containerId, customData, index, items]);
  const itemsAfterCurrentSortable = (0,external_React_namespaceObject.useMemo)(() => items.slice(items.indexOf(id)), [items, id]);
  const {
    rect,
    node,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id,
    data,
    attributes: { ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id,
    items,
    activeIndex,
    overIndex
  }) : index;
  const activeId = active == null ? void 0 : active.id;
  const previous = (0,external_React_namespaceObject.useRef)({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id,
    index,
    items,
    newIndex: previous.current.newIndex,
    previousItems: previous.current.items,
    previousContainerId: previous.current.containerId,
    transition,
    wasDragging: previous.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index,
    node,
    rect
  });
  (0,external_React_namespaceObject.useEffect)(() => {
    if (isSorting && previous.current.newIndex !== newIndex) {
      previous.current.newIndex = newIndex;
    }

    if (containerId !== previous.current.containerId) {
      previous.current.containerId = containerId;
    }

    if (items !== previous.current.items) {
      previous.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  (0,external_React_namespaceObject.useEffect)(() => {
    if (activeId === previous.current.activeId) {
      return;
    }

    if (activeId && !previous.current.activeId) {
      previous.current.activeId = activeId;
      return;
    }

    const timeoutId = setTimeout(() => {
      previous.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };

  function getTransition() {
    if ( // Temporarily disable transitions for a single frame to set up derived transforms
    derivedTransform || // Or to prevent items jumping to back to their "new" position when items change
    itemsHaveChanged && previous.current.newIndex === index) {
      return disabledTransition;
    }

    if (shouldDisplaceDragSource && !utilities_esm_isKeyboardEvent(activatorEvent) || !transition) {
      return undefined;
    }

    if (isSorting || shouldAnimateLayoutChanges) {
      return utilities_esm_CSS.Transition.toString({ ...transition,
        property: transitionProperty
      });
    }

    return undefined;
  }
}

function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;

  if (typeof localDisabled === 'boolean') {
    return {
      draggable: localDisabled,
      // Backwards compatibility
      droppable: false
    };
  }

  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}

function hasSortableData(entry) {
  if (!entry) {
    return false;
  }

  const data = entry.data.current;

  if (data && 'sortable' in data && typeof data.sortable === 'object' && 'containerId' in data.sortable && 'items' in data.sortable && 'index' in data.sortable) {
    return true;
  }

  return false;
}

const directions = [core_esm_KeyboardCode.Down, core_esm_KeyboardCode.Right, core_esm_KeyboardCode.Up, core_esm_KeyboardCode.Left];
const sortableKeyboardCoordinates = (event, _ref) => {
  let {
    context: {
      active,
      collisionRect,
      droppableRects,
      droppableContainers,
      over,
      scrollableAncestors
    }
  } = _ref;

  if (directions.includes(event.code)) {
    event.preventDefault();

    if (!active || !collisionRect) {
      return;
    }

    const filteredContainers = [];
    droppableContainers.getEnabled().forEach(entry => {
      if (!entry || entry != null && entry.disabled) {
        return;
      }

      const rect = droppableRects.get(entry.id);

      if (!rect) {
        return;
      }

      switch (event.code) {
        case KeyboardCode.Down:
          if (collisionRect.top < rect.top) {
            filteredContainers.push(entry);
          }

          break;

        case KeyboardCode.Up:
          if (collisionRect.top > rect.top) {
            filteredContainers.push(entry);
          }

          break;

        case KeyboardCode.Left:
          if (collisionRect.left > rect.left) {
            filteredContainers.push(entry);
          }

          break;

        case KeyboardCode.Right:
          if (collisionRect.left < rect.left) {
            filteredContainers.push(entry);
          }

          break;
      }
    });
    const collisions = closestCorners({
      active,
      collisionRect: collisionRect,
      droppableRects,
      droppableContainers: filteredContainers,
      pointerCoordinates: null
    });
    let closestId = getFirstCollision(collisions, 'id');

    if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {
      closestId = collisions[1].id;
    }

    if (closestId != null) {
      const activeDroppable = droppableContainers.get(active.id);
      const newDroppable = droppableContainers.get(closestId);
      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
      const newNode = newDroppable == null ? void 0 : newDroppable.node.current;

      if (newNode && newRect && activeDroppable && newDroppable) {
        const newScrollAncestors = getScrollableAncestors(newNode);
        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index) => scrollableAncestors[index] !== element);
        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);
        const isAfterActive = isAfter(activeDroppable, newDroppable);
        const offset = hasDifferentScrollAncestors || !hasSameContainer ? {
          x: 0,
          y: 0
        } : {
          x: isAfterActive ? collisionRect.width - newRect.width : 0,
          y: isAfterActive ? collisionRect.height - newRect.height : 0
        };
        const rectCoordinates = {
          x: newRect.left,
          y: newRect.top
        };
        const newCoordinates = offset.x && offset.y ? rectCoordinates : subtract(rectCoordinates, offset);
        return newCoordinates;
      }
    }
  }

  return undefined;
};

function isSameContainer(a, b) {
  if (!hasSortableData(a) || !hasSortableData(b)) {
    return false;
  }

  return a.data.current.sortable.containerId === b.data.current.sortable.containerId;
}

function isAfter(a, b) {
  if (!hasSortableData(a) || !hasSortableData(b)) {
    return false;
  }

  if (!isSameContainer(a, b)) {
    return false;
  }

  return a.data.current.sortable.index < b.data.current.sortable.index;
}


//# sourceMappingURL=sortable.esm.js.map

;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/sort.js
var sort_assign = (undefined && undefined.__assign) || function () {
    sort_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return sort_assign.apply(this, arguments);
};
var sort_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



function SortableContainer(Component) {
    return function (_a) {
        var list = _a.list, _b = _a.start, start = _b === void 0 ? 0 : _b, accessibility = _a.accessibility, onSortStart = _a.onSortStart, onSortEnd = _a.onSortEnd, props = sort_rest(_a, ["list", "start", "accessibility", "onSortStart", "onSortEnd"]);
        var _onSortEnd = function (event) {
            var active = event.active, over = event.over;
            if (!over)
                return;
            var oldIndex = +active.id - 1;
            var newIndex = +over.id - 1;
            onSortEnd === null || onSortEnd === void 0 ? void 0 : onSortEnd({
                oldIndex: oldIndex,
                newIndex: newIndex,
            });
        };
        return (external_React_default().createElement(DndContext, { accessibility: accessibility, onDragStart: onSortStart, onDragEnd: _onSortEnd },
            external_React_default().createElement(SortableContext, { items: list.map(function (_, index) { return index + start + 1; }), strategy: verticalListSortingStrategy },
                external_React_default().createElement(Component, sort_assign({}, props), props.children))));
    };
}
var useSortableItem = function () {
    return (0,external_React_namespaceObject.useContext)(SortableItemContext);
};
var SortableItemContext = (0,external_React_namespaceObject.createContext)({});
function SortableElement(Component) {
    return function (_a) {
        var _b = _a.index, index = _b === void 0 ? 0 : _b, lockAxis = _a.lockAxis, props = sort_rest(_a, ["index", "lockAxis"]);
        var sortable = useSortable({
            id: index + 1,
        });
        var setNodeRef = sortable.setNodeRef, transform = sortable.transform, transition = sortable.transition, isDragging = sortable.isDragging;
        if (transform) {
            switch (lockAxis) {
                case 'x':
                    transform.y = 0;
                    break;
                case 'y':
                    transform.x = 0;
                    break;
                default:
                    break;
            }
        }
        var style = (0,external_React_namespaceObject.useMemo)(function () {
            var zIndex = transform ? 1 : 'none';
            var position = transform ? 'relative' : 'unset';
            var itemStyle = {
                position: position,
                touchAction: 'none',
                zIndex: zIndex,
                transform: transform
                    ? "translate3d(".concat(transform.x, "px, ").concat(transform.y, "px, 0)")
                    : 'none',
                transition: "".concat(transform ? 'all 200ms ease' : ''),
            };
            var dragStyle = {
                transition: transition,
                opacity: '0.8',
                transform: "translate3d(".concat((transform === null || transform === void 0 ? void 0 : transform.x) || 0, "px, ").concat((transform === null || transform === void 0 ? void 0 : transform.y) || 0, "px, 0)"),
            };
            var computedStyle = isDragging
                ? sort_assign(sort_assign(sort_assign({}, itemStyle), dragStyle), props.style) : sort_assign(sort_assign({}, itemStyle), props.style);
            return computedStyle;
        }, [isDragging, transform, transition, props.style]);
        return (external_React_default().createElement(SortableItemContext.Provider, { value: sortable }, Component(sort_assign(sort_assign({}, props), { style: style, ref: setNodeRef }))));
    };
}
function SortableHandle(Component) {
    return function (props) {
        var _a = useSortableItem(), attributes = _a.attributes, listeners = _a.listeners;
        return external_React_default().createElement(Component, sort_assign({}, props, attributes, listeners));
    };
}
//# sourceMappingURL=sort.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/hooks/usePrefixCls.js


var usePrefixCls = function (tag, props) {
    var _a;
    if ("ConfigContext" in external_antd_namespaceObject.ConfigProvider) {
        var getPrefixCls = (0,external_React_namespaceObject.useContext)(external_antd_namespaceObject.ConfigProvider.ConfigContext).getPrefixCls;
        return getPrefixCls(tag, props === null || props === void 0 ? void 0 : props.prefixCls);
    }
    else {
        var prefix = (_a = props === null || props === void 0 ? void 0 : props.prefixCls) !== null && _a !== void 0 ? _a : 'ant-';
        return "".concat(prefix).concat(tag !== null && tag !== void 0 ? tag : '');
    }
};
//# sourceMappingURL=usePrefixCls.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(o) {
  "@babel/helpers - typeof";

  return typeof_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, typeof_typeof(o);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != typeof_typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof_typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == typeof_typeof(i) ? i : i + "";
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/defineProperty.js

function defineProperty_defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function slicedToArray_slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.5/node_modules/@babel/runtime/helpers/esm/typeof.js
function esm_typeof_typeof(o) {
  "@babel/helpers - typeof";

  return esm_typeof_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, esm_typeof_typeof(o);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.5/node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive_toPrimitive(t, r) {
  if ("object" != esm_typeof_typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != esm_typeof_typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.5/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey_toPropertyKey(t) {
  var i = toPrimitive_toPrimitive(t, "string");
  return "symbol" == esm_typeof_typeof(i) ? i : i + "";
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.5/node_modules/@babel/runtime/helpers/esm/defineProperty.js

function esm_defineProperty_defineProperty(obj, key, value) {
  key = toPropertyKey_toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.5/node_modules/@babel/runtime/helpers/esm/objectSpread2.js

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      esm_defineProperty_defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/Dom/canUseDom.js
function canUseDom() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/Dom/contains.js
function contains_contains(root, n) {
  if (!root) {
    return false;
  }

  // Use native if support
  if (root.contains) {
    return root.contains(n);
  }

  // `document.contains` not support with IE11
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/Dom/dynamicCSS.js



var APPEND_ORDER = 'data-rc-order';
var APPEND_PRIORITY = 'data-rc-priority';
var MARK_KEY = "rc-util-key";
var containerCache = new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    mark = _ref.mark;
  if (mark) {
    return mark.startsWith('data-') ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector('head');
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === 'queue') {
    return 'prependQueue';
  }
  return prepend ? 'prepend' : 'append';
}

/**
 * Find style which inject by rc-util
 */
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function (node) {
    return node.tagName === 'STYLE';
  });
}
function injectCSS(css) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp,
    prepend = option.prepend,
    _option$priority = option.priority,
    priority = _option$priority === void 0 ? 0 : _option$priority;
  var mergedOrder = getOrder(prepend);
  var isPrependQueue = mergedOrder === 'prependQueue';
  var styleNode = document.createElement('style');
  styleNode.setAttribute(APPEND_ORDER, mergedOrder);
  if (isPrependQueue && priority) {
    styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
  }
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    // If is queue `prepend`, it will prepend first style and then append rest style
    if (isPrependQueue) {
      var existStyle = (option.styles || findStyles(container)).filter(function (node) {
        // Ignore style which not injected by rc-util with prepend
        if (!['prepend', 'prependQueue'].includes(node.getAttribute(APPEND_ORDER))) {
          return false;
        }

        // Ignore style which priority less then new style
        var nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
        return priority >= nodePriority;
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }

    // Use `insertBefore` as `prepend`
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var container = getContainer(option);
  return (option.styles || findStyles(container)).find(function (node) {
    return node.getAttribute(getMark(option)) === key;
  });
}
function dynamicCSS_removeCSS(key) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var existNode = findExistNode(key, option);
  if (existNode) {
    var container = getContainer(option);
    container.removeChild(existNode);
  }
}

/**
 * qiankun will inject `appendChild` to insert into other
 */
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);

  // Find real container when not cached or cached container removed
  if (!cachedRealContainer || !contains_contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS('', option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}

/**
 * manually clear container cache to avoid global cache in unit testes
 */
function clearContainerCache() {
  containerCache.clear();
}
function dynamicCSS_updateCSS(css, key) {
  var originOption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var container = getContainer(originOption);
  var styles = findStyles(container);
  var option = _objectSpread2(_objectSpread2({}, originOption), {}, {
    styles: styles
  });

  // Sync real parent
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css) {
      existNode.innerHTML = css;
    }
    return existNode;
  }
  var newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/hooks/useMemo.js

function useMemo_useMemo(getValue, condition, shouldUpdate) {
  var cacheRef = React.useRef({});
  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/warning.js
/* eslint-disable no-console */
var warned = {};
var preWarningFns = [];

/**
 * Pre warning enable you to parse content before console.error.
 * Modify to null will prevent warning.
 */
var preMessage = function preMessage(fn) {
  preWarningFns.push(fn);
};

/**
 * Warning if condition not match.
 * @param valid Condition
 * @param message Warning message
 * @example
 * ```js
 * warning(false, 'some error'); // print some error
 * warning(true, 'some error'); // print nothing
 * warning(1 === 2, 'some error'); // print some error
 * ```
 */
function warning_warning(valid, message) {
  if (false) { var finalMessage; }
}

/** @see Similar to {@link warning} */
function note(valid, message) {
  if (false) { var finalMessage; }
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}

/** @see Same as {@link warning}, but only warn once for the same message */
function warningOnce(valid, message) {
  call(warning_warning, valid, message);
}

/** @see Same as {@link warning}, but only warn once for the same message */
function noteOnce(valid, message) {
  call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
/* harmony default export */ const es_warning = ((/* unused pure expression or super */ null && (warningOnce)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/isEqual.js



/**
 * Deeply compares two object literals.
 * @param obj1 object 1
 * @param obj2 object 2
 * @param shallow shallow compare
 * @returns
 */
function isEqual_isEqual(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // https://github.com/mapbox/mapbox-gl-js/pull/5979/files#diff-fde7145050c47cc3a306856efd5f9c3016e86e859de9afbd02c879be5067e58f
  var refSet = new Set();
  function deepEqual(a, b) {
    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var circular = refSet.has(a);
    warning(!circular, 'Warning: There may be circular references');
    if (circular) {
      return false;
    }
    if (a === b) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a);
    var newLevel = level + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
      var keys = Object.keys(a);
      if (keys.length !== Object.keys(b).length) {
        return false;
      }
      return keys.every(function (key) {
        return deepEqual(a[key], b[key], newLevel);
      });
    }
    // other
    return false;
  }
  return deepEqual(obj1, obj2);
}
/* harmony default export */ const es_isEqual = ((/* unused pure expression or super */ null && (isEqual_isEqual)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function classCallCheck_classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/createClass.js

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function createClass_createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/Cache.js



// [times, realValue]

var SPLIT = '%';

/** Connect key with `SPLIT` */
function pathKey(keys) {
  return keys.join(SPLIT);
}
var Entity = /*#__PURE__*/function () {
  function Entity(instanceId) {
    classCallCheck_classCallCheck(this, Entity);
    defineProperty_defineProperty(this, "instanceId", void 0);
    /** @private Internal cache map. Do not access this directly */
    defineProperty_defineProperty(this, "cache", new Map());
    this.instanceId = instanceId;
  }
  createClass_createClass(Entity, [{
    key: "get",
    value: function get(keys) {
      return this.opGet(pathKey(keys));
    }

    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: function opGet(keyPathStr) {
      return this.cache.get(keyPathStr) || null;
    }
  }, {
    key: "update",
    value: function update(keys, valueFn) {
      return this.opUpdate(pathKey(keys), valueFn);
    }

    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: function opUpdate(keyPathStr, valueFn) {
      var prevValue = this.cache.get(keyPathStr);
      var nextValue = valueFn(prevValue);
      if (nextValue === null) {
        this.cache.delete(keyPathStr);
      } else {
        this.cache.set(keyPathStr, nextValue);
      }
    }
  }]);
  return Entity;
}();
/* harmony default export */ const Cache = (Entity);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/StyleContext.js


var _excluded = (/* unused pure expression or super */ null && (["children"]));




var StyleContext_ATTR_TOKEN = 'data-token-hash';
var StyleContext_ATTR_MARK = 'data-css-hash';
var ATTR_CACHE_PATH = 'data-cache-path';

// Mark css-in-js instance in style element
var StyleContext_CSS_IN_JS_INSTANCE = '__cssinjs_instance__';
function createCache() {
  var cssinjsInstanceId = Math.random().toString(12).slice(2);

  // Tricky SSR: Move all inline style to the head.
  // PS: We do not recommend tricky mode.
  if (typeof document !== 'undefined' && document.head && document.body) {
    var styles = document.body.querySelectorAll("style[".concat(StyleContext_ATTR_MARK, "]")) || [];
    var firstChild = document.head.firstChild;
    Array.from(styles).forEach(function (style) {
      style[StyleContext_CSS_IN_JS_INSTANCE] = style[StyleContext_CSS_IN_JS_INSTANCE] || cssinjsInstanceId;

      // Not force move if no head
      if (style[StyleContext_CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
        document.head.insertBefore(style, firstChild);
      }
    });

    // Deduplicate of moved styles
    var styleHash = {};
    Array.from(document.querySelectorAll("style[".concat(StyleContext_ATTR_MARK, "]"))).forEach(function (style) {
      var hash = style.getAttribute(StyleContext_ATTR_MARK);
      if (styleHash[hash]) {
        if (style[StyleContext_CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          var _style$parentNode;
          (_style$parentNode = style.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style);
        }
      } else {
        styleHash[hash] = true;
      }
    });
  }
  return new Cache(cssinjsInstanceId);
}
var StyleContext_StyleContext = /*#__PURE__*/external_React_namespaceObject.createContext({
  hashPriority: 'low',
  cache: createCache(),
  defaultCache: true
});
var StyleProvider = function StyleProvider(props) {
  var children = props.children,
    restProps = _objectWithoutProperties(props, _excluded);
  var parentContext = React.useContext(StyleContext_StyleContext);
  var context = useMemo(function () {
    var mergedContext = _objectSpread({}, parentContext);
    Object.keys(restProps).forEach(function (key) {
      var value = restProps[key];
      if (restProps[key] !== undefined) {
        mergedContext[key] = value;
      }
    });
    var cache = restProps.cache;
    mergedContext.cache = mergedContext.cache || createCache();
    mergedContext.defaultCache = !cache && parentContext.defaultCache;
    return mergedContext;
  }, [parentContext, restProps], function (prev, next) {
    return !isEqual(prev[0], next[0], true) || !isEqual(prev[1], next[1], true);
  });
  return /*#__PURE__*/React.createElement(StyleContext_StyleContext.Provider, {
    value: context
  }, children);
};
/* harmony default export */ const es_StyleContext = (StyleContext_StyleContext);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/objectSpread2.js

function objectSpread2_ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function objectSpread2_objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? objectSpread2_ownKeys(Object(t), !0).forEach(function (r) {
      defineProperty_defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : objectSpread2_ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/theme/ThemeCache.js




// ================================== Cache ==================================

function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (var i = 0; i < left.length; i++) {
    if (left[i] !== right[i]) {
      return false;
    }
  }
  return true;
}
var ThemeCache = /*#__PURE__*/function () {
  function ThemeCache() {
    classCallCheck_classCallCheck(this, ThemeCache);
    defineProperty_defineProperty(this, "cache", void 0);
    defineProperty_defineProperty(this, "keys", void 0);
    defineProperty_defineProperty(this, "cacheCallTimes", void 0);
    this.cache = new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  createClass_createClass(ThemeCache, [{
    key: "size",
    value: function size() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function internalGet(derivativeOption) {
      var _cache2, _cache3;
      var updateCallTimes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var cache = {
        map: this.cache
      };
      derivativeOption.forEach(function (derivative) {
        if (!cache) {
          cache = undefined;
        } else {
          var _cache;
          cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative);
        }
      });
      if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
        cache.value[1] = this.cacheCallTimes++;
      }
      return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
    }
  }, {
    key: "get",
    value: function get(derivativeOption) {
      var _this$internalGet;
      return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
    }
  }, {
    key: "has",
    value: function has(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }
  }, {
    key: "set",
    value: function set(derivativeOption, value) {
      var _this = this;
      // New cache
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
          var _this$keys$reduce = this.keys.reduce(function (result, key) {
              var _result = slicedToArray_slicedToArray(result, 2),
                callTimes = _result[1];
              if (_this.internalGet(key)[1] < callTimes) {
                return [key, _this.internalGet(key)[1]];
              }
              return result;
            }, [this.keys[0], this.cacheCallTimes]),
            _this$keys$reduce2 = slicedToArray_slicedToArray(_this$keys$reduce, 1),
            targetKey = _this$keys$reduce2[0];
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      var cache = this.cache;
      derivativeOption.forEach(function (derivative, index) {
        if (index === derivativeOption.length - 1) {
          cache.set(derivative, {
            value: [value, _this.cacheCallTimes++]
          });
        } else {
          var cacheValue = cache.get(derivative);
          if (!cacheValue) {
            cache.set(derivative, {
              map: new Map()
            });
          } else if (!cacheValue.map) {
            cacheValue.map = new Map();
          }
          cache = cache.get(derivative).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function deleteByPath(currentCache, derivatives) {
      var cache = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        var _cache$value;
        if (!cache.map) {
          currentCache.delete(derivatives[0]);
        } else {
          currentCache.set(derivatives[0], {
            map: cache.map
          });
        }
        return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
      }
      var result = this.deleteByPath(cache.map, derivatives.slice(1));
      if ((!cache.map || cache.map.size === 0) && !cache.value) {
        currentCache.delete(derivatives[0]);
      }
      return result;
    }
  }, {
    key: "delete",
    value: function _delete(derivativeOption) {
      // If cache exists
      if (this.has(derivativeOption)) {
        this.keys = this.keys.filter(function (item) {
          return !sameDerivativeOption(item, derivativeOption);
        });
        return this.deleteByPath(this.cache, derivativeOption);
      }
      return undefined;
    }
  }]);
  return ThemeCache;
}();
defineProperty_defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
defineProperty_defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/theme/Theme.js




var uuid = 0;

/**
 * Theme with algorithms to derive tokens from design tokens.
 * Use `createTheme` first which will help to manage the theme instance cache.
 */
var Theme_Theme = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {
  function Theme(derivatives) {
    _classCallCheck(this, Theme);
    _defineProperty(this, "derivatives", void 0);
    _defineProperty(this, "id", void 0);
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid;
    if (derivatives.length === 0) {
      warning(derivatives.length > 0, '[Ant Design CSS-in-JS] Theme should have at least one derivative function.');
    }
    uuid += 1;
  }
  _createClass(Theme, [{
    key: "getDerivativeToken",
    value: function getDerivativeToken(token) {
      return this.derivatives.reduce(function (result, derivative) {
        return derivative(token, result);
      }, undefined);
    }
  }]);
  return Theme;
}()));

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/theme/createTheme.js


var cacheThemes = new ThemeCache();

/**
 * Same as new Theme, but will always return same one if `derivative` not changed.
 */
function createTheme(derivatives) {
  var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  // Create new theme if not exist
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }

  // Get theme from cache and return
  return cacheThemes.get(derivativeArr);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/theme/index.js



;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/util/index.js









// Create a cache for memo concat

var resultCache = new WeakMap();
var RESULT_VALUE = {};
function util_memoResult(callback, deps) {
  var current = resultCache;
  for (var i = 0; i < deps.length; i += 1) {
    var dep = deps[i];
    if (!current.has(dep)) {
      current.set(dep, new WeakMap());
    }
    current = current.get(dep);
  }
  if (!current.has(RESULT_VALUE)) {
    current.set(RESULT_VALUE, callback());
  }
  return current.get(RESULT_VALUE);
}

// Create a cache here to avoid always loop generate
var flattenTokenCache = new WeakMap();

/**
 * Flatten token to string, this will auto cache the result when token not change
 */
function util_flattenToken(token) {
  var str = flattenTokenCache.get(token) || '';
  if (!str) {
    Object.keys(token).forEach(function (key) {
      var value = token[key];
      str += key;
      if (value instanceof Theme) {
        str += value.id;
      } else if (value && _typeof(value) === 'object') {
        str += util_flattenToken(value);
      } else {
        str += value;
      }
    });

    // Put in cache
    flattenTokenCache.set(token, str);
  }
  return str;
}

/**
 * Convert derivative token to key string
 */
function util_token2key(token, salt) {
  return hash("".concat(salt, "_").concat(util_flattenToken(token)));
}
var randomSelectorKey = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, '');

// Magic `content` for detect selector support
var checkContent = '_bAmBoO_';
function supportSelector(styleStr, handleElement, supportCheck) {
  if (canUseDom()) {
    var _getComputedStyle$con, _ele$parentNode;
    dynamicCSS_updateCSS(styleStr, randomSelectorKey);
    var _ele = document.createElement('div');
    _ele.style.position = 'fixed';
    _ele.style.left = '0';
    _ele.style.top = '0';
    handleElement === null || handleElement === void 0 || handleElement(_ele);
    document.body.appendChild(_ele);
    if (false) {}
    var support = supportCheck ? supportCheck(_ele) : (_getComputedStyle$con = getComputedStyle(_ele).content) === null || _getComputedStyle$con === void 0 ? void 0 : _getComputedStyle$con.includes(checkContent);
    (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 || _ele$parentNode.removeChild(_ele);
    dynamicCSS_removeCSS(randomSelectorKey);
    return support;
  }
  return false;
}
var canLayer = undefined;
function supportLayer() {
  if (canLayer === undefined) {
    canLayer = supportSelector("@layer ".concat(randomSelectorKey, " { .").concat(randomSelectorKey, " { content: \"").concat(checkContent, "\"!important; } }"), function (ele) {
      ele.className = randomSelectorKey;
    });
  }
  return canLayer;
}
var canWhere = undefined;
function supportWhere() {
  if (canWhere === undefined) {
    canWhere = supportSelector(":where(.".concat(randomSelectorKey, ") { content: \"").concat(checkContent, "\"!important; }"), function (ele) {
      ele.className = randomSelectorKey;
    });
  }
  return canWhere;
}
var canLogic = undefined;
function supportLogicProps() {
  if (canLogic === undefined) {
    canLogic = supportSelector(".".concat(randomSelectorKey, " { inset-block: 93px !important; }"), function (ele) {
      ele.className = randomSelectorKey;
    }, function (ele) {
      return getComputedStyle(ele).bottom === '93px';
    });
  }
  return canLogic;
}
var util_isClientSide = canUseDom();
function unit(num) {
  if (typeof num === 'number') {
    return "".concat(num, "px");
  }
  return num;
}
function util_toStyleStr(style, tokenKey, styleId) {
  var customizeAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var plain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  if (plain) {
    return style;
  }
  var attrs = objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, customizeAttrs), {}, defineProperty_defineProperty(defineProperty_defineProperty({}, StyleContext_ATTR_TOKEN, tokenKey), StyleContext_ATTR_MARK, styleId));
  var attrStr = Object.keys(attrs).map(function (attr) {
    var val = attrs[attr];
    return val ? "".concat(attr, "=\"").concat(val, "\"") : null;
  }).filter(function (v) {
    return v;
  }).join(' ');
  return "<style ".concat(attrStr, ">").concat(style, "</style>");
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function toConsumableArray_toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/rc-util@5.39.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/rc-util/es/hooks/useLayoutEffect.js



/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */
var useInternalLayoutEffect =  true && canUseDom() ? external_React_namespaceObject.useLayoutEffect : external_React_namespaceObject.useEffect;
var hooks_useLayoutEffect_useLayoutEffect = function useLayoutEffect(callback, deps) {
  var firstMountRef = external_React_namespaceObject.useRef(true);
  useInternalLayoutEffect(function () {
    return callback(firstMountRef.current);
  }, deps);

  // We tell react that first mount has passed
  useInternalLayoutEffect(function () {
    firstMountRef.current = false;
    return function () {
      firstMountRef.current = true;
    };
  }, []);
};
var useLayoutUpdateEffect = function useLayoutUpdateEffect(callback, deps) {
  hooks_useLayoutEffect_useLayoutEffect(function (firstMount) {
    if (!firstMount) {
      return callback();
    }
  }, deps);
};
/* harmony default export */ const hooks_useLayoutEffect = (hooks_useLayoutEffect_useLayoutEffect);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useCompatibleInsertionEffect.js

// import canUseDom from 'rc-util/lib/Dom/canUseDom';



// We need fully clone React function here
// to avoid webpack warning React 17 do not export `useId`
var fullClone = objectSpread2_objectSpread2({}, external_React_namespaceObject);
var useInsertionEffect = fullClone.useInsertionEffect;
/**
 * Polyfill `useInsertionEffect` for React < 18
 * @param renderEffect will be executed in `useMemo`, and do not have callback
 * @param effect will be executed in `useLayoutEffect`
 * @param deps
 */
var useInsertionEffectPolyfill = function useInsertionEffectPolyfill(renderEffect, effect, deps) {
  external_React_namespaceObject.useMemo(renderEffect, deps);
  hooks_useLayoutEffect(function () {
    return effect(true);
  }, deps);
};

/**
 * Compatible `useInsertionEffect`
 * will use `useInsertionEffect` if React version >= 18,
 * otherwise use `useInsertionEffectPolyfill`.
 */
var useCompatibleInsertionEffect = useInsertionEffect ? function (renderEffect, effect, deps) {
  return useInsertionEffect(function () {
    renderEffect();
    return effect();
  }, deps);
} : useInsertionEffectPolyfill;
/* harmony default export */ const hooks_useCompatibleInsertionEffect = (useCompatibleInsertionEffect);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useEffectCleanupRegister.js



var useEffectCleanupRegister_fullClone = objectSpread2_objectSpread2({}, external_React_namespaceObject);
var useEffectCleanupRegister_useInsertionEffect = useEffectCleanupRegister_fullClone.useInsertionEffect;

// DO NOT register functions in useEffect cleanup function, or functions that registered will never be called.
var useCleanupRegister = function useCleanupRegister(deps) {
  var effectCleanups = [];
  var cleanupFlag = false;
  function register(fn) {
    if (cleanupFlag) {
      if (false) {}
      return;
    }
    effectCleanups.push(fn);
  }
  external_React_namespaceObject.useEffect(function () {
    // Compatible with strict mode
    cleanupFlag = false;
    return function () {
      cleanupFlag = true;
      if (effectCleanups.length) {
        effectCleanups.forEach(function (fn) {
          return fn();
        });
      }
    };
  }, deps);
  return register;
};
var useRun = function useRun() {
  return function (fn) {
    fn();
  };
};

// Only enable register in React 18
var useEffectCleanupRegister = typeof useEffectCleanupRegister_useInsertionEffect !== 'undefined' ? useCleanupRegister : useRun;
/* harmony default export */ const hooks_useEffectCleanupRegister = (useEffectCleanupRegister);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useHMR.js
function useProdHMR() {
  return false;
}
var webpackHMR = false;
function useDevHMR() {
  return webpackHMR;
}
/* harmony default export */ const useHMR = ( true ? useProdHMR : 0);

// Webpack `module.hot.accept` do not support any deps update trigger
// We have to hack handler to force mark as HRM
if (false) { var originWebpackHotUpdate, win; }
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js








function useGlobalCache_useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove,
// Add additional effect trigger by `useInsertionEffect`
onCacheEffect) {
  var _React$useContext = external_React_namespaceObject.useContext(es_StyleContext),
    globalCache = _React$useContext.cache;
  var fullPath = [prefix].concat(toConsumableArray_toConsumableArray(keyPath));
  var fullPathStr = pathKey(fullPath);
  var register = hooks_useEffectCleanupRegister([fullPathStr]);
  var HMRUpdate = useHMR();
  var buildCache = function buildCache(updater) {
    globalCache.opUpdate(fullPathStr, function (prevCache) {
      var _ref = prevCache || [undefined, undefined],
        _ref2 = slicedToArray_slicedToArray(_ref, 2),
        _ref2$ = _ref2[0],
        times = _ref2$ === void 0 ? 0 : _ref2$,
        cache = _ref2[1];

      // HMR should always ignore cache since developer may change it
      var tmpCache = cache;
      if (false) {}
      var mergedCache = tmpCache || cacheFn();
      var data = [times, mergedCache];

      // Call updater if need additional logic
      return updater ? updater(data) : data;
    });
  };

  // Create cache
  external_React_namespaceObject.useMemo(function () {
    buildCache();
  }, /* eslint-disable react-hooks/exhaustive-deps */
  [fullPathStr]
  /* eslint-enable */);
  var cacheEntity = globalCache.opGet(fullPathStr);

  // HMR clean the cache but not trigger `useMemo` again
  // Let's fallback of this
  // ref https://github.com/ant-design/cssinjs/issues/127
  if (false) {}
  var cacheContent = cacheEntity[1];

  // Remove if no need anymore
  hooks_useCompatibleInsertionEffect(function () {
    onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
  }, function (polyfill) {
    // It's bad to call build again in effect.
    // But we have to do this since StrictMode will call effect twice
    // which will clear cache on the first time.
    buildCache(function (_ref3) {
      var _ref4 = slicedToArray_slicedToArray(_ref3, 2),
        times = _ref4[0],
        cache = _ref4[1];
      if (polyfill && times === 0) {
        onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
      }
      return [times + 1, cache];
    });
    return function () {
      globalCache.opUpdate(fullPathStr, function (prevCache) {
        var _ref5 = prevCache || [],
          _ref6 = slicedToArray_slicedToArray(_ref5, 2),
          _ref6$ = _ref6[0],
          times = _ref6$ === void 0 ? 0 : _ref6$,
          cache = _ref6[1];
        var nextCount = times - 1;
        if (nextCount === 0) {
          // Always remove styles in useEffect callback
          register(function () {
            // With polyfill, registered callback will always be called synchronously
            // But without polyfill, it will be called in effect clean up,
            // And by that time this cache is cleaned up.
            if (polyfill || !globalCache.opGet(fullPathStr)) {
              onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);
            }
          });
          return null;
        }
        return [times - 1, cache];
      });
    };
  }, [fullPathStr]);
  return cacheContent;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useCacheToken.js










var EMPTY_OVERRIDE = {};

// Generate different prefix to make user selector break in production env.
// This helps developer not to do style override directly on the hash id.
var hashPrefix = (/* unused pure expression or super */ null && ( false ? 0 : 'css'));
var tokenKeys = new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key, instanceId) {
  if (typeof document !== 'undefined') {
    var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, "=\"").concat(key, "\"]"));
    styles.forEach(function (style) {
      if (style[CSS_IN_JS_INSTANCE] === instanceId) {
        var _style$parentNode;
        (_style$parentNode = style.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style);
      }
    });
  }
}
var TOKEN_THRESHOLD = 0;

// Remove will check current keys first
function cleanTokenStyle(tokenKey, instanceId) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  var tokenKeyList = Array.from(tokenKeys.keys());
  var cleanableKeyList = tokenKeyList.filter(function (key) {
    var count = tokenKeys.get(key) || 0;
    return count <= 0;
  });

  // Should keep tokens under threshold for not to insert style too often
  if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
    cleanableKeyList.forEach(function (key) {
      removeStyleTags(key, instanceId);
      tokenKeys.delete(key);
    });
  }
}
var getComputedToken = function getComputedToken(originToken, overrideToken, theme, format) {
  var derivativeToken = theme.getDerivativeToken(originToken);

  // Merge with override
  var mergedDerivativeToken = _objectSpread(_objectSpread({}, derivativeToken), overrideToken);

  // Format if needed
  if (format) {
    mergedDerivativeToken = format(mergedDerivativeToken);
  }
  return mergedDerivativeToken;
};
var TOKEN_PREFIX = 'token';
/**
 * Cache theme derivative token as global shared one
 * @param theme Theme entity
 * @param tokens List of tokens, used for cache. Please do not dynamic generate object directly
 * @param option Additional config
 * @returns Call Theme.getDerivativeToken(tokenObject) to get token
 */
function useCacheToken(theme, tokens) {
  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _useContext = useContext(StyleContext),
    instanceId = _useContext.cache.instanceId,
    container = _useContext.container;
  var _option$salt = option.salt,
    salt = _option$salt === void 0 ? '' : _option$salt,
    _option$override = option.override,
    override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override,
    formatToken = option.formatToken,
    compute = option.getComputedToken,
    cssVar = option.cssVar;

  // Basic - We do basic cache here
  var mergedToken = memoResult(function () {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
  }, tokens);
  var tokenStr = flattenToken(mergedToken);
  var overrideTokenStr = flattenToken(override);
  var cssVarStr = cssVar ? flattenToken(cssVar) : '';
  var cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], function () {
    var _cssVar$key;
    var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken);

    // Replace token value with css variables
    var actualToken = _objectSpread({}, mergedDerivativeToken);
    var cssVarsStr = '';
    if (!!cssVar) {
      var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
        prefix: cssVar.prefix,
        ignore: cssVar.ignore,
        unitless: cssVar.unitless,
        preserve: cssVar.preserve
      });
      var _transformToken2 = _slicedToArray(_transformToken, 2);
      mergedDerivativeToken = _transformToken2[0];
      cssVarsStr = _transformToken2[1];
    }

    // Optimize for `useStyleRegister` performance
    var tokenKey = token2key(mergedDerivativeToken, salt);
    mergedDerivativeToken._tokenKey = tokenKey;
    actualToken._tokenKey = token2key(actualToken, salt);
    var themeKey = (_cssVar$key = cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
    mergedDerivativeToken._themeKey = themeKey;
    recordCleanToken(themeKey);
    var hashId = "".concat(hashPrefix, "-").concat(hash(tokenKey));
    mergedDerivativeToken._hashId = hashId; // Not used

    return [mergedDerivativeToken, hashId, actualToken, cssVarsStr, (cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) || ''];
  }, function (cache) {
    // Remove token will remove all related style
    cleanTokenStyle(cache[0]._themeKey, instanceId);
  }, function (_ref) {
    var _ref2 = _slicedToArray(_ref, 4),
      token = _ref2[0],
      cssVarsStr = _ref2[3];
    if (cssVar && cssVarsStr) {
      var style = updateCSS(cssVarsStr, hash("css-variables-".concat(token._themeKey)), {
        mark: ATTR_MARK,
        prepend: 'queue',
        attachTo: container,
        priority: -999
      });
      style[CSS_IN_JS_INSTANCE] = instanceId;

      // Used for `useCacheToken` to remove on batch when token removed
      style.setAttribute(ATTR_TOKEN, token._themeKey);
    }
  });
  return cachedToken;
}
var extract = function extract(cache, effectStyles, options) {
  var _cache = slicedToArray_slicedToArray(cache, 5),
    realToken = _cache[2],
    styleStr = _cache[3],
    cssVarKey = _cache[4];
  var _ref3 = options || {},
    plain = _ref3.plain;
  if (!styleStr) {
    return null;
  }
  var styleId = realToken._tokenKey;
  var order = -999;

  // ====================== Style ======================
  // Used for rc-util
  var sharedAttrs = {
    'data-rc-order': 'prependQueue',
    'data-rc-priority': "".concat(order)
  };
  var styleText = util_toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order, styleId, styleText];
};
;// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.24.4/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+hash@0.8.0/node_modules/@emotion/hash/dist/hash.browser.esm.js
/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

/* harmony default export */ const hash_browser_esm = (murmur2);

;// CONCATENATED MODULE: ./node_modules/.pnpm/@emotion+unitless@0.7.5/node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

/* harmony default export */ const unitless_browser_esm = (unitlessKeys);

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.1.3/node_modules/stylis/src/Enum.js
var MS = '-ms-'
var MOZ = '-moz-'
var WEBKIT = '-webkit-'

var COMMENT = 'comm'
var RULESET = 'rule'
var DECLARATION = 'decl'

var PAGE = '@page'
var MEDIA = '@media'
var IMPORT = '@import'
var CHARSET = '@charset'
var VIEWPORT = '@viewport'
var SUPPORTS = '@supports'
var DOCUMENT = '@document'
var NAMESPACE = '@namespace'
var KEYFRAMES = '@keyframes'
var FONT_FACE = '@font-face'
var COUNTER_STYLE = '@counter-style'
var FONT_FEATURE_VALUES = '@font-feature-values'

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.1.3/node_modules/stylis/src/Utility.js
/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs

/**
 * @param {number}
 * @return {string}
 */
var Utility_from = String.fromCharCode

/**
 * @param {object}
 * @return {object}
 */
var Utility_assign = Object.assign

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function Utility_hash (value, length) {
	return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function Utility_replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function Utility_append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine (array, callback) {
	return array.map(callback).join('')
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.1.3/node_modules/stylis/src/Serializer.js



/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function Serializer_serialize (children, callback) {
	var output = ''
	var length = sizeof(children)

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || ''

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case IMPORT: case DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case KEYFRAMES: return element.return = element.value + '{' + Serializer_serialize(element.children, callback) + '}'
		case RULESET: element.value = element.props.join(',')
	}

	return strlen(children = Serializer_serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.1.3/node_modules/stylis/src/Tokenizer.js


var line = 1
var column = 1
var Tokenizer_length = 0
var position = 0
var character = 0
var characters = ''

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function copy (root, props) {
	return assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function Tokenizer_char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? charat(characters, --position) : 0

	if (column--, character === 10)
		column = 1, line--

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < Tokenizer_length ? charat(characters, position++) : 0

	if (column++, character === 10)
		column = 1, line++

	return character
}

/**
 * @return {number}
 */
function peek () {
	return charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function Tokenizer_slice (begin, end) {
	return substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, Tokenizer_length = strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(Tokenizer_slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {string} value
 * @return {string[]}
 */
function tokenize (value) {
	return dealloc(tokenizer(alloc(value)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next()
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {string[]} children
 * @return {string[]}
 */
function tokenizer (children) {
	while (next())
		switch (token(character)) {
			case 0: append(identifier(position - 1), children)
				break
			case 2: append(delimit(character), children)
				break
			default: append(from(character), children)
		}

	return children
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return Tokenizer_slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character)
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type)
				break
			// \
			case 92:
				next()
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + Tokenizer_slice(index, position - 1) + '*' + Utility_from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next()

	return Tokenizer_slice(index, position)
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/stylis@4.1.3/node_modules/stylis/src/Parser.js




/**
 * @param {string} value
 * @return {object[]}
 */
function Parser_compile (value) {
	return dealloc(Parser_parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function Parser_parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0
	var offset = 0
	var length = pseudo
	var atrule = 0
	var property = 0
	var previous = 0
	var variable = 1
	var scanning = 1
	var ampersand = 1
	var character = 0
	var type = ''
	var props = rules
	var children = rulesets
	var reference = rule
	var characters = type

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && charat(characters, length - 1) == 58) {
					if (indexof(characters += Utility_replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character)
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous)
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7)
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						Utility_append(comment(commenter(next(), caret()), root, parent), declarations)
						break
					default:
						characters += '/'
				}
				break
			// {
			case 123 * variable:
				points[index++] = strlen(characters) * ampersand
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0
					// ;
					case 59 + offset:
						if (property > 0 && (strlen(characters) - length))
							Utility_append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(Utility_replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations)
						break
					// @ ;
					case 59: characters += ';'
					// { rule/at-rule
					default:
						Utility_append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets)

						if (character === 123)
							if (offset === 0)
								Parser_parse(characters, root, reference, reference, props, rulesets, length, points, children)
							else
								switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
									// d m s
									case 100: case 109: case 115:
										Parser_parse(value, reference, reference, rule && Utility_append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children)
										break
									default:
										Parser_parse(characters, reference, reference, reference, [''], children, 0, points, children)
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo
				break
			// :
			case 58:
				length = 1 + strlen(characters), property = previous
			default:
				if (variable < 1)
					if (character == 123)
						--variable
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += Utility_from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1)
						break
					// ,
					case 44:
						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next())

						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++
						break
					// -
					case 45:
						if (previous === 45 && strlen(characters) == 2)
							variable = 0
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1
	var rule = offset === 0 ? rules : ['']
	var size = sizeof(rule)

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : Utility_replace(y, /&\f/g, rule[x])))
				props[k++] = z

	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, Utility_from(Tokenizer_char()), substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/utils.js

function utils_lintWarning(message, info) {
  var path = info.path,
    parentSelectors = info.parentSelectors;
  devWarning(false, "[Ant Design CSS-in-JS] ".concat(path ? "Error in ".concat(path, ": ") : '').concat(message).concat(parentSelectors.length ? " Selector: ".concat(parentSelectors.join(' | ')) : ''));
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/contentQuotesLinter.js

var linter = function linter(key, value, info) {
  if (key === 'content') {
    // From emotion: https://github.com/emotion-js/emotion/blob/main/packages/serialize/src/index.js#L63
    var contentValuePattern = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    var contentValues = ['normal', 'none', 'initial', 'inherit', 'unset'];
    if (typeof value !== 'string' || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
      lintWarning("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(value, "\"'`."), info);
    }
  }
};
/* harmony default export */ const contentQuotesLinter = ((/* unused pure expression or super */ null && (linter)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/hashedAnimationLinter.js

var hashedAnimationLinter_linter = function linter(key, value, info) {
  if (key === 'animation') {
    if (info.hashId && value !== 'none') {
      lintWarning("You seem to be using hashed animation '".concat(value, "', in which case 'animationName' with Keyframe as value is recommended."), info);
    }
  }
};
/* harmony default export */ const hashedAnimationLinter = ((/* unused pure expression or super */ null && (hashedAnimationLinter_linter)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/legacyNotSelectorLinter.js

function isConcatSelector(selector) {
  var _selector$match;
  var notContent = ((_selector$match = selector.match(/:not\(([^)]*)\)/)) === null || _selector$match === void 0 ? void 0 : _selector$match[1]) || '';

  // split selector. e.g.
  // `h1#a.b` => ['h1', #a', '.b']
  var splitCells = notContent.split(/(\[[^[]*])|(?=[.#])/).filter(function (str) {
    return str;
  });
  return splitCells.length > 1;
}
function parsePath(info) {
  return info.parentSelectors.reduce(function (prev, cur) {
    if (!prev) {
      return cur;
    }
    return cur.includes('&') ? cur.replace(/&/g, prev) : "".concat(prev, " ").concat(cur);
  }, '');
}
var legacyNotSelectorLinter_linter = function linter(key, value, info) {
  var parentSelectorPath = parsePath(info);
  var notList = parentSelectorPath.match(/:not\([^)]*\)/g) || [];
  if (notList.length > 0 && notList.some(isConcatSelector)) {
    lintWarning("Concat ':not' selector not support in legacy browsers.", info);
  }
};
/* harmony default export */ const legacyNotSelectorLinter = ((/* unused pure expression or super */ null && (legacyNotSelectorLinter_linter)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/logicalPropertiesLinter.js

var logicalPropertiesLinter_linter = function linter(key, value, info) {
  switch (key) {
    case 'marginLeft':
    case 'marginRight':
    case 'paddingLeft':
    case 'paddingRight':
    case 'left':
    case 'right':
    case 'borderLeft':
    case 'borderLeftWidth':
    case 'borderLeftStyle':
    case 'borderLeftColor':
    case 'borderRight':
    case 'borderRightWidth':
    case 'borderRightStyle':
    case 'borderRightColor':
    case 'borderTopLeftRadius':
    case 'borderTopRightRadius':
    case 'borderBottomLeftRadius':
    case 'borderBottomRightRadius':
      lintWarning("You seem to be using non-logical property '".concat(key, "' which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
      return;
    case 'margin':
    case 'padding':
    case 'borderWidth':
    case 'borderStyle':
      // case 'borderColor':
      if (typeof value === 'string') {
        var valueArr = value.split(' ').map(function (item) {
          return item.trim();
        });
        if (valueArr.length === 4 && valueArr[1] !== valueArr[3]) {
          lintWarning("You seem to be using '".concat(key, "' property with different left ").concat(key, " and right ").concat(key, ", which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
        }
      }
      return;
    case 'clear':
    case 'textAlign':
      if (value === 'left' || value === 'right') {
        lintWarning("You seem to be using non-logical value '".concat(value, "' of ").concat(key, ", which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
      }
      return;
    case 'borderRadius':
      if (typeof value === 'string') {
        var radiusGroups = value.split('/').map(function (item) {
          return item.trim();
        });
        var invalid = radiusGroups.reduce(function (result, group) {
          if (result) {
            return result;
          }
          var radiusArr = group.split(' ').map(function (item) {
            return item.trim();
          });
          // borderRadius: '2px 4px'
          if (radiusArr.length >= 2 && radiusArr[0] !== radiusArr[1]) {
            return true;
          }
          // borderRadius: '4px 4px 2px'
          if (radiusArr.length === 3 && radiusArr[1] !== radiusArr[2]) {
            return true;
          }
          // borderRadius: '4px 4px 2px 4px'
          if (radiusArr.length === 4 && radiusArr[2] !== radiusArr[3]) {
            return true;
          }
          return result;
        }, false);
        if (invalid) {
          lintWarning("You seem to be using non-logical value '".concat(value, "' of ").concat(key, ", which is not compatible with RTL mode. Please use logical properties and values instead. For more information: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties."), info);
        }
      }
      return;
    default:
  }
};
/* harmony default export */ const logicalPropertiesLinter = ((/* unused pure expression or super */ null && (logicalPropertiesLinter_linter)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/NaNLinter.js

var NaNLinter_linter = function linter(key, value, info) {
  if (typeof value === 'string' && /NaN/g.test(value) || Number.isNaN(value)) {
    lintWarning("Unexpected 'NaN' in property '".concat(key, ": ").concat(value, "'."), info);
  }
};
/* harmony default export */ const NaNLinter = ((/* unused pure expression or super */ null && (NaNLinter_linter)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/parentSelectorLinter.js

var parentSelectorLinter_linter = function linter(key, value, info) {
  if (info.parentSelectors.some(function (selector) {
    var selectors = selector.split(',');
    return selectors.some(function (item) {
      return item.split('&').length > 2;
    });
  })) {
    lintWarning('Should not use more than one `&` in a selector.', info);
  }
};
/* harmony default export */ const parentSelectorLinter = ((/* unused pure expression or super */ null && (parentSelectorLinter_linter)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/linters/index.js






;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/util/cacheMapUtil.js



var cacheMapUtil_ATTR_CACHE_MAP = 'data-ant-cssinjs-cache-path';

/**
 * This marks style from the css file.
 * Which means not exist in `<style />` tag.
 */
var CSS_FILE_STYLE = '_FILE_STYLE__';
function cacheMapUtil_serialize(cachePathMap) {
  return Object.keys(cachePathMap).map(function (path) {
    var hash = cachePathMap[path];
    return "".concat(path, ":").concat(hash);
  }).join(';');
}
var cachePathMap;
var fromCSSFile = true;

/**
 * @private Test usage only. Can save remove if no need.
 */
function cacheMapUtil_reset(mockCache) {
  var fromFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  cachePathMap = mockCache;
  fromCSSFile = fromFile;
}
function prepare() {
  if (!cachePathMap) {
    cachePathMap = {};
    if (canUseDom()) {
      var div = document.createElement('div');
      div.className = cacheMapUtil_ATTR_CACHE_MAP;
      div.style.position = 'fixed';
      div.style.visibility = 'hidden';
      div.style.top = '-9999px';
      document.body.appendChild(div);
      var content = getComputedStyle(div).content || '';
      content = content.replace(/^"/, '').replace(/"$/, '');

      // Fill data
      content.split(';').forEach(function (item) {
        var _item$split = item.split(':'),
          _item$split2 = slicedToArray_slicedToArray(_item$split, 2),
          path = _item$split2[0],
          hash = _item$split2[1];
        cachePathMap[path] = hash;
      });

      // Remove inline record style
      var inlineMapStyle = document.querySelector("style[".concat(cacheMapUtil_ATTR_CACHE_MAP, "]"));
      if (inlineMapStyle) {
        var _inlineMapStyle$paren;
        fromCSSFile = false;
        (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
      }
      document.body.removeChild(div);
    }
  }
}
function existPath(path) {
  prepare();
  return !!cachePathMap[path];
}
function getStyleAndHash(path) {
  var hash = cachePathMap[path];
  var styleStr = null;
  if (hash && canUseDom()) {
    if (fromCSSFile) {
      styleStr = CSS_FILE_STYLE;
    } else {
      var _style = document.querySelector("style[".concat(StyleContext_ATTR_MARK, "=\"").concat(cachePathMap[path], "\"]"));
      if (_style) {
        styleStr = _style.innerHTML;
      } else {
        // Clean up since not exist anymore
        delete cachePathMap[path];
      }
    }
  }
  return [styleStr, hash];
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useStyleRegister.js









// @ts-ignore







var SKIP_CHECK = '_skip_check_';
var MULTI_VALUE = '_multi_value_';
// ============================================================================
// ==                                 Parser                                 ==
// ============================================================================
// Preprocessor style content to browser support one
function normalizeStyle(styleStr) {
  var serialized = Serializer_serialize(Parser_compile(styleStr), stringify);
  return serialized.replace(/\{%%%\:[^;];}/g, ';');
}
function isCompoundCSSProperty(value) {
  return typeof_typeof(value) === 'object' && value && (SKIP_CHECK in value || MULTI_VALUE in value);
}

// 注入 hash 值
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId) {
    return key;
  }
  var hashClassName = ".".concat(hashId);
  var hashSelector = hashPriority === 'low' ? ":where(".concat(hashClassName, ")") : hashClassName;

  // 注入 hashId
  var keys = key.split(',').map(function (k) {
    var _firstPath$match;
    var fullPath = k.trim().split(/\s+/);

    // 如果 Selector 第一个是 HTML Element，那我们就插到它的后面。反之，就插到最前面。
    var firstPath = fullPath[0] || '';
    var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || '';
    firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
    return [firstPath].concat(toConsumableArray_toConsumableArray(fullPath.slice(1))).join(' ');
  });
  return keys.join(',');
}
// Parse CSSObject to style content
var parseStyle = function parseStyle(interpolation) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      root: true,
      parentSelectors: []
    },
    root = _ref.root,
    injectHash = _ref.injectHash,
    parentSelectors = _ref.parentSelectors;
  var hashId = config.hashId,
    layer = config.layer,
    path = config.path,
    hashPriority = config.hashPriority,
    _config$transformers = config.transformers,
    transformers = _config$transformers === void 0 ? [] : _config$transformers,
    _config$linters = config.linters,
    linters = _config$linters === void 0 ? [] : _config$linters;
  var styleStr = '';
  var effectStyle = {};
  function parseKeyframes(keyframes) {
    var animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      var _parseStyle = parseStyle(keyframes.style, config, {
          root: false,
          parentSelectors: parentSelectors
        }),
        _parseStyle2 = slicedToArray_slicedToArray(_parseStyle, 1),
        _parsedStr = _parseStyle2[0];
      effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
    }
  }
  function flattenList(list) {
    var fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    list.forEach(function (item) {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  flattenStyleList.forEach(function (originStyle) {
    // Only root level can use raw string
    var style = typeof originStyle === 'string' && !root ? {} : originStyle;
    if (typeof style === 'string') {
      styleStr += "".concat(style, "\n");
    } else if (style._keyframe) {
      // Keyframe
      parseKeyframes(style);
    } else {
      var mergedStyle = transformers.reduce(function (prev, trans) {
        var _trans$visit;
        return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev)) || prev;
      }, style);

      // Normal CSSObject
      Object.keys(mergedStyle).forEach(function (key) {
        var value = mergedStyle[key];
        if (typeof_typeof(value) === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {
          var subInjectHash = false;

          // 当成嵌套对象来处理
          var mergedKey = key.trim();
          // Whether treat child as root. In most case it is false.
          var nextRoot = false;

          // 拆分多个选择器
          if ((root || injectHash) && hashId) {
            if (mergedKey.startsWith('@')) {
              // 略过媒体查询，交给子节点继续插入 hashId
              subInjectHash = true;
            } else {
              // 注入 hashId
              mergedKey = injectSelectorHash(key, hashId, hashPriority);
            }
          } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {
            // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,
            // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.
            // But it does not conform to stylis syntax,
            // and finally we will get `{color:red;}` as css, which is wrong.
            // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.
            mergedKey = '';
            nextRoot = true;
          }
          var _parseStyle3 = parseStyle(value, config, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [].concat(toConsumableArray_toConsumableArray(parentSelectors), [mergedKey])
            }),
            _parseStyle4 = slicedToArray_slicedToArray(_parseStyle3, 2),
            _parsedStr2 = _parseStyle4[0],
            childEffectStyle = _parseStyle4[1];
          effectStyle = objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, effectStyle), childEffectStyle);
          styleStr += "".concat(mergedKey).concat(_parsedStr2);
        } else {
          var _value;
          function appendStyle(cssKey, cssValue) {
            if (false) {}

            // 如果是样式则直接插入
            var styleName = cssKey.replace(/[A-Z]/g, function (match) {
              return "-".concat(match.toLowerCase());
            });

            // Auto suffix with px
            var formatValue = cssValue;
            if (!unitless_browser_esm[cssKey] && typeof formatValue === 'number' && formatValue !== 0) {
              formatValue = "".concat(formatValue, "px");
            }

            // handle animationName & Keyframe value
            if (cssKey === 'animationName' && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
              parseKeyframes(cssValue);
              formatValue = cssValue.getName(hashId);
            }
            styleStr += "".concat(styleName, ":").concat(formatValue, ";");
          }
          var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
          if (typeof_typeof(value) === 'object' && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
            actualValue.forEach(function (item) {
              appendStyle(key, item);
            });
          } else {
            appendStyle(key, actualValue);
          }
        }
      });
    }
  });
  if (!root) {
    styleStr = "{".concat(styleStr, "}");
  } else if (layer && supportLayer()) {
    var layerCells = layer.split(',');
    var layerName = layerCells[layerCells.length - 1].trim();
    styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");

    // Order of layer if needed
    if (layerCells.length > 1) {
      // zombieJ: stylis do not support layer order, so we need to handle it manually.
      styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
    }
  }
  return [styleStr, effectStyle];
};

// ============================================================================
// ==                                Register                                ==
// ============================================================================
function useStyleRegister_uniqueHash(path, styleStr) {
  return hash_browser_esm("".concat(path.join('%')).concat(styleStr));
}
function Empty() {
  return null;
}
var STYLE_PREFIX = 'style';
/**
 * Register a style to the global style sheet.
 */
function useStyleRegister(info, styleFn) {
  var token = info.token,
    path = info.path,
    hashId = info.hashId,
    layer = info.layer,
    nonce = info.nonce,
    clientOnly = info.clientOnly,
    _info$order = info.order,
    order = _info$order === void 0 ? 0 : _info$order;
  var _React$useContext = external_React_namespaceObject.useContext(es_StyleContext),
    autoClear = _React$useContext.autoClear,
    mock = _React$useContext.mock,
    defaultCache = _React$useContext.defaultCache,
    hashPriority = _React$useContext.hashPriority,
    container = _React$useContext.container,
    ssrInline = _React$useContext.ssrInline,
    transformers = _React$useContext.transformers,
    linters = _React$useContext.linters,
    cache = _React$useContext.cache;
  var tokenKey = token._tokenKey;
  var fullPath = [tokenKey].concat(toConsumableArray_toConsumableArray(path));

  // Check if need insert style
  var isMergedClientSide = util_isClientSide;
  if (false) {}
  var _useGlobalCache = useGlobalCache_useGlobalCache(STYLE_PREFIX, fullPath,
    // Create cache if needed
    function () {
      var cachePath = fullPath.join('|');

      // Get style from SSR inline style directly
      if (existPath(cachePath)) {
        var _getStyleAndHash = getStyleAndHash(cachePath),
          _getStyleAndHash2 = slicedToArray_slicedToArray(_getStyleAndHash, 2),
          inlineCacheStyleStr = _getStyleAndHash2[0],
          styleHash = _getStyleAndHash2[1];
        if (inlineCacheStyleStr) {
          return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order];
        }
      }

      // Generate style
      var styleObj = styleFn();
      var _parseStyle5 = parseStyle(styleObj, {
          hashId: hashId,
          hashPriority: hashPriority,
          layer: layer,
          path: path.join('-'),
          transformers: transformers,
          linters: linters
        }),
        _parseStyle6 = slicedToArray_slicedToArray(_parseStyle5, 2),
        parsedStyle = _parseStyle6[0],
        effectStyle = _parseStyle6[1];
      var styleStr = normalizeStyle(parsedStyle);
      var styleId = useStyleRegister_uniqueHash(fullPath, styleStr);
      return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
    },
    // Remove cache if no need
    function (_ref2, fromHMR) {
      var _ref3 = slicedToArray_slicedToArray(_ref2, 3),
        styleId = _ref3[2];
      if ((fromHMR || autoClear) && util_isClientSide) {
        dynamicCSS_removeCSS(styleId, {
          mark: StyleContext_ATTR_MARK
        });
      }
    },
    // Effect: Inject style here
    function (_ref4) {
      var _ref5 = slicedToArray_slicedToArray(_ref4, 4),
        styleStr = _ref5[0],
        _ = _ref5[1],
        styleId = _ref5[2],
        effectStyle = _ref5[3];
      if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
        var mergedCSSConfig = {
          mark: StyleContext_ATTR_MARK,
          prepend: 'queue',
          attachTo: container,
          priority: order
        };
        var nonceStr = typeof nonce === 'function' ? nonce() : nonce;
        if (nonceStr) {
          mergedCSSConfig.csp = {
            nonce: nonceStr
          };
        }
        var style = dynamicCSS_updateCSS(styleStr, styleId, mergedCSSConfig);
        style[StyleContext_CSS_IN_JS_INSTANCE] = cache.instanceId;

        // Used for `useCacheToken` to remove on batch when token removed
        style.setAttribute(StyleContext_ATTR_TOKEN, tokenKey);

        // Debug usage. Dev only
        if (false) {}

        // Inject client side effect style
        Object.keys(effectStyle).forEach(function (effectKey) {
          dynamicCSS_updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
        });
      }
    }),
    _useGlobalCache2 = slicedToArray_slicedToArray(_useGlobalCache, 3),
    cachedStyleStr = _useGlobalCache2[0],
    cachedTokenKey = _useGlobalCache2[1],
    cachedStyleId = _useGlobalCache2[2];
  return function (node) {
    var styleNode;
    if (!ssrInline || isMergedClientSide || !defaultCache) {
      styleNode = /*#__PURE__*/external_React_namespaceObject.createElement(Empty, null);
    } else {
      styleNode = /*#__PURE__*/external_React_namespaceObject.createElement("style", _extends({}, defineProperty_defineProperty(defineProperty_defineProperty({}, StyleContext_ATTR_TOKEN, cachedTokenKey), StyleContext_ATTR_MARK, cachedStyleId), {
        dangerouslySetInnerHTML: {
          __html: cachedStyleStr
        }
      }));
    }
    return /*#__PURE__*/external_React_namespaceObject.createElement(external_React_namespaceObject.Fragment, null, styleNode, node);
  };
}
var useStyleRegister_extract = function extract(cache, effectStyles, options) {
  var _cache = slicedToArray_slicedToArray(cache, 6),
    styleStr = _cache[0],
    tokenKey = _cache[1],
    styleId = _cache[2],
    effectStyle = _cache[3],
    clientOnly = _cache[4],
    order = _cache[5];
  var _ref7 = options || {},
    plain = _ref7.plain;

  // Skip client only style
  if (clientOnly) {
    return null;
  }
  var keyStyleText = styleStr;

  // ====================== Style ======================
  // Used for rc-util
  var sharedAttrs = {
    'data-rc-order': 'prependQueue',
    'data-rc-priority': "".concat(order)
  };
  keyStyleText = util_toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);

  // =============== Create effect style ===============
  if (effectStyle) {
    Object.keys(effectStyle).forEach(function (effectKey) {
      // Effect style can be reused
      if (!effectStyles[effectKey]) {
        effectStyles[effectKey] = true;
        var effectStyleStr = normalizeStyle(effectStyle[effectKey]);
        keyStyleText += util_toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
      }
    });
  }
  return [order, styleId, keyStyleText];
};
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/hooks/useCSSVarRegister.js









var CSS_VAR_PREFIX = 'cssVar';
var useCSSVarRegister = function useCSSVarRegister(config, fn) {
  var key = config.key,
    prefix = config.prefix,
    unitless = config.unitless,
    ignore = config.ignore,
    token = config.token,
    _config$scope = config.scope,
    scope = _config$scope === void 0 ? '' : _config$scope;
  var _useContext = useContext(StyleContext),
    instanceId = _useContext.cache.instanceId,
    container = _useContext.container;
  var tokenKey = token._tokenKey;
  var stylePath = [].concat(_toConsumableArray(config.path), [key, scope, tokenKey]);
  var cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, function () {
    var originToken = fn();
    var _transformToken = transformToken(originToken, key, {
        prefix: prefix,
        unitless: unitless,
        ignore: ignore,
        scope: scope
      }),
      _transformToken2 = _slicedToArray(_transformToken, 2),
      mergedToken = _transformToken2[0],
      cssVarsStr = _transformToken2[1];
    var styleId = uniqueHash(stylePath, cssVarsStr);
    return [mergedToken, cssVarsStr, styleId, key];
  }, function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
      styleId = _ref2[2];
    if (isClientSide) {
      removeCSS(styleId, {
        mark: ATTR_MARK
      });
    }
  }, function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 3),
      cssVarsStr = _ref4[1],
      styleId = _ref4[2];
    if (!cssVarsStr) {
      return;
    }
    var style = updateCSS(cssVarsStr, styleId, {
      mark: ATTR_MARK,
      prepend: 'queue',
      attachTo: container,
      priority: -999
    });
    style[CSS_IN_JS_INSTANCE] = instanceId;

    // Used for `useCacheToken` to remove on batch when token removed
    style.setAttribute(ATTR_TOKEN, key);
  });
  return cache;
};
var useCSSVarRegister_extract = function extract(cache, effectStyles, options) {
  var _cache = slicedToArray_slicedToArray(cache, 4),
    styleStr = _cache[1],
    styleId = _cache[2],
    cssVarKey = _cache[3];
  var _ref5 = options || {},
    plain = _ref5.plain;
  if (!styleStr) {
    return null;
  }
  var order = -999;

  // ====================== Style ======================
  // Used for rc-util
  var sharedAttrs = {
    'data-rc-order': 'prependQueue',
    'data-rc-priority': "".concat(order)
  };
  var styleText = util_toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
  return [order, styleId, styleText];
};
/* harmony default export */ const hooks_useCSSVarRegister = ((/* unused pure expression or super */ null && (useCSSVarRegister)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/extractStyle.js







var ExtractStyleFns = defineProperty_defineProperty(defineProperty_defineProperty(defineProperty_defineProperty({}, STYLE_PREFIX, useStyleRegister_extract), TOKEN_PREFIX, extract), CSS_VAR_PREFIX, useCSSVarRegister_extract);
function isNotNull(value) {
  return value !== null;
}
function extractStyle(cache, options) {
  var _ref = typeof options === 'boolean' ? {
      plain: options
    } : options || {},
    _ref$plain = _ref.plain,
    plain = _ref$plain === void 0 ? false : _ref$plain,
    _ref$types = _ref.types,
    types = _ref$types === void 0 ? ['style', 'token', 'cssVar'] : _ref$types;
  var matchPrefixRegexp = new RegExp("^(".concat((typeof types === 'string' ? [types] : types).join('|'), ")%"));

  // prefix with `style` is used for `useStyleRegister` to cache style context
  var styleKeys = Array.from(cache.cache.keys()).filter(function (key) {
    return matchPrefixRegexp.test(key);
  });

  // Common effect styles like animation
  var effectStyles = {};

  // Mapping of cachePath to style hash
  var cachePathMap = {};
  var styleText = '';
  styleKeys.map(function (key) {
    var cachePath = key.replace(matchPrefixRegexp, '').replace(/%/g, '|');
    var _key$split = key.split('%'),
      _key$split2 = _slicedToArray(_key$split, 1),
      prefix = _key$split2[0];
    var extractFn = ExtractStyleFns[prefix];
    var extractedStyle = extractFn(cache.cache.get(key)[1], effectStyles, {
      plain: plain
    });
    if (!extractedStyle) {
      return null;
    }
    var _extractedStyle = _slicedToArray(extractedStyle, 3),
      order = _extractedStyle[0],
      styleId = _extractedStyle[1],
      styleStr = _extractedStyle[2];
    if (key.startsWith('style')) {
      cachePathMap[cachePath] = styleId;
    }
    return [order, styleStr];
  }).filter(isNotNull).sort(function (_ref2, _ref3) {
    var _ref4 = _slicedToArray(_ref2, 1),
      o1 = _ref4[0];
    var _ref5 = _slicedToArray(_ref3, 1),
      o2 = _ref5[0];
    return o1 - o2;
  }).forEach(function (_ref6) {
    var _ref7 = _slicedToArray(_ref6, 2),
      style = _ref7[1];
    styleText += style;
  });

  // ==================== Fill Cache Path ====================
  styleText += toStyleStr(".".concat(ATTR_CACHE_MAP, "{content:\"").concat(serializeCacheMap(cachePathMap), "\";}"), undefined, undefined, _defineProperty({}, ATTR_CACHE_MAP, ATTR_CACHE_MAP), plain);
  return styleText;
}
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/Keyframes.js



var Keyframe = /*#__PURE__*/function () {
  function Keyframe(name, style) {
    classCallCheck_classCallCheck(this, Keyframe);
    defineProperty_defineProperty(this, "name", void 0);
    defineProperty_defineProperty(this, "style", void 0);
    defineProperty_defineProperty(this, "_keyframe", true);
    this.name = name;
    this.style = style;
  }
  createClass_createClass(Keyframe, [{
    key: "getName",
    value: function getName() {
      var hashId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
    }
  }]);
  return Keyframe;
}();
/* harmony default export */ const Keyframes = (Keyframe);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/transformers/legacyLogicalProperties.js

function splitValues(value) {
  if (typeof value === 'number') {
    return [[value], false];
  }
  var rawStyle = String(value).trim();
  var importantCells = rawStyle.match(/(.*)(!important)/);
  var splitStyle = (importantCells ? importantCells[1] : rawStyle).trim().split(/\s+/);

  // Combine styles split in brackets, like `calc(1px + 2px)`
  var temp = [];
  var brackets = 0;
  return [splitStyle.reduce(function (list, item) {
    if (item.includes('(') || item.includes(')')) {
      var left = item.split('(').length - 1;
      var right = item.split(')').length - 1;
      brackets += left - right;
    }
    if (brackets >= 0) temp.push(item);
    if (brackets === 0) {
      list.push(temp.join(' '));
      temp = [];
    }
    return list;
  }, []), !!importantCells];
}
function noSplit(list) {
  list.notSplit = true;
  return list;
}
var keyMap = {
  // Inset
  inset: ['top', 'right', 'bottom', 'left'],
  insetBlock: ['top', 'bottom'],
  insetBlockStart: ['top'],
  insetBlockEnd: ['bottom'],
  insetInline: ['left', 'right'],
  insetInlineStart: ['left'],
  insetInlineEnd: ['right'],
  // Margin
  marginBlock: ['marginTop', 'marginBottom'],
  marginBlockStart: ['marginTop'],
  marginBlockEnd: ['marginBottom'],
  marginInline: ['marginLeft', 'marginRight'],
  marginInlineStart: ['marginLeft'],
  marginInlineEnd: ['marginRight'],
  // Padding
  paddingBlock: ['paddingTop', 'paddingBottom'],
  paddingBlockStart: ['paddingTop'],
  paddingBlockEnd: ['paddingBottom'],
  paddingInline: ['paddingLeft', 'paddingRight'],
  paddingInlineStart: ['paddingLeft'],
  paddingInlineEnd: ['paddingRight'],
  // Border
  borderBlock: noSplit(['borderTop', 'borderBottom']),
  borderBlockStart: noSplit(['borderTop']),
  borderBlockEnd: noSplit(['borderBottom']),
  borderInline: noSplit(['borderLeft', 'borderRight']),
  borderInlineStart: noSplit(['borderLeft']),
  borderInlineEnd: noSplit(['borderRight']),
  // Border width
  borderBlockWidth: ['borderTopWidth', 'borderBottomWidth'],
  borderBlockStartWidth: ['borderTopWidth'],
  borderBlockEndWidth: ['borderBottomWidth'],
  borderInlineWidth: ['borderLeftWidth', 'borderRightWidth'],
  borderInlineStartWidth: ['borderLeftWidth'],
  borderInlineEndWidth: ['borderRightWidth'],
  // Border style
  borderBlockStyle: ['borderTopStyle', 'borderBottomStyle'],
  borderBlockStartStyle: ['borderTopStyle'],
  borderBlockEndStyle: ['borderBottomStyle'],
  borderInlineStyle: ['borderLeftStyle', 'borderRightStyle'],
  borderInlineStartStyle: ['borderLeftStyle'],
  borderInlineEndStyle: ['borderRightStyle'],
  // Border color
  borderBlockColor: ['borderTopColor', 'borderBottomColor'],
  borderBlockStartColor: ['borderTopColor'],
  borderBlockEndColor: ['borderBottomColor'],
  borderInlineColor: ['borderLeftColor', 'borderRightColor'],
  borderInlineStartColor: ['borderLeftColor'],
  borderInlineEndColor: ['borderRightColor'],
  // Border radius
  borderStartStartRadius: ['borderTopLeftRadius'],
  borderStartEndRadius: ['borderTopRightRadius'],
  borderEndStartRadius: ['borderBottomLeftRadius'],
  borderEndEndRadius: ['borderBottomRightRadius']
};
function wrapImportantAndSkipCheck(value, important) {
  var parsedValue = value;
  if (important) {
    parsedValue = "".concat(parsedValue, " !important");
  }
  return {
    _skip_check_: true,
    value: parsedValue
  };
}

/**
 * Convert css logical properties to legacy properties.
 * Such as: `margin-block-start` to `margin-top`.
 * Transform list:
 * - inset
 * - margin
 * - padding
 * - border
 */
var transform = {
  visit: function visit(cssObj) {
    var clone = {};
    Object.keys(cssObj).forEach(function (key) {
      var value = cssObj[key];
      var matchValue = keyMap[key];
      if (matchValue && (typeof value === 'number' || typeof value === 'string')) {
        var _splitValues = splitValues(value),
          _splitValues2 = slicedToArray_slicedToArray(_splitValues, 2),
          _values = _splitValues2[0],
          _important = _splitValues2[1];
        if (matchValue.length && matchValue.notSplit) {
          // not split means always give same value like border
          matchValue.forEach(function (matchKey) {
            clone[matchKey] = wrapImportantAndSkipCheck(value, _important);
          });
        } else if (matchValue.length === 1) {
          // Handle like `marginBlockStart` => `marginTop`
          clone[matchValue[0]] = wrapImportantAndSkipCheck(_values[0], _important);
        } else if (matchValue.length === 2) {
          // Handle like `marginBlock` => `marginTop` & `marginBottom`
          matchValue.forEach(function (matchKey, index) {
            var _values$index;
            clone[matchKey] = wrapImportantAndSkipCheck((_values$index = _values[index]) !== null && _values$index !== void 0 ? _values$index : _values[0], _important);
          });
        } else if (matchValue.length === 4) {
          // Handle like `inset` => `top` & `right` & `bottom` & `left`
          matchValue.forEach(function (matchKey, index) {
            var _ref, _values$index2;
            clone[matchKey] = wrapImportantAndSkipCheck((_ref = (_values$index2 = _values[index]) !== null && _values$index2 !== void 0 ? _values$index2 : _values[index - 2]) !== null && _ref !== void 0 ? _ref : _values[0], _important);
          });
        } else {
          clone[key] = value;
        }
      } else {
        clone[key] = value;
      }
    });
    return clone;
  }
};
/* harmony default export */ const legacyLogicalProperties = ((/* unused pure expression or super */ null && (transform)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/transformers/px2rem.js


/**
 * respect https://github.com/cuth/postcss-pxtorem
 */
// @ts-ignore

var pxRegex = /url\([^)]+\)|var\([^)]+\)|(\d*\.?\d+)px/g;
function toFixed(number, precision) {
  var multiplier = Math.pow(10, precision + 1),
    wholeNumber = Math.floor(number * multiplier);
  return Math.round(wholeNumber / 10) * 10 / multiplier;
}
var px2rem_transform = function transform() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _options$rootValue = options.rootValue,
    rootValue = _options$rootValue === void 0 ? 16 : _options$rootValue,
    _options$precision = options.precision,
    precision = _options$precision === void 0 ? 5 : _options$precision,
    _options$mediaQuery = options.mediaQuery,
    mediaQuery = _options$mediaQuery === void 0 ? false : _options$mediaQuery;
  var pxReplace = function pxReplace(m, $1) {
    if (!$1) return m;
    var pixels = parseFloat($1);
    // covenant: pixels <= 1, not transform to rem @zombieJ
    if (pixels <= 1) return m;
    var fixedVal = toFixed(pixels / rootValue, precision);
    return "".concat(fixedVal, "rem");
  };
  var visit = function visit(cssObj) {
    var clone = _objectSpread({}, cssObj);
    Object.entries(cssObj).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];
      if (typeof value === 'string' && value.includes('px')) {
        var newValue = value.replace(pxRegex, pxReplace);
        clone[key] = newValue;
      }

      // no unit
      if (!unitless[key] && typeof value === 'number' && value !== 0) {
        clone[key] = "".concat(value, "px").replace(pxRegex, pxReplace);
      }

      // Media queries
      var mergedKey = key.trim();
      if (mergedKey.startsWith('@') && mergedKey.includes('px') && mediaQuery) {
        var newKey = key.replace(pxRegex, pxReplace);
        clone[newKey] = clone[key];
        delete clone[key];
      }
    });
    return clone;
  };
  return {
    visit: visit
  };
};
/* harmony default export */ const px2rem = ((/* unused pure expression or super */ null && (px2rem_transform)));
;// CONCATENATED MODULE: ./node_modules/.pnpm/@ant-design+cssinjs@1.18.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/cssinjs/es/index.js













var _experimental = {
  supportModernCSS: function supportModernCSS() {
    return supportWhere() && supportLogicProps();
  }
};
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/hooks/useToken.js

var useToken = external_antd_namespaceObject.theme.useToken;

//# sourceMappingURL=useToken.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/hooks/useConfig.js


var ConfigContext = external_antd_namespaceObject.ConfigProvider.ConfigContext;
var useConfig = function () { return (0,external_React_namespaceObject.useContext)(ConfigContext); };
//# sourceMappingURL=useConfig.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/style.js
var style_assign = (undefined && undefined.__assign) || function () {
    style_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return style_assign.apply(this, arguments);
};



var genCommonStyle = function (token, componentPrefixCls) {
    var _a, _b;
    var fontFamily = token.fontFamily, fontSize = token.fontSize;
    var rootPrefixSelector = "[class^=\"".concat(componentPrefixCls, "\"], [class*=\" ").concat(componentPrefixCls, "\"]");
    return _a = {},
        _a[rootPrefixSelector] = (_b = {
                fontFamily: fontFamily,
                fontSize: fontSize,
                boxSizing: 'border-box',
                '&::before, &::after': {
                    boxSizing: 'border-box',
                }
            },
            _b[rootPrefixSelector] = {
                boxSizing: 'border-box',
                '&::before, &::after': {
                    boxSizing: 'border-box',
                },
            },
            _b),
        _a;
};
var genStyleHook = function (component, styleFn) {
    return function (prefixCls) {
        var _a = useToken(), theme = _a.theme, token = _a.token, hashId = _a.hashId;
        var _b = useConfig(), getPrefixCls = _b.getPrefixCls, iconPrefixCls = _b.iconPrefixCls;
        var rootPrefixCls = getPrefixCls();
        return [
            useStyleRegister({
                theme: theme,
                token: token,
                hashId: hashId,
                path: ['formily-antd', component, prefixCls, iconPrefixCls],
            }, function () {
                var componentCls = ".".concat(prefixCls);
                var mergedToken = merge(token, style_assign(style_assign({}, token['Form']), { // Merge the antd form token
                    componentCls: componentCls, prefixCls: prefixCls, iconCls: ".".concat(iconPrefixCls), antCls: ".".concat(rootPrefixCls) }));
                var styleInterpolation = styleFn(mergedToken, {
                    hashId: hashId,
                    prefixCls: prefixCls,
                    rootPrefixCls: rootPrefixCls,
                    iconPrefixCls: iconPrefixCls,
                });
                return [genCommonStyle(token, prefixCls), styleInterpolation];
            }),
            hashId,
        ];
    };
};
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-base/style.js

/* harmony default export */ const style = (genStyleHook('array-base', function (token) {
    var _a;
    var componentCls = token.componentCls, colorText = token.colorText, fontSizeLG = token.fontSizeLG, colorPrimaryText = token.colorPrimaryText, colorTextDisabled = token.colorTextDisabled;
    return _a = {},
        _a[componentCls] = {
            '&-remove, &-copy': {
                transition: 'all 0.25s ease-in-out',
                color: colorText,
                fontSize: fontSizeLG,
                ':hover': {
                    color: colorPrimaryText,
                },
                '&-disabled': {
                    color: colorTextDisabled,
                    cursor: 'not-allowed !important',
                    '&:hover': {
                        color: colorTextDisabled,
                    },
                },
            },
            '&-sort-handle': {
                cursor: 'move',
                color: '#888 !important',
            },
            '&-addition': {
                transition: 'all 0.25s ease-in-out',
            },
            '&-move-down, &-move-up': {
                transition: 'all 0.25s ease-in-out',
                color: colorText,
                fontSize: fontSizeLG,
                marginInlineStart: 6,
                ':hover': {
                    color: colorPrimaryText,
                },
                '&-disabled': {
                    color: colorTextDisabled,
                    cursor: 'not-allowed !important',
                    '&:hover': {
                        color: colorTextDisabled,
                    },
                },
            },
        },
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-base/index.js
var array_base_assign = (undefined && undefined.__assign) || function () {
    array_base_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return array_base_assign.apply(this, arguments);
};
var array_base_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var array_base_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};








var ArrayBaseContext = (0,external_React_namespaceObject.createContext)(null);
var ItemContext = (0,external_React_namespaceObject.createContext)(null);
var takeRecord = function (val, index) {
    return typeof val === 'function' ? val(index) : val;
};
var useArray = function () {
    return (0,external_React_namespaceObject.useContext)(ArrayBaseContext);
};
var useIndex = function (index) {
    var ctx = (0,external_React_namespaceObject.useContext)(ItemContext);
    return (ctx ? ctx.index : index) || 0;
};
var useRecord = function (record) {
    var ctx = (0,external_React_namespaceObject.useContext)(ItemContext);
    return takeRecord(ctx ? ctx.record : record, ctx === null || ctx === void 0 ? void 0 : ctx.index);
};
var getSchemaDefaultValue = function (schema) {
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'array')
        return [];
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'object')
        return {};
    if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'void') {
        for (var key in schema.properties) {
            var value = getSchemaDefaultValue(schema.properties[key]);
            if (isEmpty_isValid(value))
                return value;
        }
    }
};
var getDefaultValue = function (defaultValue, schema) {
    if (isEmpty_isValid(defaultValue))
        return clone(defaultValue);
    if (Array.isArray(schema === null || schema === void 0 ? void 0 : schema.items))
        return getSchemaDefaultValue(schema === null || schema === void 0 ? void 0 : schema.items[0]);
    return getSchemaDefaultValue(schema === null || schema === void 0 ? void 0 : schema.items);
};
var InternalArrayBase = function (props) {
    var field = useField();
    var schema = useFieldSchema();
    return (external_React_default().createElement(RecordsScope, { getRecords: function () { return field.value; } },
        external_React_default().createElement(ArrayBaseContext.Provider, { value: { field: field, schema: schema, props: props } }, props.children)));
};
var Item = function (_a) {
    var children = _a.children, props = array_base_rest(_a, ["children"]);
    return (external_React_default().createElement(ItemContext.Provider, { value: props },
        external_React_default().createElement(RecordScope, { getIndex: function () { return props.index; }, getRecord: function () { return takeRecord(props.record, props.index); } }, children)));
};
var InternalSortHandle = SortableHandle(function (props) {
    var prefixCls = usePrefixCls('formily-array-base');
    var _a = array_base_read(style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement(external_icons_namespaceObject.MenuOutlined, array_base_assign({}, props, { className: classnames_default()("".concat(prefixCls, "-sort-handle"), hashId, props.className), style: array_base_assign({}, props.style) })));
});
var SortHandle = function (props) {
    var _a;
    var array = useArray();
    if (!array)
        return null;
    if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
        return null;
    return external_React_default().createElement(InternalSortHandle, array_base_assign({}, props));
};
var Index = function (props) {
    var index = useIndex();
    var prefixCls = usePrefixCls('formily-array-base');
    var _a = array_base_read(style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement("span", array_base_assign({}, props, { className: classnames_default()("".concat(prefixCls, "-index"), hashId) }),
        "#",
        (index || 0) + 1,
        "."));
};
var Addition = function (props) {
    var _a, _b;
    var self = useField();
    var array = useArray();
    var prefixCls = usePrefixCls('formily-array-base');
    var _c = array_base_read(style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    if (!array)
        return null;
    if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable' &&
        ((_b = array.field) === null || _b === void 0 ? void 0 : _b.pattern) !== 'disabled')
        return null;
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Button, array_base_assign({ type: "dashed", block: true }, props, { disabled: self === null || self === void 0 ? void 0 : self.disabled, className: classnames_default()("".concat(prefixCls, "-addition"), hashId, props.className), onClick: function (e) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            if ((_a = array.props) === null || _a === void 0 ? void 0 : _a.disabled)
                return;
            var defaultValue = getDefaultValue(props.defaultValue, array.schema);
            if (props.method === 'unshift') {
                (_c = (_b = array.field) === null || _b === void 0 ? void 0 : _b.unshift) === null || _c === void 0 ? void 0 : _c.call(_b, defaultValue);
                (_e = (_d = array.props) === null || _d === void 0 ? void 0 : _d.onAdd) === null || _e === void 0 ? void 0 : _e.call(_d, 0);
            }
            else {
                (_g = (_f = array.field) === null || _f === void 0 ? void 0 : _f.push) === null || _g === void 0 ? void 0 : _g.call(_f, defaultValue);
                (_j = (_h = array.props) === null || _h === void 0 ? void 0 : _h.onAdd) === null || _j === void 0 ? void 0 : _j.call(_h, ((_l = (_k = array === null || array === void 0 ? void 0 : array.field) === null || _k === void 0 ? void 0 : _k.value) === null || _l === void 0 ? void 0 : _l.length) - 1);
            }
            if (props.onClick) {
                props.onClick(e);
            }
        }, icon: isUndef(props.icon) ? external_React_default().createElement(external_icons_namespaceObject.PlusOutlined, null) : props.icon }), props.title || self.title));
};
var Copy = (0,external_React_namespaceObject.forwardRef)(function (props, ref) {
    var _a;
    var self = useField();
    var array = useArray();
    var index = useIndex(props.index) || 0;
    var prefixCls = usePrefixCls('formily-array-base');
    var _b = array_base_read(style(prefixCls), 2), wrapSSR = _b[0], hashId = _b[1];
    if (!array)
        return null;
    if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
        return null;
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Button, array_base_assign({ type: "ghost" }, props, { style: array_base_assign({ padding: '0 0 0 6px', width: 'auto', height: 'auto' }, props.style), disabled: self === null || self === void 0 ? void 0 : self.disabled, className: classnames_default()("".concat(prefixCls, "-copy"), hashId, (self === null || self === void 0 ? void 0 : self.disabled) ? "".concat(prefixCls, "-copy-disabled") : '', props.className), ref: ref, onClick: function (e) {
            var _a, _b, _c, _d, _e, _f;
            if (self === null || self === void 0 ? void 0 : self.disabled)
                return;
            e.stopPropagation();
            if ((_a = array.props) === null || _a === void 0 ? void 0 : _a.disabled)
                return;
            if (props.onClick) {
                props.onClick(e);
                if (e.defaultPrevented)
                    return;
            }
            var value = clone((_b = array === null || array === void 0 ? void 0 : array.field) === null || _b === void 0 ? void 0 : _b.value[index]);
            var distIndex = index + 1;
            (_d = (_c = array.field) === null || _c === void 0 ? void 0 : _c.insert) === null || _d === void 0 ? void 0 : _d.call(_c, distIndex, value);
            (_f = (_e = array.props) === null || _e === void 0 ? void 0 : _e.onCopy) === null || _f === void 0 ? void 0 : _f.call(_e, distIndex);
        }, icon: isUndef(props.icon) ? external_React_default().createElement(external_icons_namespaceObject.CopyOutlined, null) : props.icon }), props.title || self.title));
});
var Remove = (0,external_React_namespaceObject.forwardRef)(function (props, ref) {
    var _a;
    var index = useIndex(props.index);
    var self = useField();
    var array = useArray();
    var prefixCls = usePrefixCls('formily-array-base');
    var _b = array_base_read(style(prefixCls), 2), wrapSSR = _b[0], hashId = _b[1];
    if (!array)
        return null;
    if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
        return null;
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Button, array_base_assign({ type: "ghost" }, props, { style: array_base_assign({ padding: '0 0 0 6px', width: 'auto', height: 'auto' }, props.style), disabled: self === null || self === void 0 ? void 0 : self.disabled, className: classnames_default()("".concat(prefixCls, "-remove"), hashId, (self === null || self === void 0 ? void 0 : self.disabled) ? "".concat(prefixCls, "-remove-disabled") : '', props.className), ref: ref, onClick: function (e) {
            var _a, _b, _c, _d;
            if (self === null || self === void 0 ? void 0 : self.disabled)
                return;
            e.stopPropagation();
            if (props.onClick) {
                props.onClick(e);
                if (e.defaultPrevented)
                    return;
            }
            (_b = (_a = array.field) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a, index);
            (_d = (_c = array.props) === null || _c === void 0 ? void 0 : _c.onRemove) === null || _d === void 0 ? void 0 : _d.call(_c, index);
        }, icon: isUndef(props.icon) ? external_React_default().createElement(external_icons_namespaceObject.DeleteOutlined, null) : props.icon }), props.title || self.title));
});
var MoveDown = (0,external_React_namespaceObject.forwardRef)(function (props, ref) {
    var _a;
    var index = useIndex(props.index);
    var self = useField();
    var array = useArray();
    var prefixCls = usePrefixCls('formily-array-base');
    if (!array)
        return null;
    if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
        return null;
    return (external_React_default().createElement(external_antd_namespaceObject.Button, array_base_assign({ type: "ghost" }, props, { style: array_base_assign({ padding: '0 0 0 6px', width: 'auto', height: 'auto' }, props.style), disabled: self === null || self === void 0 ? void 0 : self.disabled, className: classnames_default()("".concat(prefixCls, "-move-down"), (self === null || self === void 0 ? void 0 : self.disabled) ? "".concat(prefixCls, "-move-down-disabled") : '', props.className), ref: ref, onClick: function (e) {
            var _a, _b, _c, _d;
            if (self === null || self === void 0 ? void 0 : self.disabled)
                return;
            e.stopPropagation();
            if (props.onClick) {
                props.onClick(e);
                if (e.defaultPrevented)
                    return;
            }
            (_b = (_a = array.field) === null || _a === void 0 ? void 0 : _a.moveDown) === null || _b === void 0 ? void 0 : _b.call(_a, index);
            (_d = (_c = array.props) === null || _c === void 0 ? void 0 : _c.onMoveDown) === null || _d === void 0 ? void 0 : _d.call(_c, index);
        }, icon: isUndef(props.icon) ? external_React_default().createElement(external_icons_namespaceObject.DownOutlined, null) : props.icon }), props.title || self.title));
});
var MoveUp = (0,external_React_namespaceObject.forwardRef)(function (props, ref) {
    var _a;
    var index = useIndex(props.index);
    var self = useField();
    var array = useArray();
    var prefixCls = usePrefixCls('formily-array-base');
    if (!array)
        return null;
    if (((_a = array.field) === null || _a === void 0 ? void 0 : _a.pattern) !== 'editable')
        return null;
    return (external_React_default().createElement(external_antd_namespaceObject.Button, array_base_assign({ type: "ghost" }, props, { style: array_base_assign({ padding: '0 0 0 6px', width: 'auto', height: 'auto' }, props.style), disabled: self === null || self === void 0 ? void 0 : self.disabled, className: classnames_default()("".concat(prefixCls, "-move-up"), (self === null || self === void 0 ? void 0 : self.disabled) ? "".concat(prefixCls, "-move-up-disabled") : '', props.className), ref: ref, onClick: function (e) {
            var _a, _b, _c;
            if (self === null || self === void 0 ? void 0 : self.disabled)
                return;
            e.stopPropagation();
            if (props.onClick) {
                props.onClick(e);
                if (e.defaultPrevented)
                    return;
            }
            (_a = array === null || array === void 0 ? void 0 : array.field) === null || _a === void 0 ? void 0 : _a.moveUp(index);
            (_c = (_b = array === null || array === void 0 ? void 0 : array.props) === null || _b === void 0 ? void 0 : _b.onMoveUp) === null || _c === void 0 ? void 0 : _c.call(_b, index);
        }, icon: isUndef(props.icon) ? external_React_default().createElement(external_icons_namespaceObject.UpOutlined, null) : props.icon }), props.title || self.title));
});
function mixin(target) {
    return Object.assign(target, {
        Index: Index,
        SortHandle: SortHandle,
        Addition: Addition,
        Copy: Copy,
        Remove: Remove,
        MoveDown: MoveDown,
        MoveUp: MoveUp,
        useArray: useArray,
        useIndex: useIndex,
        useRecord: useRecord,
    });
}
var ArrayBase = Object.assign(InternalArrayBase, {
    Item: Item,
    Index: Index,
    SortHandle: SortHandle,
    Addition: Addition,
    Copy: Copy,
    Remove: Remove,
    MoveDown: MoveDown,
    MoveUp: MoveUp,
    useArray: useArray,
    useIndex: useIndex,
    useRecord: useRecord,
    mixin: mixin,
});
/* harmony default export */ const array_base = (ArrayBase);
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-cards/style.js

/* harmony default export */ const array_cards_style = (genStyleHook('array-cards', function (token) {
    var _a, _b;
    var componentCls = token.componentCls, antCls = token.antCls;
    var arrayBase = "".concat(antCls, "-formily-array-base");
    return _a = {},
        _a[componentCls] = (_b = {
                '&-item': {
                    marginBottom: '10px !important',
                }
            },
            _b["".concat(arrayBase, "-copy")] = {
                marginInlineStart: 6,
            },
            _b),
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-cards/index.js
var array_cards_assign = (undefined && undefined.__assign) || function () {
    array_cards_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return array_cards_assign.apply(this, arguments);
};
var array_cards_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};







var isAdditionComponent = function (schema) {
    var _a;
    return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Addition')) > -1;
};
var isIndexComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'Index')) > -1;
};
var isRemoveComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'Remove')) > -1;
};
var isCopyComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'Copy')) > -1;
};
var isMoveUpComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'MoveUp')) > -1;
};
var isMoveDownComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'MoveDown')) > -1;
};
var isOperationComponent = function (schema) {
    return (isAdditionComponent(schema) ||
        isRemoveComponent(schema) ||
        isCopyComponent(schema) ||
        isMoveDownComponent(schema) ||
        isMoveUpComponent(schema));
};
var InternalArrayCards = observer(function (props) {
    var field = useField();
    var schema = useFieldSchema();
    var dataSource = Array.isArray(field.value) ? field.value : [];
    var prefixCls = usePrefixCls('formily-array-cards', props);
    var _a = array_cards_read(array_cards_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    if (!schema)
        throw new Error('can not found schema object');
    var renderItems = function () {
        return dataSource === null || dataSource === void 0 ? void 0 : dataSource.map(function (item, index) {
            var items = Array.isArray(schema.items)
                ? schema.items[index] || schema.items[0]
                : schema.items;
            var title = (external_React_default().createElement("span", null,
                items ? (external_React_default().createElement(RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                        if (!isIndexComponent(schema))
                            return false;
                        return true;
                    }, onlyRenderProperties: true })) : null,
                props.title || field.title));
            var extra = (external_React_default().createElement("span", null,
                items ? (external_React_default().createElement(RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                        if (!isOperationComponent(schema))
                            return false;
                        return true;
                    }, onlyRenderProperties: true })) : null,
                props.extra));
            var content = items ? (external_React_default().createElement(RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                    if (isIndexComponent(schema))
                        return false;
                    if (isOperationComponent(schema))
                        return false;
                    return true;
                } })) : null;
            return (external_React_default().createElement(ArrayBase.Item, { key: index, index: index, record: function () { var _a; return (_a = field.value) === null || _a === void 0 ? void 0 : _a[index]; } },
                external_React_default().createElement(external_antd_namespaceObject.Card, array_cards_assign({}, props, { onChange: function () { }, className: classnames_default()("".concat(prefixCls, "-item"), hashId, props.className), title: title, extra: extra }), content)));
        });
    };
    var renderAddition = function () {
        return schema.reduceProperties(function (addition, schema, key) {
            if (isAdditionComponent(schema)) {
                return external_React_default().createElement(RecursionField, { schema: schema, name: key });
            }
            return addition;
        }, null);
    };
    var renderEmpty = function () {
        if (dataSource === null || dataSource === void 0 ? void 0 : dataSource.length)
            return;
        return (external_React_default().createElement(external_antd_namespaceObject.Card, array_cards_assign({}, props, { onChange: function () { }, className: classnames_default()("".concat(prefixCls, "-item"), hashId, props.className), title: props.title || field.title }),
            external_React_default().createElement(external_antd_namespaceObject.Empty, null)));
    };
    return wrapSSR(external_React_default().createElement(ArrayBase, null,
        renderEmpty(),
        renderItems(),
        renderAddition()));
});
var ArrayCards = ArrayBase.mixin(InternalArrayCards);
ArrayCards.displayName = 'ArrayCards';
/* harmony default export */ const array_cards = ((/* unused pure expression or super */ null && (ArrayCards)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-collapse/style.js

/* harmony default export */ const array_collapse_style = (genStyleHook('', function (token) {
    var _a;
    var componentCls = token.componentCls;
    return _a = {},
        _a[componentCls] = {
            '&-item': {
                marginBottom: '10px !important',
            },
        },
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-collapse/index.js
var array_collapse_assign = (undefined && undefined.__assign) || function () {
    array_collapse_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return array_collapse_assign.apply(this, arguments);
};
var array_collapse_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};








var array_collapse_isAdditionComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'Addition')) > -1;
};
var array_collapse_isIndexComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'Index')) > -1;
};
var array_collapse_isRemoveComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'Remove')) > -1;
};
var array_collapse_isMoveUpComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'MoveUp')) > -1;
};
var array_collapse_isMoveDownComponent = function (schema) {
    var _a, _b;
    return ((_b = (_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, 'MoveDown')) > -1;
};
var array_collapse_isOperationComponent = function (schema) {
    return (array_collapse_isAdditionComponent(schema) ||
        array_collapse_isRemoveComponent(schema) ||
        array_collapse_isMoveDownComponent(schema) ||
        array_collapse_isMoveUpComponent(schema));
};
var range = function (count) { return Array.from({ length: count }).map(function (_, i) { return i; }); };
var takeDefaultActiveKeys = function (dataSourceLength, defaultOpenPanelCount) {
    if (dataSourceLength < defaultOpenPanelCount)
        return range(dataSourceLength);
    return range(defaultOpenPanelCount);
};
var insertActiveKeys = function (activeKeys, index) {
    if (activeKeys.length <= index)
        return activeKeys.concat(index);
    return activeKeys.reduce(function (buf, key) {
        if (key < index)
            return buf.concat(key);
        if (key === index)
            return buf.concat([key, key + 1]);
        return buf.concat(key + 1);
    }, []);
};
var InternalArrayCollapse = observer(function (props) {
    var field = useField();
    var dataSource = Array.isArray(field.value) ? field.value : [];
    var _a = array_collapse_read((0,external_React_namespaceObject.useState)(takeDefaultActiveKeys(dataSource.length, props.defaultOpenPanelCount)), 2), activeKeys = _a[0], setActiveKeys = _a[1];
    var schema = useFieldSchema();
    var prefixCls = usePrefixCls('formily-array-collapse', props);
    var _b = array_collapse_read(array_collapse_style(prefixCls), 2), wrapSSR = _b[0], hashId = _b[1];
    (0,external_React_namespaceObject.useEffect)(function () {
        if (!field.modified && dataSource.length) {
            setActiveKeys(takeDefaultActiveKeys(dataSource.length, props.defaultOpenPanelCount));
        }
    }, [dataSource.length, field]);
    if (!schema)
        throw new Error('can not found schema object');
    var renderAddition = function () {
        return schema.reduceProperties(function (addition, schema, key) {
            if (array_collapse_isAdditionComponent(schema)) {
                return external_React_default().createElement(RecursionField, { schema: schema, name: key });
            }
            return addition;
        }, null);
    };
    var renderEmpty = function () {
        if (dataSource.length)
            return;
        return (external_React_default().createElement(external_antd_namespaceObject.Card, { className: classnames_default()("".concat(prefixCls, "-item"), hashId, props.className) },
            external_React_default().createElement(external_antd_namespaceObject.Empty, null)));
    };
    var renderItems = function () {
        return (external_React_default().createElement(external_antd_namespaceObject.Collapse, array_collapse_assign({}, props, { activeKey: activeKeys, onChange: function (keys) { return setActiveKeys(toArr(keys).map(Number)); }, className: classnames_default()("".concat(prefixCls, "-item"), hashId, props.className) }), dataSource.map(function (item, index) {
            var items = Array.isArray(schema.items)
                ? schema.items[index] || schema.items[0]
                : schema.items;
            if (!items)
                return null;
            var panelProps = field
                .query("".concat(field.address, ".").concat(index))
                .get('componentProps');
            var props = items['x-component-props'];
            var header = function () {
                var header = "".concat((panelProps === null || panelProps === void 0 ? void 0 : panelProps.header) || props.header || field.title);
                var path = field.address.concat(index);
                var errors = field.form.queryFeedbacks({
                    type: 'error',
                    address: "".concat(path, ".**"),
                });
                return (external_React_default().createElement(array_base.Item, { index: index, record: function () { var _a; return (_a = field.value) === null || _a === void 0 ? void 0 : _a[index]; } },
                    external_React_default().createElement(RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                            if (!array_collapse_isIndexComponent(schema))
                                return false;
                            return true;
                        }, onlyRenderProperties: true }),
                    errors.length ? (external_React_default().createElement(external_antd_namespaceObject.Badge, { size: "small", className: "errors-badge", count: errors.length }, header)) : (header)));
            };
            var extra = (external_React_default().createElement(array_base.Item, { index: index, record: item },
                external_React_default().createElement(RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                        if (!array_collapse_isOperationComponent(schema))
                            return false;
                        return true;
                    }, onlyRenderProperties: true }), panelProps === null || panelProps === void 0 ? void 0 :
                panelProps.extra));
            var content = (external_React_default().createElement(RecursionField, { schema: items, name: index, filterProperties: function (schema) {
                    if (array_collapse_isIndexComponent(schema))
                        return false;
                    if (array_collapse_isOperationComponent(schema))
                        return false;
                    return true;
                } }));
            return (external_React_default().createElement(external_antd_namespaceObject.Collapse.Panel, array_collapse_assign({}, props, panelProps, { forceRender: true, key: index, header: header(), extra: extra }),
                external_React_default().createElement(array_base.Item, { index: index, key: index, record: item }, content)));
        })));
    };
    return wrapSSR(external_React_default().createElement(array_base, { onAdd: function (index) {
            setActiveKeys(insertActiveKeys(activeKeys, index));
        } },
        renderEmpty(),
        renderItems(),
        renderAddition()));
});
var CollapsePanel = function (_a) {
    var children = _a.children;
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, children);
};
CollapsePanel.displayName = 'CollapsePanel';
var ArrayCollapse = Object.assign(array_base.mixin(InternalArrayCollapse), {
    CollapsePanel: CollapsePanel,
});
ArrayCollapse.displayName = 'ArrayCollapse';
ArrayCollapse.defaultProps = {
    defaultOpenPanelCount: 5,
};
/* harmony default export */ const array_collapse = ((/* unused pure expression or super */ null && (ArrayCollapse)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-items/style.js

/* harmony default export */ const array_items_style = (genStyleHook('array-items', function (token) {
    var _a, _b, _c, _d, _e, _f;
    var componentCls = token.componentCls, antCls = token.antCls, colorBgBase = token.colorBgBase, fontSizeSM = token.fontSizeSM, colorBorder = token.colorBorder, colorText = token.colorText;
    var itemCls = "".concat(antCls, "-formily-item");
    return _a = {},
        _a[componentCls] = (_b = {},
            _b["".concat(componentCls, "-item-inner")] = {
                visibility: 'visible',
            },
            _b['&-item'] = {
                zIndex: 100000,
            },
            _b['&-card'] = (_c = {
                    display: 'flex',
                    border: "1px solid ".concat(colorBorder),
                    marginBottom: 10,
                    padding: '3px 6px',
                    background: colorBgBase,
                    justifyContent: 'space-between',
                    color: colorText
                },
                _c["".concat(itemCls, ":not(").concat(itemCls, "-feedback-layout-popover)")] = (_d = {
                        marginBottom: '0 !important'
                    },
                    _d["".concat(itemCls, "-help")] = {
                        position: 'absolute',
                        fontSize: fontSizeSM,
                        top: '100%',
                        background: colorBgBase,
                        width: '100%',
                        marginTop: 3,
                        padding: 3,
                        zIndex: 1,
                        borderRadius: 3,
                        boxShadow: "0 0 10px ".concat(colorBorder),
                    },
                    _d),
                _c),
            _b['&-divide'] = (_e = {
                    display: 'flex',
                    borderBottom: "1px solid ".concat(colorBorder),
                    padding: '10px 0',
                    justifyContent: 'space-between'
                },
                _e["".concat(itemCls, ":not(").concat(itemCls, "-feedback-layout-popover)")] = (_f = {
                        marginBottom: '0 !important'
                    },
                    _f["".concat(itemCls, "-help")] = {
                        position: 'absolute',
                        fontSize: fontSizeSM,
                        top: '100%',
                        background: colorBgBase,
                        width: '100%',
                        marginTop: 3,
                        padding: 3,
                        zIndex: 1,
                        borderRadius: 3,
                        boxShadow: "0 0 10px ".concat(colorBorder),
                    },
                    _f),
                _e),
            _b),
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-items/index.js
var array_items_assign = (undefined && undefined.__assign) || function () {
    array_items_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return array_items_assign.apply(this, arguments);
};
var array_items_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};






var SortableItem = SortableElement(function (props) {
    var prefixCls = usePrefixCls('formily-array-items');
    var _a = array_items_read(array_items_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement("div", array_items_assign({}, props, { className: classnames_default()("".concat(prefixCls, "-item"), hashId, props.className) }), props.children));
});
var SortableList = SortableContainer(function (props) {
    var prefixCls = usePrefixCls('formily-array-items');
    var _a = array_items_read(array_items_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement("div", array_items_assign({}, props, { className: classnames_default()("".concat(prefixCls, "-list"), hashId, props.className) }), props.children));
});
var array_items_isAdditionComponent = function (schema) {
    var _a;
    return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Addition')) > -1;
};
var useAddition = function () {
    var schema = useFieldSchema();
    return schema.reduceProperties(function (addition, schema, key) {
        if (array_items_isAdditionComponent(schema)) {
            return external_React_default().createElement(RecursionField, { schema: schema, name: key });
        }
        return addition;
    }, null);
};
var InternalArrayItems = observer(function (props) {
    var field = useField();
    var prefixCls = usePrefixCls('formily-array-items');
    var _a = array_items_read(array_items_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    var schema = useFieldSchema();
    var addition = useAddition();
    var dataSource = Array.isArray(field.value) ? field.value : [];
    if (!schema)
        throw new Error('can not found schema object');
    return wrapSSR(external_React_default().createElement(ArrayBase, null,
        external_React_default().createElement("div", array_items_assign({}, props, { onChange: function () { }, className: classnames_default()(prefixCls, hashId, props.className) }),
            external_React_default().createElement(SortableList, { list: dataSource.slice(), className: "".concat(prefixCls, "-sort-helper"), onSortEnd: function (event) {
                    var oldIndex = event.oldIndex, newIndex = event.newIndex;
                    field.move(oldIndex, newIndex);
                } }, dataSource === null || dataSource === void 0 ? void 0 : dataSource.map(function (item, index) {
                var items = Array.isArray(schema.items)
                    ? schema.items[index] || schema.items[0]
                    : schema.items;
                return (external_React_default().createElement(ArrayBase.Item, { key: index, index: index, record: function () { var _a; return (_a = field.value) === null || _a === void 0 ? void 0 : _a[index]; } },
                    external_React_default().createElement(SortableItem, { key: "item-".concat(index), lockAxis: "y", index: index },
                        external_React_default().createElement("div", { className: "".concat(prefixCls, "-item-inner") }, items ? (external_React_default().createElement(RecursionField, { schema: items, name: index })) : null))));
            })),
            addition)));
});
var array_items_Item = function (props) {
    var prefixCls = usePrefixCls('formily-array-items');
    var _a = array_items_read(array_items_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement("div", array_items_assign({}, props, { onChange: function () { }, className: classnames_default()("".concat(prefixCls, "-").concat(props.type || 'card'), hashId, props.className) }), props.children));
};
var ArrayItems = Object.assign(ArrayBase.mixin(InternalArrayItems), {
    Item: array_items_Item,
});
ArrayItems.displayName = 'ArrayItems';
/* harmony default export */ const array_items = ((/* unused pure expression or super */ null && (ArrayItems)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-table/style.js

/* harmony default export */ const array_table_style = (genStyleHook('array-table', function (token) {
    var _a, _b, _c, _d, _e, _f;
    var componentCls = token.componentCls, antCls = token.antCls, colorErrorBorder = token.colorErrorBorder, fontSizeSM = token.fontSizeSM, colorBgBase = token.colorBgBase, colorBorder = token.colorBorder, colorBgContainer = token.colorBgContainer;
    var itemCls = "".concat(antCls, "-formily-item");
    return _a = {},
        _a[componentCls] = (_b = {},
            _b["".concat(componentCls, "-pagination")] = (_c = {
                    display: 'flex',
                    justifyContent: 'center'
                },
                _c["".concat(componentCls, "-status-select.has-error")] = (_d = {},
                    _d["".concat(antCls, "-select-selector")] = {
                        borderColor: "".concat(colorErrorBorder, " !important"),
                    },
                    _d),
                _c),
            _b["".concat(antCls, "-table")] = {
                td: (_e = {
                        visibility: 'visible'
                    },
                    _e["".concat(itemCls, ":not(").concat(itemCls, "-feedback-layout-popover)")] = (_f = {
                            marginBottom: '0 !important'
                        },
                        _f["".concat(itemCls, "-help")] = {
                            position: 'absolute',
                            fontSize: fontSizeSM,
                            top: '100%',
                            background: colorBgBase,
                            width: '100%',
                            marginTop: 3,
                            padding: 3,
                            zIndex: 1,
                            borderRadius: 3,
                            boxShadow: "0 0 10px ".concat(colorBorder),
                            animation: 'none',
                            transform: 'translateY(0)',
                            opacity: 1,
                        },
                        _f),
                    _e),
                table: {
                    overflow: 'hidden',
                },
            },
            _b["".concat(componentCls, "-sort-helper")] = {
                background: colorBgContainer,
                border: "1px solid ".concat(colorBorder),
                zIndex: 10,
            },
            _b),
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-table/index.js
var array_table_assign = (undefined && undefined.__assign) || function () {
    array_table_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return array_table_assign.apply(this, arguments);
};
var array_table_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};








var SortableRow = SortableElement(function (props) { return external_React_default().createElement("tr", array_table_assign({}, props)); });
var SortableBody = SortableContainer(function (props) { return external_React_default().createElement("tbody", array_table_assign({}, props)); });
var isColumnComponent = function (schema) {
    var _a;
    return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Column')) > -1;
};
var isOperationsComponent = function (schema) {
    var _a;
    return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Operations')) > -1;
};
var array_table_isAdditionComponent = function (schema) {
    var _a;
    return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Addition')) > -1;
};
var useArrayTableSources = function () {
    var arrayField = useField();
    var schema = useFieldSchema();
    var parseSources = function (schema) {
        var _a, _b, _c;
        if (isColumnComponent(schema) ||
            isOperationsComponent(schema) ||
            array_table_isAdditionComponent(schema)) {
            if (!((_a = schema['x-component-props']) === null || _a === void 0 ? void 0 : _a['dataIndex']) && !schema['name'])
                return [];
            var name_1 = ((_b = schema['x-component-props']) === null || _b === void 0 ? void 0 : _b['dataIndex']) || schema['name'];
            var field = arrayField.query(arrayField.address.concat(name_1)).take();
            var columnProps = ((_c = field === null || field === void 0 ? void 0 : field.component) === null || _c === void 0 ? void 0 : _c[1]) || schema['x-component-props'] || {};
            var display = (field === null || field === void 0 ? void 0 : field.display) || schema['x-display'];
            return [
                {
                    name: name_1,
                    display: display,
                    field: field,
                    schema: schema,
                    columnProps: columnProps,
                },
            ];
        }
        else if (schema.properties) {
            return schema.reduceProperties(function (buf, schema) {
                return buf.concat(parseSources(schema));
            }, []);
        }
        return [];
    };
    var parseArrayItems = function (schema) {
        if (!schema)
            return [];
        var sources = [];
        var items = checkers_isArr(schema) ? schema : [schema];
        return items.reduce(function (columns, schema) {
            var item = parseSources(schema);
            if (item) {
                return columns.concat(item);
            }
            return columns;
        }, sources);
    };
    if (!schema)
        throw new Error('can not found schema object');
    return parseArrayItems(schema.items);
};
var useArrayTableColumns = function (dataSource, field, sources) {
    return sources.reduce(function (buf, _a, key) {
        var name = _a.name, columnProps = _a.columnProps, schema = _a.schema, display = _a.display;
        if (display !== 'visible')
            return buf;
        if (!isColumnComponent(schema))
            return buf;
        return buf.concat(array_table_assign(array_table_assign({}, columnProps), { key: key, dataIndex: name, render: function (value, record) {
                var index = dataSource.indexOf(record);
                var children = (external_React_default().createElement(ArrayBase.Item, { index: index, record: function () { var _a; return (_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a[index]; } },
                    external_React_default().createElement(RecursionField, { schema: schema, name: index, onlyRenderProperties: true })));
                return children;
            } }));
    }, []);
};
var array_table_useAddition = function () {
    var schema = useFieldSchema();
    return schema.reduceProperties(function (addition, schema, key) {
        if (array_table_isAdditionComponent(schema)) {
            return external_React_default().createElement(RecursionField, { schema: schema, name: key });
        }
        return addition;
    }, null);
};
var schedulerRequest = {
    request: null,
};
var StatusSelect = observer(function (props) {
    var _a;
    var field = useField();
    var prefixCls = usePrefixCls('formily-array-table');
    var _b = array_table_read(array_table_style(prefixCls), 2), wrapSSR = _b[0], hashId = _b[1];
    var errors = field.errors;
    var parseIndex = function (address) {
        var _a;
        return Number((_a = address === null || address === void 0 ? void 0 : address.slice(address.indexOf(field.address.toString())).match(/(\d+)/)) === null || _a === void 0 ? void 0 : _a[1]);
    };
    var options = (_a = props.options) === null || _a === void 0 ? void 0 : _a.map(function (_a) {
        var label = _a.label, value = _a.value;
        var val = Number(value);
        var hasError = errors.some(function (_a) {
            var _b;
            var address = _a.address;
            var currentIndex = parseIndex(address);
            var startIndex = props.pageSize ? (val - 1) * props.pageSize : 0;
            var endIndex = props.pageSize
                ? val * props.pageSize
                : ((_b = props.options) === null || _b === void 0 ? void 0 : _b.length) || 0;
            return currentIndex >= startIndex && currentIndex <= endIndex;
        });
        return {
            label: hasError ? external_React_default().createElement(external_antd_namespaceObject.Badge, { dot: true }, label) : label,
            value: value,
        };
    });
    var width = String(options === null || options === void 0 ? void 0 : options.length).length * 15;
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Select, { value: props.value, onChange: props.onChange, options: options, virtual: true, style: {
            width: width < 60 ? 60 : width,
        }, className: classnames_default()("".concat(prefixCls, "-status-select"), hashId, {
            'has-error': errors === null || errors === void 0 ? void 0 : errors.length,
        }) }));
}, {
    scheduler: function (update) {
        clearTimeout(schedulerRequest.request);
        schedulerRequest.request = setTimeout(function () {
            update();
        }, 100);
    },
});
var PaginationContext = (0,external_React_namespaceObject.createContext)({});
var usePagination = function () {
    return (0,external_React_namespaceObject.useContext)(PaginationContext);
};
var ArrayTablePagination = function (props) {
    var _a;
    var _b = array_table_read((0,external_React_namespaceObject.useState)(1), 2), current = _b[0], setCurrent = _b[1];
    var prefixCls = usePrefixCls('formily-array-table');
    var _c = array_table_read(array_table_style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    var pageSize = props.pageSize || 10;
    var size = props.size || 'default';
    var dataSource = props.dataSource || [];
    var startIndex = (current - 1) * pageSize;
    var endIndex = startIndex + pageSize - 1;
    var total = (dataSource === null || dataSource === void 0 ? void 0 : dataSource.length) || 0;
    var totalPage = Math.ceil(total / pageSize);
    var pages = Array.from(new Array(totalPage)).map(function (_, index) {
        var page = index + 1;
        return {
            label: page,
            value: page,
        };
    });
    var handleChange = function (current) {
        setCurrent(current);
    };
    (0,external_React_namespaceObject.useEffect)(function () {
        if (totalPage > 0 && totalPage < current) {
            handleChange(totalPage);
        }
    }, [totalPage, current]);
    var renderPagination = function () {
        if (totalPage <= 1)
            return;
        return (external_React_default().createElement("div", { className: classnames_default()("".concat(prefixCls, "-pagination"), hashId) },
            external_React_default().createElement(external_antd_namespaceObject.Space, null,
                external_React_default().createElement(StatusSelect, { value: current, pageSize: pageSize, onChange: handleChange, options: pages, notFoundContent: false }),
                external_React_default().createElement(external_antd_namespaceObject.Pagination, array_table_assign({}, props, { pageSize: pageSize, current: current, total: dataSource.length, size: size, showSizeChanger: false, onChange: handleChange })))));
    };
    return wrapSSR(external_React_default().createElement(external_React_namespaceObject.Fragment, null,
        external_React_default().createElement(PaginationContext.Provider, { value: { totalPage: totalPage, pageSize: pageSize, changePage: handleChange } }, (_a = props.children) === null || _a === void 0 ? void 0 : _a.call(props, dataSource === null || dataSource === void 0 ? void 0 : dataSource.slice(startIndex, endIndex + 1), renderPagination(), {
            startIndex: startIndex,
        }))));
};
var RowComp = function (props) {
    var prefixCls = usePrefixCls('formily-array-table');
    var index = props['data-row-key'] || 0;
    return (external_React_default().createElement(SortableRow, array_table_assign({ lockAxis: "y" }, props, { index: index, className: classnames_default()(props.className, "".concat(prefixCls, "-row-").concat(index + 1)) })));
};
var InternalArrayTable = observer(function (props) {
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var field = useField();
    var prefixCls = usePrefixCls('formily-array-table');
    var _a = array_table_read(array_table_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    var dataSource = Array.isArray(field.value) ? field.value.slice() : [];
    var sources = useArrayTableSources();
    var columns = useArrayTableColumns(dataSource, field, sources);
    var pagination = isBool(props.pagination) ? {} : props.pagination;
    var addition = array_table_useAddition();
    var defaultRowKey = function (record) {
        return dataSource.indexOf(record);
    };
    var addTdStyles = function (id) {
        var _a, _b;
        var node = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.querySelector(".".concat(prefixCls, "-row-").concat(id));
        var helper = (_b = ref.current) === null || _b === void 0 ? void 0 : _b.querySelector(".".concat(prefixCls, "-sort-helper"));
        if (helper) {
            var tds_1 = node === null || node === void 0 ? void 0 : node.querySelectorAll('td');
            if (tds_1) {
                requestAnimationFrame(function () {
                    helper.querySelectorAll('td').forEach(function (td, index) {
                        if (tds_1[index]) {
                            td.style.width = getComputedStyle(tds_1[index]).width;
                        }
                    });
                });
            }
        }
    };
    var genWrapperComp = (0,external_React_namespaceObject.useCallback)(function (list, start) {
        return function (props) {
            return (external_React_default().createElement(SortableBody, array_table_assign({}, props, { accessibility: {
                    container: ref.current || undefined,
                }, start: start, list: list, onSortStart: function (event) {
                    addTdStyles(event.active.id);
                }, onSortEnd: function (event) {
                    var oldIndex = event.oldIndex, newIndex = event.newIndex;
                    window.requestAnimationFrame(function () {
                        field.move(oldIndex, newIndex);
                    });
                }, className: classnames_default()("".concat(prefixCls, "-sort-helper"), props.className) }), props.children));
        };
    }, [field]);
    return wrapSSR(external_React_default().createElement(ArrayTablePagination, array_table_assign({}, pagination, { dataSource: dataSource }), function (dataSource, pager, _a) {
        var startIndex = _a.startIndex;
        return (external_React_default().createElement("div", { ref: ref, className: classnames_default()(prefixCls, hashId) },
            external_React_default().createElement(ArrayBase, null,
                external_React_default().createElement(external_antd_namespaceObject.Table, array_table_assign({ size: "small", bordered: true, rowKey: defaultRowKey }, props, { onChange: function () { }, pagination: false, columns: columns, dataSource: dataSource, components: {
                        body: {
                            wrapper: genWrapperComp(dataSource, startIndex),
                            row: RowComp,
                        },
                    } })),
                external_React_default().createElement("div", { style: { marginTop: 5, marginBottom: 5 } }, pager),
                sources.map(function (column, key) {
                    //专门用来承接对Column的状态管理
                    if (!isColumnComponent(column.schema))
                        return;
                    return external_React_default().createElement(RecursionField, {
                        name: column.name,
                        schema: column.schema,
                        onlyRenderSelf: true,
                        key: key,
                    });
                }),
                addition)));
    }));
});
var Column = function () {
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null);
};
var array_table_Addition = function (props) {
    var array = ArrayBase.useArray();
    var _a = usePagination(), _b = _a.totalPage, totalPage = _b === void 0 ? 0 : _b, _c = _a.pageSize, pageSize = _c === void 0 ? 10 : _c, changePage = _a.changePage;
    return (external_React_default().createElement(ArrayBase.Addition, array_table_assign({}, props, { onClick: function (e) {
            var _a, _b;
            // 如果添加数据后将超过当前页，则自动切换到下一页
            var total = ((_a = array === null || array === void 0 ? void 0 : array.field) === null || _a === void 0 ? void 0 : _a.value.length) || 0;
            if (total === totalPage * pageSize + 1 && checkers_isFn(changePage)) {
                changePage(totalPage + 1);
            }
            (_b = props.onClick) === null || _b === void 0 ? void 0 : _b.call(props, e);
        } })));
};
var ArrayTable = Object.assign(ArrayBase.mixin(InternalArrayTable), {
    Column: Column,
    Addition: array_table_Addition,
});
ArrayTable.displayName = 'ArrayTable';
/* harmony default export */ const array_table = ((/* unused pure expression or super */ null && (ArrayTable)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/array-tabs/index.js
var array_tabs_assign = (undefined && undefined.__assign) || function () {
    array_tabs_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return array_tabs_assign.apply(this, arguments);
};
var array_tabs_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};



var FeedbackBadge = observer(function (props) {
    var field = useField();
    var tab = "".concat(field.title || 'Untitled', " ").concat(props.index + 1);
    var errors = field.errors.filter(function (error) { var _a; return (_a = error.address) === null || _a === void 0 ? void 0 : _a.includes("".concat(field.address, ".").concat(props.index)); });
    if (errors.length) {
        return (external_React_default().createElement(external_antd_namespaceObject.Badge, { size: "small", className: "errors-badge", count: errors.length }, tab));
    }
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, tab);
});
var ArrayTabs = observer(function (props) {
    var field = useField();
    var schema = useFieldSchema();
    var _a = array_tabs_read((0,external_React_namespaceObject.useState)('tab-0'), 2), activeKey = _a[0], setActiveKey = _a[1];
    var value = Array.isArray(field.value) ? field.value : [];
    var dataSource = (value === null || value === void 0 ? void 0 : value.length) ? value : [{}];
    var onEdit = function (targetKey, type) {
        var _a, _b;
        if (type == 'add') {
            var id = dataSource.length;
            if ((_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a.length) {
                field.push(null);
            }
            else {
                field.push(null, null);
            }
            setActiveKey("tab-".concat(id));
        }
        else if (type == 'remove') {
            var index = Number((_b = targetKey.match(/-(\d+)/)) === null || _b === void 0 ? void 0 : _b[1]);
            if (index - 1 > -1) {
                setActiveKey("tab-".concat(index - 1));
            }
            field.remove(index);
        }
    };
    return (external_React_default().createElement(external_antd_namespaceObject.Tabs, array_tabs_assign({}, props, { activeKey: activeKey, onChange: function (key) {
            setActiveKey(key);
        }, type: "editable-card", onEdit: onEdit, items: dataSource === null || dataSource === void 0 ? void 0 : dataSource.map(function (item, index) {
            var items = Array.isArray(schema.items)
                ? schema.items[index]
                : schema.items;
            var key = "tab-".concat(index);
            return {
                key: key,
                label: external_React_default().createElement(FeedbackBadge, { index: index }),
                forceRender: true,
                closable: index !== 0,
                children: items ? (external_React_default().createElement(RecursionField, { schema: items, name: index })) : null,
            };
        }) })));
});
/* harmony default export */ const array_tabs = ((/* unused pure expression or super */ null && (ArrayTabs)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: external "dayjs"
const external_dayjs_namespaceObject = globalThis["dayjs"];
var external_dayjs_default = /*#__PURE__*/__webpack_require__.n(external_dayjs_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/dayjs.js


function dayjsable(value, format) {
    if (!value)
        return value;
    if (Array.isArray(value)) {
        return value.map(function (val) {
            var date = external_dayjs_default()(val, format);
            if (date.isValid())
                return date;
            var _date = external_dayjs_default()(val);
            return _date.isValid() ? _date : val;
        });
    }
    else {
        var date = external_dayjs_default()(value, format);
        if (date.isValid())
            return date;
        var _date = external_dayjs_default()(value);
        return _date.isValid() ? _date : value;
    }
}
var formatDayjsValue = function (value, format, placeholder) {
    var validFormatDate = function (date, format) {
        if (typeof date === 'number') {
            return external_dayjs_default()(date).format(format);
        }
        var _date = external_dayjs_default()(date, format);
        return _date.isValid() ? _date.format(format) : date;
    };
    var formatDate = function (date, format, i) {
        if (i === void 0) { i = 0; }
        if (!date)
            return placeholder;
        if (checkers_isArr(format)) {
            var _format = format[i];
            if (checkers_isFn(_format)) {
                return _format(date);
            }
            if (isEmpty_isEmpty(_format)) {
                return date;
            }
            return validFormatDate(date, _format);
        }
        else {
            if (checkers_isFn(format)) {
                return format(date);
            }
            if (isEmpty_isEmpty(format)) {
                return date;
            }
            return validFormatDate(date, format);
        }
    };
    if (checkers_isArr(value)) {
        return value.map(function (val, index) {
            return formatDate(val, format, index);
        });
    }
    else {
        return value ? formatDate(value, format) : value || placeholder;
    }
};
//# sourceMappingURL=dayjs.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/preview-text/style.js

/* harmony default export */ const preview_text_style = (genStyleHook('preview-text', function (token) {
    var _a, _b;
    var componentCls = token.componentCls, antCls = token.antCls, fontSize = token.fontSize, fontWeightStrong = token.fontWeightStrong;
    return [
        (_a = {},
            _a[componentCls] = (_b = {
                    fontSize: fontSize,
                    fontWeight: fontWeightStrong
                },
                _b["".concat(antCls, "-tag:last-child")] = {
                    marginInlineEnd: 0,
                },
                _b),
            _a),
    ];
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/preview-text/index.js
var preview_text_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};







var PlaceholderContext = (0,external_React_namespaceObject.createContext)('N/A');
var Placeholder = PlaceholderContext.Provider;
var usePlaceholder = function (value) {
    var placeholder = (0,external_React_namespaceObject.useContext)(PlaceholderContext) || 'N/A';
    return isEmpty_isValid(value) && value !== '' ? value : placeholder;
};
var Input = observer(function (props) {
    var prefixCls = usePrefixCls('form-text', props);
    var _a = preview_text_read(preview_text_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Space, { className: classnames_default()(prefixCls, hashId, props.className), style: props.style },
        props.addonBefore,
        props.prefix,
        usePlaceholder(props.value),
        props.suffix,
        props.addonAfter));
});
var NumberPicker = observer(function (props) {
    var prefixCls = usePrefixCls('form-text', props);
    var _a = preview_text_read(preview_text_style(prefixCls), 2), wrapSSR = _a[0], hashId = _a[1];
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Space, { className: classnames_default()(prefixCls, hashId, props.className), style: props.style },
        props.addonBefore,
        props.prefix,
        usePlaceholder(props.formatter
            ? props.formatter(String(props.value), {
                userTyping: false,
                input: '',
            })
            : props.value),
        props['suffix'],
        props.addonAfter));
});
var Select = observer(function (props) {
    var _a, _b;
    var field = useField();
    var prefixCls = usePrefixCls('form-text', props);
    var _c = preview_text_read(preview_text_style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    var dataSource = ((_a = field === null || field === void 0 ? void 0 : field.dataSource) === null || _a === void 0 ? void 0 : _a.length)
        ? field.dataSource
        : ((_b = props === null || props === void 0 ? void 0 : props.options) === null || _b === void 0 ? void 0 : _b.length)
            ? props.options
            : [];
    var placeholder = usePlaceholder();
    var getSelected = function () {
        var value = props.value;
        if (props.mode === 'multiple' || props.mode === 'tags') {
            if (props.labelInValue) {
                return checkers_isArr(value) ? value : [];
            }
            else {
                return checkers_isArr(value)
                    ? value.map(function (val) { return ({ label: val, value: val }); })
                    : [];
            }
        }
        else {
            if (props.labelInValue) {
                return isEmpty_isValid(value) ? [value] : [];
            }
            else {
                return isEmpty_isValid(value) ? [{ label: value, value: value }] : [];
            }
        }
    };
    var getLabel = function (target) {
        var _a, _b;
        var labelKey = ((_a = props.fieldNames) === null || _a === void 0 ? void 0 : _a.label) || 'label';
        return (((_b = dataSource === null || dataSource === void 0 ? void 0 : dataSource.find(function (item) {
            var _a;
            var valueKey = ((_a = props.fieldNames) === null || _a === void 0 ? void 0 : _a.value) || 'value';
            return item[valueKey] == (target === null || target === void 0 ? void 0 : target.value);
        })) === null || _b === void 0 ? void 0 : _b[labelKey]) ||
            target.label ||
            placeholder);
    };
    var getLabels = function () {
        var selected = getSelected();
        if (!selected.length)
            return placeholder;
        if (selected.length === 1)
            return getLabel(selected[0]);
        return selected.map(function (item, key) {
            return external_React_default().createElement(external_antd_namespaceObject.Tag, { key: key }, getLabel(item));
        });
    };
    return wrapSSR(external_React_default().createElement("div", { className: classnames_default()(prefixCls, hashId, props.className), style: props.style }, getLabels()));
});
var TreeSelect = observer(function (props) {
    var _a, _b;
    var field = useField();
    var placeholder = usePlaceholder();
    var prefixCls = usePrefixCls('form-text', props);
    var _c = preview_text_read(preview_text_style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    var dataSource = ((_a = field === null || field === void 0 ? void 0 : field.dataSource) === null || _a === void 0 ? void 0 : _a.length)
        ? field.dataSource
        : ((_b = props === null || props === void 0 ? void 0 : props.treeData) === null || _b === void 0 ? void 0 : _b.length)
            ? props.treeData
            : [];
    var getSelected = function () {
        var value = props.value;
        if (props.multiple) {
            if (props.labelInValue) {
                return checkers_isArr(value) ? value : [];
            }
            else {
                return checkers_isArr(value)
                    ? value.map(function (val) { return ({ label: val, value: val }); })
                    : [];
            }
        }
        else {
            if (props.labelInValue) {
                return value ? [value] : [];
            }
            else {
                return value ? [{ label: value, value: value }] : [];
            }
        }
    };
    var findLabel = function (value, dataSource, treeNodeLabelProp) {
        var _a, _b;
        var valueKey = ((_a = props.fieldNames) === null || _a === void 0 ? void 0 : _a.value) || 'value';
        for (var i = 0; i < (dataSource === null || dataSource === void 0 ? void 0 : dataSource.length); i++) {
            var item = dataSource[i];
            if ((item === null || item === void 0 ? void 0 : item[valueKey]) === value) {
                return (_b = item === null || item === void 0 ? void 0 : item.label) !== null && _b !== void 0 ? _b : item[treeNodeLabelProp];
            }
            else {
                var childLabel = findLabel(value, item === null || item === void 0 ? void 0 : item.children, treeNodeLabelProp);
                if (childLabel)
                    return childLabel;
            }
        }
    };
    var getLabels = function () {
        var selected = getSelected();
        if (!(selected === null || selected === void 0 ? void 0 : selected.length))
            return external_React_default().createElement(external_antd_namespaceObject.Tag, null, placeholder);
        return selected.map(function (_a, key) {
            var value = _a.value, label = _a.label;
            return (external_React_default().createElement(external_antd_namespaceObject.Tag, { key: key }, findLabel(value, dataSource, props.treeNodeLabelProp) ||
                label ||
                placeholder));
        });
    };
    return wrapSSR(external_React_default().createElement("div", { className: classnames_default()(prefixCls, hashId, props.className), style: props.style }, getLabels()));
});
var Cascader = observer(function (props) {
    var _a, _b;
    var field = useField();
    var placeholder = usePlaceholder();
    var prefixCls = usePrefixCls('form-text', props);
    var _c = preview_text_read(preview_text_style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    var dataSource = ((_a = field === null || field === void 0 ? void 0 : field.dataSource) === null || _a === void 0 ? void 0 : _a.length)
        ? field.dataSource
        : ((_b = props === null || props === void 0 ? void 0 : props.options) === null || _b === void 0 ? void 0 : _b.length)
            ? props.options
            : [];
    var findSelectedItem = function (items, val) {
        return items.find(function (item) { return item.value == val; });
    };
    var findSelectedItems = function (sources, selectedValues) {
        return selectedValues.map(function (value) {
            var result = [];
            var items = sources;
            value.forEach(function (val) {
                var _a, _b;
                var selectedItem = findSelectedItem(items, val);
                result.push({
                    label: (_a = selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.label) !== null && _a !== void 0 ? _a : '',
                    value: selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.value,
                });
                items = (_b = selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.children) !== null && _b !== void 0 ? _b : [];
            });
            return result;
        });
    };
    var getSelected = function () {
        var val = toArr(props.value);
        // unified conversion to multi selection mode
        return props.multiple ? val : [val];
    };
    var getLabels = function () {
        var selected = getSelected();
        var values = findSelectedItems(dataSource, selected);
        var labels = values
            .map(function (val) {
            return val.map(function (item) { return item.label; }).join('/');
        })
            .join(' ');
        return labels || placeholder;
    };
    return wrapSSR(external_React_default().createElement("div", { className: classnames_default()(prefixCls, hashId, props.className), style: props.style }, getLabels()));
});
var DatePicker = function (props) {
    var placeholder = usePlaceholder();
    var prefixCls = usePrefixCls('form-text', props);
    var getLabels = function () {
        var labels = formatDayjsValue(props.value, props.format, placeholder);
        return checkers_isArr(labels) ? labels.join('~') : labels;
    };
    return external_React_default().createElement("div", { className: classnames_default()(prefixCls, props.className) }, getLabels());
};
var DateRangePicker = function (props) {
    var placeholder = usePlaceholder();
    var prefixCls = usePrefixCls('form-text', props);
    var getLabels = function () {
        var labels = formatDayjsValue(props.value, props.format, placeholder);
        return checkers_isArr(labels) ? labels.join('~') : labels;
    };
    return (external_React_default().createElement("div", { className: classnames_default()(prefixCls, props.className), style: props.style }, getLabels()));
};
var TimePicker = function (props) {
    var placeholder = usePlaceholder();
    var prefixCls = usePrefixCls('form-text', props);
    var getLabels = function () {
        var labels = formatDayjsValue(props.value, props.format, placeholder);
        return checkers_isArr(labels) ? labels.join('~') : labels;
    };
    return (external_React_default().createElement("div", { className: classnames_default()(prefixCls, props.className), style: props.style }, getLabels()));
};
var TimeRangePicker = function (props) {
    var placeholder = usePlaceholder();
    var prefixCls = usePrefixCls('form-text', props);
    var getLabels = function () {
        var labels = formatDayjsValue(props.value, props.format, placeholder);
        return checkers_isArr(labels) ? labels.join('~') : labels;
    };
    return (external_React_default().createElement("div", { className: classnames_default()(prefixCls, props.className), style: props.style }, getLabels()));
};
var InternalPreviewText = observer(function (props) {
    var prefixCls = usePrefixCls('form-text', props);
    return (external_React_default().createElement("div", { className: classnames_default()(prefixCls, props.className), style: props.style }, usePlaceholder(props.value)));
});
var PreviewText = Object.assign(InternalPreviewText, {
    Input: Input,
    Select: Select,
    TreeSelect: TreeSelect,
    Cascader: Cascader,
    DatePicker: DatePicker,
    DateRangePicker: DateRangePicker,
    TimePicker: TimePicker,
    TimeRangePicker: TimeRangePicker,
    Placeholder: Placeholder,
    usePlaceholder: usePlaceholder,
    NumberPicker: NumberPicker,
});
/* harmony default export */ const preview_text = ((/* unused pure expression or super */ null && (PreviewText)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/cascader/index.js
var cascader_assign = (undefined && undefined.__assign) || function () {
    cascader_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return cascader_assign.apply(this, arguments);
};





var cascader_Cascader = connect(external_antd_namespaceObject.Cascader, mapProps({
    dataSource: 'options',
}, function (props, field) {
    return cascader_assign(cascader_assign({}, props), { suffixIcon: (field === null || field === void 0 ? void 0 : field['loading']) || (field === null || field === void 0 ? void 0 : field['validating']) ? (external_React_default().createElement(external_icons_namespaceObject.LoadingOutlined, null)) : (props.suffixIcon) });
}), mapReadPretty(PreviewText.Cascader));
/* harmony default export */ const cascader = ((/* unused pure expression or super */ null && (cascader_Cascader)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/checkbox/index.js



var InternalCheckbox = connect(external_antd_namespaceObject.Checkbox, mapProps({
    value: 'checked',
    onInput: 'onChange',
}));
var Group = connect(external_antd_namespaceObject.Checkbox.Group, mapProps({
    dataSource: 'options',
}), mapReadPretty(PreviewText.Select, {
    mode: 'tags',
}));
var Checkbox = Object.assign(InternalCheckbox, {
    __ANT_CHECKBOX: true,
    Group: Group,
});
/* harmony default export */ const esm_checkbox = ((/* unused pure expression or super */ null && (Checkbox)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/date-picker/index.js
var date_picker_assign = (undefined && undefined.__assign) || function () {
    date_picker_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return date_picker_assign.apply(this, arguments);
};




var mapDateFormat = function () {
    var getDefaultFormat = function (props) {
        if (props['picker'] === 'month') {
            return 'YYYY-MM';
        }
        else if (props['picker'] === 'quarter') {
            return 'YYYY-\\QQ';
        }
        else if (props['picker'] === 'year') {
            return 'YYYY';
        }
        else if (props['picker'] === 'week') {
            return 'gggg-wo';
        }
        return props['showTime'] ? 'YYYY-MM-DD HH:mm:ss' : 'YYYY-MM-DD';
    };
    return function (props) {
        var format = props['format'] || getDefaultFormat(props);
        var onChange = props.onChange;
        return date_picker_assign(date_picker_assign({}, props), { format: format, value: dayjsable(props.value, format === 'gggg-wo' ? 'gggg-ww' : format), onChange: function (value) {
                if (onChange) {
                    onChange(formatDayjsValue(value, format));
                }
            } });
    };
};
var InternalDatePicker = connect(external_antd_namespaceObject.DatePicker, mapProps(mapDateFormat()), mapReadPretty(PreviewText.DatePicker));
var RangePicker = connect(external_antd_namespaceObject.DatePicker.RangePicker, mapProps(mapDateFormat()), mapReadPretty(PreviewText.DateRangePicker));
var date_picker_DatePicker = Object.assign(InternalDatePicker, {
    RangePicker: RangePicker,
});
/* harmony default export */ const date_picker = ((/* unused pure expression or super */ null && (date_picker_DatePicker)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-layout/useResponsiveFormLayout.js
var useResponsiveFormLayout_assign = (undefined && undefined.__assign) || function () {
    useResponsiveFormLayout_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return useResponsiveFormLayout_assign.apply(this, arguments);
};
var useResponsiveFormLayout_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var useResponsiveFormLayout_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


var calcBreakpointIndex = function (breakpoints, width) {
    if (!breakpoints)
        return;
    for (var i = 0; i < breakpoints.length; i++) {
        if (width <= breakpoints[i]) {
            return i;
        }
    }
};
var calcFactor = function (value, breakpointIndex) {
    var _a;
    if (Array.isArray(value)) {
        if (breakpointIndex === -1)
            return value[0];
        return (_a = value[breakpointIndex || value.length - 1]) !== null && _a !== void 0 ? _a : value[value.length - 1];
    }
    else {
        return value;
    }
};
var factor = function (value, breakpointIndex) {
    return isEmpty_isValid(value) ? calcFactor(value, breakpointIndex) : value;
};
var calculateProps = function (target, props) {
    var clientWidth = target.clientWidth;
    var breakpoints = props.breakpoints, layout = props.layout, labelAlign = props.labelAlign, wrapperAlign = props.wrapperAlign, labelCol = props.labelCol, wrapperCol = props.wrapperCol, otherProps = useResponsiveFormLayout_rest(props, ["breakpoints", "layout", "labelAlign", "wrapperAlign", "labelCol", "wrapperCol"]);
    var breakpointIndex = calcBreakpointIndex(breakpoints, clientWidth);
    return useResponsiveFormLayout_assign({ layout: factor(layout, breakpointIndex), labelAlign: factor(labelAlign, breakpointIndex), wrapperAlign: factor(wrapperAlign, breakpointIndex), labelCol: factor(labelCol, breakpointIndex), wrapperCol: factor(wrapperCol, breakpointIndex) }, otherProps);
};
var useResponsiveFormLayout = function (props) {
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var breakpoints = props.breakpoints;
    if (!checkers_isArr(breakpoints)) {
        return { ref: ref, props: props };
    }
    var _a = useResponsiveFormLayout_read((0,external_React_namespaceObject.useState)(props), 2), layoutProps = _a[0], setLayout = _a[1];
    var updateUI = function () {
        if (ref.current) {
            setLayout(calculateProps(ref.current, props));
        }
    };
    (0,external_React_namespaceObject.useEffect)(function () {
        var observer = function () {
            updateUI();
        };
        var resizeObserver = new ResizeObserver(observer);
        if (ref.current) {
            resizeObserver.observe(ref.current);
        }
        updateUI();
        return function () {
            resizeObserver.disconnect();
        };
    }, []);
    return {
        ref: ref,
        props: layoutProps,
    };
};
//# sourceMappingURL=useResponsiveFormLayout.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-layout/index.js
var form_layout_assign = (undefined && undefined.__assign) || function () {
    form_layout_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_layout_assign.apply(this, arguments);
};
var form_layout_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




var FormLayoutDeepContext = (0,external_React_namespaceObject.createContext)({});
var FormLayoutShallowContext = (0,external_React_namespaceObject.createContext)({});
var useFormDeepLayout = function () { return (0,external_React_namespaceObject.useContext)(FormLayoutDeepContext); };
var useFormShallowLayout = function () { return (0,external_React_namespaceObject.useContext)(FormLayoutShallowContext); };
var useFormLayout = function () { return (form_layout_assign(form_layout_assign({}, useFormDeepLayout()), useFormShallowLayout())); };
var FormLayout = function (_a) {
    var _b;
    var shallow = _a.shallow, children = _a.children, prefixCls = _a.prefixCls, className = _a.className, style = _a.style, otherProps = form_layout_rest(_a, ["shallow", "children", "prefixCls", "className", "style"]);
    var _c = useResponsiveFormLayout(otherProps), ref = _c.ref, props = _c.props;
    var deepLayout = useFormDeepLayout();
    var formPrefixCls = usePrefixCls('form', { prefixCls: prefixCls });
    var layoutPrefixCls = usePrefixCls('formily-layout', { prefixCls: prefixCls });
    var layoutClassName = classnames_default()(layoutPrefixCls, (_b = {},
        _b["".concat(formPrefixCls, "-").concat(props.layout)] = true,
        _b["".concat(formPrefixCls, "-rtl")] = props.direction === 'rtl',
        _b["".concat(formPrefixCls, "-").concat(props.size)] = props.size,
        _b), className);
    var renderChildren = function () {
        var newDeepLayout = form_layout_assign({}, deepLayout);
        if (!shallow) {
            Object.assign(newDeepLayout, props);
        }
        else {
            if (props.size) {
                newDeepLayout.size = props.size;
            }
            if (props.colon) {
                newDeepLayout.colon = props.colon;
            }
        }
        return (external_React_default().createElement(FormLayoutDeepContext.Provider, { value: newDeepLayout },
            external_React_default().createElement(FormLayoutShallowContext.Provider, { value: shallow ? props : undefined }, children)));
    };
    return (external_React_default().createElement("div", { ref: ref, className: layoutClassName, style: style }, renderChildren()));
};
FormLayout.defaultProps = {
    shallow: true,
};
FormLayout.useFormDeepLayout = useFormDeepLayout;
FormLayout.useFormShallowLayout = useFormShallowLayout;
FormLayout.useFormLayout = useFormLayout;
/* harmony default export */ const form_layout = ((/* unused pure expression or super */ null && (FormLayout)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/pickDataProps.js
var pickDataProps = function (props) {
    if (props === void 0) { props = {}; }
    var results = {};
    for (var key in props) {
        if (key.indexOf('data-') > -1) {
            results[key] = props[key];
        }
    }
    return results;
};
//# sourceMappingURL=pickDataProps.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/hooks/useFormItemLayout.js
var useFormItemLayout_assign = (undefined && undefined.__assign) || function () {
    useFormItemLayout_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return useFormItemLayout_assign.apply(this, arguments);
};



var useFormItemLayout = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    var layout = useFormLayout();
    var layoutType = (_b = (_a = props.layout) !== null && _a !== void 0 ? _a : layout.layout) !== null && _b !== void 0 ? _b : 'horizontal';
    return useFormItemLayout_assign(useFormItemLayout_assign({}, props), { layout: layoutType, colon: (_c = props.colon) !== null && _c !== void 0 ? _c : layout.colon, labelAlign: layoutType === 'vertical'
            ? (_d = props.labelAlign) !== null && _d !== void 0 ? _d : 'left'
            : (_f = (_e = props.labelAlign) !== null && _e !== void 0 ? _e : layout.labelAlign) !== null && _f !== void 0 ? _f : 'right', labelWrap: (_g = props.labelWrap) !== null && _g !== void 0 ? _g : layout.labelWrap, labelWidth: (_h = props.labelWidth) !== null && _h !== void 0 ? _h : layout.labelWidth, wrapperWidth: (_j = props.wrapperWidth) !== null && _j !== void 0 ? _j : layout.wrapperWidth, labelCol: (_k = props.labelCol) !== null && _k !== void 0 ? _k : layout.labelCol, wrapperCol: (_l = props.wrapperCol) !== null && _l !== void 0 ? _l : layout.wrapperCol, wrapperAlign: (_m = props.wrapperAlign) !== null && _m !== void 0 ? _m : layout.wrapperAlign, wrapperWrap: (_o = props.wrapperWrap) !== null && _o !== void 0 ? _o : layout.wrapperWrap, fullness: (_p = props.fullness) !== null && _p !== void 0 ? _p : layout.fullness, size: (_q = props.size) !== null && _q !== void 0 ? _q : layout.size, inset: (_r = props.inset) !== null && _r !== void 0 ? _r : layout.inset, asterisk: props.asterisk, bordered: (_s = props.bordered) !== null && _s !== void 0 ? _s : layout.bordered, feedbackIcon: props.feedbackIcon, feedbackLayout: (_u = (_t = props.feedbackLayout) !== null && _t !== void 0 ? _t : layout.feedbackLayout) !== null && _u !== void 0 ? _u : 'loose', tooltipLayout: (_w = (_v = props.tooltipLayout) !== null && _v !== void 0 ? _v : layout.tooltipLayout) !== null && _w !== void 0 ? _w : 'icon', tooltipIcon: (_y = (_x = props.tooltipIcon) !== null && _x !== void 0 ? _x : layout.tooltipIcon) !== null && _y !== void 0 ? _y : (external_React_default().createElement(external_icons_namespaceObject.QuestionCircleOutlined, null)) });
};
//# sourceMappingURL=useFormItemLayout.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/hooks/useOverflow.js
var useOverflow_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};


function useOverflow() {
    var _a = useOverflow_read((0,external_React_namespaceObject.useState)(false), 2), overflow = _a[0], setOverflow = _a[1];
    var containerRef = (0,external_React_namespaceObject.useRef)(null);
    var contentRef = (0,external_React_namespaceObject.useRef)(null);
    var layout = useFormLayout();
    var labelCol = JSON.stringify(layout.labelCol);
    (0,external_React_namespaceObject.useEffect)(function () {
        requestAnimationFrame(function () {
            if (containerRef.current && contentRef.current) {
                var contentWidth = contentRef.current.getBoundingClientRect().width;
                var containerWidth = containerRef.current.getBoundingClientRect().width;
                if (contentWidth && containerWidth && containerWidth < contentWidth) {
                    if (!overflow)
                        setOverflow(true);
                }
                else {
                    if (overflow)
                        setOverflow(false);
                }
            }
        });
    }, [labelCol]);
    return {
        overflow: overflow,
        containerRef: containerRef,
        contentRef: contentRef,
    };
}
//# sourceMappingURL=useOverflow.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/style/animation.js

var antShowHelpIn = new Keyframes('antShowHelpIn', {
    '0%': {
        transform: 'translateY(-5px)',
        opacity: 0,
    },
    to: {
        transform: ' translateY(0)',
        opacity: 1,
    },
});
var getAnimationStyle = function (token) {
    var _a;
    var componentCls = token.componentCls;
    var helpCls = "".concat(componentCls, "-help");
    return _a = {},
        _a[helpCls] = {
            '&-appear, &-enter': {
                animationDuration: '0.3s',
                animationFillMode: 'both',
                animationPlayState: 'paused',
                opacity: 0,
                animationTimingFunction: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
                '&-active': {
                    animationPlayState: 'running',
                    animationName: antShowHelpIn,
                },
            },
        },
        _a;
};
//# sourceMappingURL=animation.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/style/grid.js
var grid_assign = (undefined && undefined.__assign) || function () {
    grid_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return grid_assign.apply(this, arguments);
};
var getGridStyle = function (token) {
    var _a;
    var componentCls = token.componentCls;
    var colCls = "".concat(componentCls, "-item-col");
    var genGrid = function (grid) {
        return {
            flex: "0 0 ".concat((grid / 24) * 100, "%"),
            maxWidth: "".concat((grid / 24) * 100, "%"),
        };
    };
    var genGrids = function () {
        return Array.from({ length: 24 }, function (_, i) {
            var _a;
            var gridCls = "".concat(colCls, "-").concat(i + 1);
            return _a = {},
                _a[gridCls] = genGrid(i + 1),
                _a;
        }).reduce(function (acc, cur) { return (grid_assign(grid_assign({}, acc), cur)); }, {});
    };
    return _a = {},
        _a[componentCls] = grid_assign({}, genGrids()),
        _a;
};
//# sourceMappingURL=grid.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/style/other.js
var other_assign = (undefined && undefined.__assign) || function () {
    other_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return other_assign.apply(this, arguments);
};
var genOtherStyle = function (token) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
    var componentCls = token.componentCls, colorError = token.colorError, colorWarningBg = token.colorWarningBg, colorWarning = token.colorWarning, colorBorder = token.colorBorder, colorSuccess = token.colorSuccess, lineWidth = token.lineWidth, colorPrimaryBorderHover = token.colorPrimaryBorderHover, colorPrimary = token.colorPrimary, antCls = token.antCls, fontSize = token.fontSize, marginSM = token.marginSM, marginLG = token.marginLG, controlHeight = token.controlHeight, controlHeightSM = token.controlHeightSM, lineHeight = token.lineHeight, controlOutlineWidth = token.controlOutlineWidth, controlOutline = token.controlOutline, colorErrorOutline = token.colorErrorOutline, colorWarningOutline = token.colorWarningOutline, colorTextSecondary = token.colorTextSecondary, paddingXS = token.paddingXS;
    var hover = function (color) {
        if (color === void 0) { color = colorPrimaryBorderHover; }
        return ({
            borderColor: color,
            borderInlineEndWidth: lineWidth,
        });
    };
    var active = function (color, outlineColor) {
        if (color === void 0) { color = colorPrimary; }
        if (outlineColor === void 0) { outlineColor = controlOutline; }
        return ({
            borderColor: color,
            borderInlineEndWidth: lineWidth,
            outline: 0,
            boxShadow: "0 0 0 ".concat(controlOutlineWidth, "px ").concat(outlineColor),
        });
    };
    var extraLabelHeight = controlHeightSM - 2;
    return _a = {},
        _a[componentCls] = (_b = {
                '&-layout-vertical': (_c = {
                        display: 'block'
                    },
                    // Vertical Label: https://github.com/ant-design/ant-design/blob/master/components/form/style/index.ts#L391C1-L404C4
                    _c["".concat(componentCls, "-label")] = {
                        minHeight: lineHeight * fontSize + paddingXS,
                        lineHeight: lineHeight,
                        padding: "0 0 ".concat(paddingXS, "px"),
                        '&-content': {
                            whiteSpace: 'initial',
                            textAlign: 'start',
                        },
                    },
                    _c["".concat(antCls, "-label")] = {
                        minHeight: controlHeight - 10,
                        lineHeight: lineHeight,
                    },
                    _c),
                '&-success': (_d = {},
                    _d["".concat(antCls, "-select-selector,\n          ").concat(antCls, "-cascader-picker,\n          ").concat(antCls, "-picker,\n          ").concat(antCls, "-input,\n          ").concat(antCls, "-input-number,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-input")] = {
                        borderColor: "".concat(colorSuccess, " !important"),
                    },
                    _d["".concat(antCls, "-select-selector,\n        ").concat(antCls, "-cascader-picker,\n        ").concat(antCls, "-picker,\n        ").concat(antCls, "-input,\n        ").concat(antCls, "-input-number,\n        ").concat(antCls, "-input-affix-wrapper,\n        ").concat(antCls, "-input-affix-wrapper:hover,\n        ").concat(antCls, "-input:hover")] = {
                        borderColor: "".concat(colorSuccess, " !important"),
                    },
                    _d["".concat(antCls, "-input-affix-wrapper-focused,\n        ").concat(antCls, "-input-affix-wrapper:focus,\n        ").concat(antCls, "-input-focused,\n        ").concat(antCls, "-input:focus")] = {
                        borderColor: "".concat(colorSuccess, " !important"),
                        borderInlineEndWidth: '1px !important',
                        outline: 0,
                    },
                    _d),
                '&-warning': (_e = {},
                    _e["".concat(antCls, "-select-selector,\n          ").concat(antCls, "-cascader-picker,\n          ").concat(antCls, "-picker,\n          ").concat(antCls, "-input,\n          ").concat(antCls, "-input-number,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-input")] = {
                        borderColor: colorWarning,
                    },
                    _e["".concat(antCls, "-select-selector,\n          ").concat(antCls, "-cascader-picker,\n          ").concat(antCls, "-picker,\n          ").concat(antCls, "-input,\n          ").concat(antCls, "-input-number,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-input-affix-wrapper:hover,\n          ").concat(antCls, "-input:hover")] = {
                        borderColor: colorWarning,
                    },
                    _e["".concat(antCls, "-select:not(").concat(antCls, "-select-disabled):not(").concat(antCls, "-select-customize-input)")] = (_f = {},
                        _f["".concat(antCls, "-select-selector")] = {
                            backgroundColor: colorWarningBg,
                            borderColor: colorWarning,
                        },
                        _f["&".concat(antCls, "-select-open ").concat(antCls, "-select-selector,\n              &").concat(antCls, "-select-focused ").concat(antCls, "-select-selector")] = other_assign({}, active(colorWarning, colorWarningOutline)),
                        _f),
                    _e["".concat(antCls, "-input-number,\n          ").concat(antCls, "-picker")] = (_g = {
                            backgroundColor: colorWarningBg,
                            borderColor: colorWarning
                        },
                        _g["&-focused,\n            &:focus"] = other_assign({}, active(colorWarning, colorWarningOutline)),
                        _g['&:not([disabled]):hover'] = {
                            backgroundColor: colorWarningBg,
                            borderColor: colorWarning,
                        },
                        _g),
                    _e["".concat(antCls, "-cascader-picker:focus ").concat(antCls, "-cascader-input")] = other_assign({ backgroundColor: colorWarningBg }, active(colorWarning, colorWarningOutline)),
                    _e["".concat(antCls, "-input-affix-wrapper-focused,\n          ").concat(antCls, "-input-affix-wrapper:focus,\n          ").concat(antCls, "-input-focused,\n          ").concat(antCls, "-input:focus")] = other_assign({}, active(colorWarning, colorWarningOutline)),
                    _e),
                '&-error': (_h = {},
                    _h["".concat(antCls, "-select-selector,\n            ").concat(antCls, "-cascader-picker,\n            ").concat(antCls, "-picker,\n            ").concat(antCls, "-input,\n            ").concat(antCls, "-input-number,\n            ").concat(antCls, "-input-affix-wrapper,\n            ").concat(antCls, "-input")] = {
                        borderColor: "".concat(colorError, " !important"),
                    },
                    _h["".concat(antCls, "-select-selector,\n            ").concat(antCls, "-cascader-picker,\n            ").concat(antCls, "-picker,\n            ").concat(antCls, "-input,\n            ").concat(antCls, "-input-number,\n            ").concat(antCls, "-input-affix-wrapper,\n            ").concat(antCls, "-input-affix-wrapper:hover,\n            ").concat(antCls, "-input:hover")] = {
                        borderColor: "".concat(colorError, "  !important"),
                    },
                    _h["".concat(antCls, "-select:not(").concat(antCls, "-select-disabled):not(").concat(antCls, "-select-customize-input)")] = (_j = {},
                        _j["".concat(antCls, "-select-selector")] = {
                            borderColor: "".concat(colorError, "  !important"),
                        },
                        _j["&".concat(antCls, "-select-open ").concat(antCls, "-select-selector,\n                &").concat(antCls, "-select-focused ").concat(antCls, "-select-selector")] = other_assign({}, active(colorError, colorErrorOutline)),
                        _j),
                    _h["".concat(antCls, "-input-number,\n            ").concat(antCls, "-picker")] = (_k = {
                            borderColor: colorError
                        },
                        _k["&-focused,\n            &:focus"] = other_assign({}, active(colorError, colorErrorOutline)),
                        _k["&:not([disabled]):hover"] = {
                            borderColor: colorError,
                        },
                        _k),
                    _h["".concat(antCls, "-cascader-picker:focus ").concat(antCls, "-cascader-input")] = other_assign({}, active(colorError, colorErrorOutline)),
                    _h["".concat(antCls, "-input-affix-wrapper-focused,\n            ").concat(antCls, "-input-affix-wrapper:focus,\n            ").concat(antCls, "-input-focused,\n            ").concat(antCls, "-input:focus")] = other_assign({}, active(colorError, colorErrorOutline)),
                    _h),
                '&-feedback-layout': {
                    '&-terse': (_l = {
                            marginBottom: marginSM
                        },
                        _l["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                            marginBottom: 0,
                        },
                        _l),
                    '&-loose': (_m = {
                            marginBottom: marginLG
                        },
                        _m["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                            marginBottom: Math.max(marginLG - extraLabelHeight, 0),
                        },
                        _m),
                    '&-none': (_o = {
                            marginBottom: 0
                        },
                        _o["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                            marginBottom: 0,
                        },
                        _o),
                },
                '&-control-wrap': (_p = {},
                    _p["".concat(componentCls, "-control")] = {
                        whiteSpace: 'pre-line',
                        wordBreak: 'break-all',
                    },
                    _p),
                '&-control-align': {
                    '&-left': (_q = {},
                        _q["".concat(componentCls, "-control-content")] = {
                            justifyContent: 'flex-start',
                        },
                        _q),
                    '&-right': (_r = {},
                        _r["".concat(componentCls, "-control-content")] = {
                            justifyContent: 'flex-end',
                        },
                        _r),
                },
                "input[type='radio'], input[type='checkbox']": {
                    width: fontSize,
                    height: fontSize,
                },
                '&-feedback-layout-popover': {
                    marginBottom: 8,
                },
                '&-fullness': (_s = {},
                    _s["> ".concat(componentCls, "-control")] = (_t = {},
                        _t["> ".concat(componentCls, "-control-content")] = (_u = {},
                            _u["> ".concat(componentCls, "-control-content-component")] = {
                                '> *:first-child': {
                                    width: '100%',
                                },
                            },
                            _u),
                        _t),
                    _s),
                '&-inset': (_v = {
                        borderRadius: 2,
                        border: "1px solid ".concat(colorBorder),
                        paddingInlineStart: 12,
                        transition: '0.3s all'
                    },
                    _v["".concat(antCls, "-input-number,\n          ").concat(antCls, "-picker,\n          ").concat(antCls, "-cascader-picker:focus ").concat(antCls, "-cascader-input,\n          ").concat(antCls, "-select:not(").concat(antCls, "-select-customize-input)\n          ").concat(antCls, "-select-selector,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-input")] = {
                        border: 'none !important',
                        boxShadow: 'none !important',
                    },
                    _v["".concat(antCls, "-input-number-handler-wrap")] = (_w = {
                            border: 'none !important'
                        },
                        _w["".concat(antCls, "-input-number-handler")] = {
                            border: 'none !important',
                        },
                        _w),
                    _v['&:hover'] = other_assign({}, hover()),
                    _v),
                '&-active': (_x = {},
                    _x["".concat(componentCls, "-control-content-component-has-feedback-icon")] = other_assign({}, active()),
                    _x["".concat(antCls, "-input-number,\n          ").concat(antCls, "-picker,\n          ").concat(antCls, "-cascader-picker:focus ").concat(antCls, "-cascader-input,\n          ").concat(antCls, "-select:not(").concat(antCls, "-select-customize-input)\n          ").concat(antCls, "-select-selector,\n          ").concat(antCls, "-input")] = other_assign({}, active()),
                    _x),
                '&-inset-active': other_assign({}, active()),
                '&-bordered-none': (_y = {},
                    _y["".concat(antCls, "-input-number,\n          ").concat(antCls, "-input-affix-wrapper,\n          ").concat(antCls, "-picker,\n          ").concat(antCls, "-cascader-picker:focus ").concat(antCls, "-cascader-input,\n          ").concat(antCls, "-select:not(").concat(antCls, "-select-customize-input)\n          ").concat(antCls, "-select-selector,\n          ").concat(antCls, "-input")] = {
                        border: 'none !important',
                        boxShadow: 'none !important',
                    },
                    _y["".concat(antCls, "-input-number-handler-wrap")] = (_z = {
                            border: 'none !important'
                        },
                        _z["".concat(antCls, "-input-number-handler")] = {
                            border: 'none !important',
                        },
                        _z),
                    _y),
                '&:hover': (_0 = {},
                    _0["".concat(componentCls, "-control-content-component-has-feedback-icon")] = other_assign({}, hover()),
                    _0)
            },
            _b["textarea".concat(antCls, "-input")] = {
                height: 'auto',
            },
            _b["".concat(componentCls, "-label-tooltip-icon")] = {
                marginInlineStart: 4,
                color: token.colorTextSecondary,
                display: 'flex',
                alignItems: 'center',
                maxHeight: controlHeight,
                span: {
                    display: 'inline-block',
                },
            },
            _b["".concat(componentCls, "-asterisk")] = {
                color: colorError,
                marginInlineEnd: '4px',
                display: 'inline-block',
                fontFamily: 'SimSun, sans-serif',
            },
            _b["".concat(componentCls, "-colon")] = {
                marginInlineStart: 2,
                marginInlineEnd: 8,
            },
            _b["".concat(componentCls, "-control")] = (_1 = {
                    flex: 1,
                    maxWidth: '100%'
                },
                _1["".concat(componentCls, "-control-content")] = (_2 = {
                        display: 'flex'
                    },
                    _2["".concat(componentCls, "-control-content-component")] = (_3 = {
                            width: '100%',
                            minHeight: controlHeight - 2,
                            lineHeight: "".concat(controlHeight - 2, "px")
                        },
                        _3["&-has-feedback-icon"] = {
                            flex: 1,
                            position: 'relative',
                            display: 'flex',
                            alignItems: 'center',
                        },
                        _3),
                    _2["".concat(componentCls, "-addon-before ")] = {
                        marginInlineEnd: 8,
                        display: 'inline-flex',
                        alignItems: 'center',
                        minHeight: controlHeight,
                        flexShrink: 0,
                    },
                    _2["".concat(componentCls, "-addon-after")] = {
                        marginInlineStart: 8,
                        display: 'inline-flex',
                        alignItems: 'center',
                        minHeight: controlHeight,
                        flexShrink: 0,
                    },
                    _2),
                _1["".concat(componentCls, "-help,\n        ").concat(componentCls, "-extra ")] = {
                    minHeight: extraLabelHeight,
                    lineHeight: "".concat(extraLabelHeight, "px"),
                    color: colorTextSecondary,
                },
                _1),
            _b["".concat(componentCls, "-help,\n          ").concat(componentCls, "-extra")] = {
                clear: 'both',
                minHeight: extraLabelHeight,
                color: 'rgba(0, 0, 0, 0.45)',
                transition: 'color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1)',
                paddingTop: 0,
            },
            _b["".concat(componentCls, "-control-content-component-has-feedback-icon")] = (_4 = {
                    borderRadius: 2,
                    border: "1px solid ".concat(colorBorder),
                    paddingInlineEnd: 8,
                    transition: 'all 0.3s',
                    touchAction: 'manipulation',
                    outline: 'none'
                },
                _4["".concat(antCls, "-input-number,\n            ").concat(antCls, "-picker,\n            ").concat(antCls, "-cascader-picker:focus ").concat(antCls, "-cascader-input,\n            ").concat(antCls, "-select:not(").concat(antCls, "-select-customize-input)\n            ").concat(antCls, "-select-selector,\n            ").concat(antCls, "-input-affix-wrapper,\n            ").concat(antCls, "-input")] = {
                    border: 'none !important',
                    boxShadow: 'none !important',
                },
                _4),
            _b["".concat(componentCls, "-error-help")] = {
                color: "".concat(colorError, "  !important"),
            },
            _b["".concat(componentCls, "-warning-help")] = {
                color: colorWarning,
            },
            _b["".concat(componentCls, "-success-help")] = {
                color: "".concat(colorSuccess, " !important"),
            },
            _b["".concat(antCls, "-upload")] = {
                background: 'transparent',
            },
            _b["".concat(antCls, "-upload").concat(antCls, "-upload-drag")] = {
                background: token.colorBgBase,
            },
            _b["".concat(antCls, "-radio-inline, ").concat(antCls, "-checkbox-inline")] = {
                display: 'inline-block',
                marginInlineStart: marginSM,
                fontWeight: 'normal',
                verticalAlign: 'middle',
                cursor: 'pointer',
                '&:first-child': {
                    marginInlineStart: 0,
                },
            },
            _b["".concat(antCls, "-radio-vertical,\n          ").concat(antCls, "-checkbox-vertical")] = {
                display: 'block',
            },
            _b["".concat(antCls, "-checkbox-vertical + ").concat(antCls, "-checkbox-vertical,\n          ").concat(antCls, "-radio-vertical + ").concat(antCls, "-radio-vertical")] = {
                marginInlineStart: 0,
            },
            _b["".concat(antCls, "-input-number")] = (_5 = {
                    width: '100%',
                    verticalAlign: 'top'
                },
                _5["+ ".concat(antCls, "-form-text")] = {
                    marginInlineStart: marginSM,
                },
                _5['&-handler-wrap'] = {
                    zIndex: 2,
                },
                _5),
            _b["".concat(antCls, "-select,\n          ").concat(antCls, "-cascader-picker,\n          ").concat(antCls, "-picker")] = {
                width: '100%',
            },
            _b["".concat(antCls, "-input-group ").concat(antCls, "-select,\n          ").concat(antCls, "-input-group ").concat(antCls, "-cascader-picker")] = {
                width: 'auto',
            },
            _b['&-popover'] = (_6 = {},
                _6["".concat(componentCls, "-error-help")] = {
                    color: "".concat(colorError, "  !important"),
                },
                _6["".concat(componentCls, "-warning-help")] = {
                    color: colorWarning,
                },
                _6["".concat(componentCls, "-success-help")] = {
                    color: "".concat(colorSuccess, " !important"),
                },
                _6),
            _b),
        _a;
};
//# sourceMappingURL=other.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/style/index.js




var genSmallStyle = function (token) {
    var _a, _b, _c, _d, _e, _f;
    var componentCls = token.componentCls, antCls = token.antCls, controlHeightSM = token.controlHeightSM, marginLG = token.marginLG, fontSizeSM = token.fontSizeSM, lineHeightSM = token.lineHeightSM;
    return _a = {
            fontSize: fontSizeSM,
            lineHeight: controlHeightSM
        },
        _a["".concat(componentCls, "-label")] = {
            lineHeight: "".concat(controlHeightSM, "px"),
            minHeight: controlHeightSM - 4,
            '> label': {
                height: controlHeightSM - 2,
            },
        },
        _a["".concat(componentCls, "-control-content")] = {
            ' &-component': {
                minHeight: controlHeightSM - 4,
                lineHeight: lineHeightSM,
            },
        },
        _a["".concat(componentCls, "-help,\n      ").concat(componentCls, "-extra")] = {
            minHeight: controlHeightSM - 4,
            lineHeight: "".concat(controlHeightSM - 4, "px"),
        },
        _a["".concat(componentCls, "-control-content")] = {
            minHeight: controlHeightSM - 4,
        },
        _a["".concat(antCls, "-input-affix-wrapper,\n      ").concat(antCls, "-input-number,\n      ").concat(antCls, "-picker")] = {
            padding: "0px 11px",
            input: {
                height: controlHeightSM - 4,
                fontSize: fontSizeSM,
            },
        },
        _a["".concat(antCls, "-cascader-picker")] = {
            height: controlHeightSM - 4,
            input: {
                padding: '0 7px',
                height: controlHeightSM - 4,
                fontSize: fontSizeSM,
            },
        },
        _a["".concat(antCls, "-select-single:not(").concat(antCls, "-select-customize-input) ").concat(antCls, "-select-selector")] = (_b = {
                padding: "0px 11px",
                height: controlHeightSM - 4,
                fontSize: fontSizeSM,
                lineHeight: "".concat(controlHeightSM, "px")
            },
            _b["".concat(antCls, "-select-selection-search")] = {
                height: controlHeightSM,
                lineHeight: "".concat(controlHeightSM - 4, "px"),
                '&-input': {
                    height: controlHeightSM - 4,
                    lineHeight: "".concat(controlHeightSM - 4, "px"),
                },
            },
            _b["".concat(antCls, "-select-selection-placeholder")] = {
                height: controlHeightSM,
                lineHeight: "".concat(controlHeightSM - 4, "px"),
            },
            _b["".concat(antCls, "-select-selection-item")] = {
                height: controlHeightSM,
                lineHeight: "".concat(controlHeightSM - 4, "px"),
            },
            _b["".concat(antCls, "-select-multiple:not(").concat(antCls, "-select-customize-input)\n          ").concat(antCls, "-select-selector")] = (_c = {
                    padding: '0px 2px',
                    height: controlHeightSM - 4,
                    fontSize: fontSizeSM,
                    lineHeight: "".concat(controlHeightSM, "px"),
                    '&::after': {
                        height: controlHeightSM - 8,
                        lineHeight: "".concat(controlHeightSM - 8, "px"),
                    }
                },
                _c["".concat(antCls, "-select-selection-search")] = {
                    height: controlHeightSM - 8,
                    lineHeight: "".concat(controlHeightSM - 8, "px"),
                    marginInlineStart: 0,
                    '&-input': {
                        height: controlHeightSM,
                        lineHeight: "".concat(controlHeightSM - 4, "px"),
                    },
                },
                _c["".concat(antCls, "-select-selection-placeholder")] = {
                    height: controlHeightSM - 4,
                    lineHeight: "".concat(controlHeightSM, "px"),
                    marginInlineStart: 4,
                },
                _c["".concat(antCls, "-select-selection-overflow-item")] = (_d = {
                        alignSelf: 'flex-start'
                    },
                    _d["".concat(antCls, "-select-selection-item")] = {
                        lineHeight: "".concat(controlHeightSM - 10, "px"),
                        height: controlHeightSM - 8,
                    },
                    _d),
                _c),
            _b["&".concat(componentCls, "-feedback-layout-terse")] = (_e = {
                    marginBottom: 8
                },
                _e["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                    marginBottom: 0,
                },
                _e),
            _b["&".concat(componentCls, "-feedback-layout-loose")] = (_f = {
                    marginBottom: marginLG
                },
                _f["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                    marginBottom: 0,
                },
                _f),
            _b),
        _a;
};
var genLargeStyle = function (token) {
    var _a, _b, _c, _d, _e, _f;
    var componentCls = token.componentCls, antCls = token.antCls, fontSizeLG = token.fontSizeLG, controlHeightLG = token.controlHeightLG, controlHeightSM = token.controlHeightSM, marginLG = token.marginLG, lineHeightLG = token.lineHeightLG;
    return _a = {
            fontSize: fontSizeLG,
            lineHeight: "".concat(controlHeightLG, "px")
        },
        _a["".concat(componentCls, "-label")] = {
            lineHeight: "".concat(controlHeightLG, "px"),
            minHeight: controlHeightLG - 2,
            '> label': {
                height: controlHeightLG,
            },
        },
        _a["".concat(componentCls, "-control-content")] = {
            ' &-component': {
                minHeight: controlHeightLG - 2,
                lineHeight: lineHeightLG,
            },
        },
        _a["".concat(componentCls, "-help,\n      ").concat(componentCls, "-extra")] = {
            minHeight: controlHeightSM,
            lineHeight: "".concat(controlHeightSM, "px"),
        },
        _a["".concat(componentCls, "-control-content")] = {
            minHeight: controlHeightLG - 2,
        },
        _a["".concat(antCls, "-input")] = {
            fontSize: fontSizeLG,
        },
        _a["".concat(antCls, "-input-number")] = {
            fontSize: fontSizeLG,
            input: {
                height: controlHeightLG - 2,
            },
        },
        _a["".concat(antCls, "-input-affix-wrapper,\n      ").concat(antCls, "-picker")] = {
            padding: "0px 11px",
            lineHeight: "".concat(controlHeightLG - 2, "px"),
            input: {
                height: controlHeightLG - 2,
                fontSize: fontSizeLG,
            },
        },
        _a["".concat(antCls, "-btn")] = {
            height: controlHeightLG,
            padding: '0 8px',
        },
        _a["".concat(antCls, "-radio-button-wrapper")] = {
            height: controlHeightLG,
            lineHeight: "".concat(controlHeightLG, "px"),
        },
        _a["".concat(antCls, "-cascader-picker")] = {
            height: controlHeightLG - 2,
            input: {
                padding: '0 11px',
                height: controlHeightLG - 2,
                fontSize: fontSizeLG,
            },
        },
        _a["".concat(antCls, "-select-single:not(").concat(antCls, "-select-customize-input) ").concat(antCls, "-select-selector")] = (_b = {
                padding: "0px 11px",
                height: controlHeightLG,
                fontSize: fontSizeLG,
                lineHeight: "".concat(controlHeightLG, "px")
            },
            _b["".concat(antCls, "-select-selection-search")] = {
                height: controlHeightLG,
                lineHeight: "".concat(controlHeightLG - 2, "px"),
                '&-input': {
                    height: controlHeightLG,
                    lineHeight: "".concat(controlHeightLG - 2, "px"),
                },
            },
            _b["".concat(antCls, "-select-selection-placeholder")] = {
                height: controlHeightLG,
                lineHeight: "".concat(controlHeightLG, "px"),
            },
            _b["".concat(antCls, "-select-selection-item")] = {
                height: controlHeightLG,
                lineHeight: "".concat(controlHeightLG, "px"),
            },
            _b["".concat(antCls, "-select-multiple:not(").concat(antCls, "-select-customize-input)\n          ").concat(antCls, "-select-selector")] = (_c = {
                    padding: '0px 2px',
                    height: controlHeightLG - 2,
                    fontSize: fontSizeLG,
                    lineHeight: "".concat(controlHeightLG, "px"),
                    '&::after': {
                        height: controlHeightLG - 8,
                        lineHeight: "".concat(controlHeightLG - 8, "px"),
                    }
                },
                _c["".concat(antCls, "-select-selection-search")] = {
                    height: controlHeightLG - 8,
                    lineHeight: "".concat(controlHeightLG - 8, "px"),
                    '&-input': {
                        height: controlHeightLG - 12,
                        lineHeight: "".concat(controlHeightLG - 12, "px"),
                    },
                },
                _c["".concat(antCls, "-select-selection-placeholder")] = {
                    height: controlHeightLG - 8,
                    lineHeight: "".concat(controlHeightLG - 8, "px"),
                },
                _c["".concat(antCls, "-select-selection-overflow-item")] = (_d = {
                        alignSelf: 'flex-start'
                    },
                    _d["".concat(antCls, "-select-selection-item")] = {
                        lineHeight: "".concat(controlHeightLG - 10, "px"),
                        height: controlHeightLG - 8,
                    },
                    _d),
                _c),
            _b["&".concat(componentCls, "-feedback-layout-terse")] = (_e = {
                    marginBottom: 8
                },
                _e["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                    marginBottom: 0,
                },
                _e),
            _b["&".concat(componentCls, "-feedback-layout-loose")] = (_f = {
                    marginBottom: marginLG
                },
                _f["&".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                    marginBottom: 0,
                },
                _f),
            _b),
        _a;
};
var genLabelStyle = function (token) {
    var _a, _b, _c;
    var componentCls = token.componentCls, controlHeight = token.controlHeight, controlHeightSM = token.controlHeightSM, marginLG = token.marginLG, marginSM = token.marginSM, lineHeight = token.lineHeight;
    return {
        lineHeight: "".concat(controlHeight, "px"),
        minHeight: controlHeight - 2,
        position: 'relative',
        display: 'flex',
        color: token.colorTextHeading,
        label: {
            cursor: 'text',
        },
        '&-content': {
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap',
            label: {
                whiteSpace: 'nowrap',
            },
        },
        '&-tooltip': {
            cursor: 'help',
            '*': {
                cursor: 'help',
            },
            label: {
                borderBottom: '1px dashed currentColor',
            },
        },
        '&-feedback-layout': {
            '&-terse': {
                marginBottom: marginSM,
            },
            '&-loose': {
                marginBottom: marginLG,
            },
            '&-none': {
                marginBottom: 0,
            },
            '&-terse, &-loosee, &-none': (_a = {},
                _a["&.".concat(componentCls, "-feedback-has-text:not(").concat(componentCls, "-inset)")] = {
                    marginBottom: 0,
                },
                _a),
        },
        '&-control': (_b = {
                flex: 1,
                maxWidth: '100%'
            },
            _b["&.".concat(componentCls, "-control-content")] = (_c = {
                    display: 'flex',
                    '&-component': {
                        width: '100%',
                        minHeight: controlHeight - 2,
                        lineHeight: lineHeight,
                        '&-has-feedback-icon': {
                            flex: 1,
                            position: 'relative',
                            display: 'flex',
                            alignItems: 'center',
                        },
                    }
                },
                _c["".concat(componentCls, "-addon")] = {
                    '&-before': {
                        marginInlineEnd: marginSM,
                    },
                    '&-after': {
                        marginInlineEnd: marginSM,
                    },
                    '&-before, &-after': {
                        display: 'inline-flex',
                        alignItems: 'center',
                        minHeight: controlHeight,
                        flexShrink: 0,
                    },
                },
                _c),
            _b["".concat(componentCls, "-help,\n        ").concat(componentCls, "-extra")] = {
                minHeight: controlHeightSM,
                lineHeight: "".concat(controlHeightSM, "px"),
                color: token.colorTextSecondary,
            },
            _b),
    };
};
var genFormItemStyle = function (token) {
    var _a, _b, _c, _d, _e, _f, _g;
    var componentCls = token.componentCls, fontSize = token.fontSize, marginLG = token.marginLG;
    return _a = {},
        _a[componentCls] = (_b = {
                display: 'flex',
                position: 'relative',
                marginBottom: marginLG,
                fontSize: fontSize
            },
            _b["".concat(componentCls, "-label")] = genLabelStyle(token),
            _b["&".concat(componentCls, "-size-small")] = genSmallStyle(token),
            _b["&".concat(componentCls, "-size-large")] = genLargeStyle(token),
            _b['&-label'] = (_c = {
                    '&-align': (_d = {},
                        _d["&-left"] = (_e = {},
                            _e["> ".concat(componentCls, "-label")] = {
                                justifyContent: 'flex-start',
                            },
                            _e),
                        _d["&-right"] = (_f = {},
                            _f["> ".concat(componentCls, "-label")] = {
                                justifyContent: 'flex-end',
                            },
                            _f),
                        _d)
                },
                _c['&-wrap'] = (_g = {},
                    _g["".concat(componentCls, "-label")] = {
                        label: {
                            whiteSpace: 'pre-line',
                            wordBreak: 'break-all',
                        },
                    },
                    _g),
                _c),
            _b),
        _a;
};
/* harmony default export */ const form_item_style = (genStyleHook('Form', function (token) {
    return [
        genFormItemStyle(token),
        getAnimationStyle(token),
        genOtherStyle(token),
        getGridStyle(token),
    ];
}));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/hooks/index.js


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-item/index.js
var form_item_assign = (undefined && undefined.__assign) || function () {
    form_item_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_item_assign.apply(this, arguments);
};
var form_item_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var form_item_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};












var ICON_MAP = {
    error: external_React_default().createElement(external_icons_namespaceObject.CloseCircleOutlined, null),
    success: external_React_default().createElement(external_icons_namespaceObject.CheckCircleOutlined, null),
    warning: external_React_default().createElement(external_icons_namespaceObject.ExclamationCircleOutlined, null),
};
var BaseItem = function (_a) {
    var _b, _c, _d, _e, _f;
    var children = _a.children, props = form_item_rest(_a, ["children"]);
    var _g = form_item_read((0,external_React_namespaceObject.useState)(false), 2), active = _g[0], setActive = _g[1];
    var formLayout = useFormItemLayout(props);
    var _h = useOverflow(), containerRef = _h.containerRef, contentRef = _h.contentRef, overflow = _h.overflow;
    var label = formLayout.label, style = formLayout.style, layout = formLayout.layout, _j = formLayout.colon, colon = _j === void 0 ? true : _j, addonBefore = formLayout.addonBefore, addonAfter = formLayout.addonAfter, asterisk = formLayout.asterisk, feedbackStatus = formLayout.feedbackStatus, extra = formLayout.extra, feedbackText = formLayout.feedbackText, fullness = formLayout.fullness, feedbackLayout = formLayout.feedbackLayout, feedbackIcon = formLayout.feedbackIcon, getPopupContainer = formLayout.getPopupContainer, inset = formLayout.inset, _k = formLayout.bordered, bordered = _k === void 0 ? true : _k, labelWidth = formLayout.labelWidth, wrapperWidth = formLayout.wrapperWidth, labelCol = formLayout.labelCol, wrapperCol = formLayout.wrapperCol, labelAlign = formLayout.labelAlign, _l = formLayout.wrapperAlign, wrapperAlign = _l === void 0 ? 'left' : _l, size = formLayout.size, labelWrap = formLayout.labelWrap, wrapperWrap = formLayout.wrapperWrap, tooltipLayout = formLayout.tooltipLayout, tooltip = formLayout.tooltip, tooltipIcon = formLayout.tooltipIcon;
    var labelStyle = form_item_assign({}, formLayout.labelStyle);
    var wrapperStyle = form_item_assign({}, formLayout.wrapperStyle);
    var prefixCls = usePrefixCls('formily-item', props);
    var _m = form_item_read(form_item_style(prefixCls), 2), wrapSSR = _m[0], hashId = _m[1];
    // 固定宽度
    var enableCol = false;
    if (labelWidth || wrapperWidth) {
        if (labelWidth) {
            labelStyle.width = labelWidth === 'auto' ? undefined : labelWidth;
            labelStyle.maxWidth = labelWidth === 'auto' ? undefined : labelWidth;
        }
        if (wrapperWidth) {
            wrapperStyle.width = wrapperWidth === 'auto' ? undefined : wrapperWidth;
            wrapperStyle.maxWidth = wrapperWidth === 'auto' ? undefined : wrapperWidth;
        }
        // 栅格模式
    }
    if (labelCol || wrapperCol) {
        if (!labelStyle.width && !wrapperStyle.width && layout !== 'vertical') {
            enableCol = true;
        }
    }
    var formatChildren = feedbackLayout === 'popover' ? (external_React_default().createElement(external_antd_namespaceObject.Popover, { autoAdjustOverflow: true, overlayClassName: "".concat(prefixCls, "-popover"), placement: "top", content: external_React_default().createElement("div", { className: classnames_default()((_b = {},
                _b["".concat(prefixCls, "-").concat(feedbackStatus, "-help")] = !!feedbackStatus,
                _b["".concat(prefixCls, "-help")] = true,
                _b)) },
            feedbackStatus ? ICON_MAP[feedbackStatus] : null,
            " ",
            feedbackText), open: !!feedbackText, getPopupContainer: getPopupContainer },
        external_React_default().createElement((external_React_default()).Fragment, null, children))) : (children);
    var gridStyles = {};
    var getOverflowTooltip = function () {
        if (overflow) {
            return (external_React_default().createElement("div", null,
                external_React_default().createElement("div", null, label),
                external_React_default().createElement("div", null, tooltip)));
        }
        return tooltip;
    };
    var renderLabelText = function () {
        var labelChildren = (external_React_default().createElement("div", { className: "".concat(prefixCls, "-label-content"), ref: containerRef },
            external_React_default().createElement("span", { ref: contentRef },
                asterisk && external_React_default().createElement("span", { className: "".concat(prefixCls, "-asterisk") }, '*'),
                external_React_default().createElement("label", null, label))));
        if ((tooltipLayout === 'text' && tooltip) || overflow) {
            return (external_React_default().createElement(external_antd_namespaceObject.Tooltip, { placement: "top", title: getOverflowTooltip() }, labelChildren));
        }
        return labelChildren;
    };
    var renderTooltipIcon = function () {
        if (tooltip && tooltipLayout === 'icon' && !overflow) {
            return (external_React_default().createElement("span", { className: "".concat(prefixCls, "-label-tooltip-icon") },
                external_React_default().createElement(external_antd_namespaceObject.Tooltip, { placement: "top", title: tooltip }, tooltipIcon)));
        }
    };
    var renderLabel = function () {
        var _a;
        if (!label)
            return null;
        return (external_React_default().createElement("div", { className: classnames_default()((_a = {},
                _a["".concat(prefixCls, "-label")] = true,
                _a["".concat(prefixCls, "-label-tooltip")] = (tooltip && tooltipLayout === 'text') || overflow,
                _a["".concat(prefixCls, "-item-col-").concat(labelCol)] = enableCol && !!labelCol,
                _a)), style: labelStyle },
            renderLabelText(),
            renderTooltipIcon(),
            label !== ' ' && (external_React_default().createElement("span", { className: "".concat(prefixCls, "-colon") }, colon ? ':' : ''))));
    };
    return wrapSSR(external_React_default().createElement("div", form_item_assign({}, pickDataProps(props), { style: form_item_assign(form_item_assign({}, style), gridStyles), "data-grid-span": props.gridSpan, className: classnames_default()(props.className, (_c = {},
            _c["".concat(prefixCls)] = true,
            _c["".concat(prefixCls, "-layout-").concat(layout)] = true,
            _c["".concat(prefixCls, "-").concat(feedbackStatus)] = !!feedbackStatus,
            _c["".concat(prefixCls, "-feedback-has-text")] = !!feedbackText,
            _c["".concat(prefixCls, "-size-").concat(size)] = !!size,
            _c["".concat(prefixCls, "-feedback-layout-").concat(feedbackLayout)] = !!feedbackLayout,
            _c["".concat(prefixCls, "-fullness")] = !!fullness || !!inset || !!feedbackIcon,
            _c["".concat(prefixCls, "-inset")] = !!inset,
            _c["".concat(prefixCls, "-active")] = active,
            _c["".concat(prefixCls, "-inset-active")] = !!inset && active,
            _c["".concat(prefixCls, "-label-align-").concat(labelAlign)] = true,
            _c["".concat(prefixCls, "-control-align-").concat(wrapperAlign)] = true,
            _c["".concat(prefixCls, "-label-wrap")] = !!labelWrap,
            _c["".concat(prefixCls, "-control-wrap")] = !!wrapperWrap,
            _c["".concat(prefixCls, "-bordered-none")] = bordered === false || !!inset || !!feedbackIcon,
            _c), hashId), onFocus: function () {
            if (feedbackIcon || inset) {
                setActive(true);
            }
        }, onBlur: function () {
            if (feedbackIcon || inset) {
                setActive(false);
            }
        } }),
        renderLabel(),
        external_React_default().createElement("div", { className: classnames_default()((_d = {},
                _d["".concat(prefixCls, "-control")] = true,
                _d["".concat(prefixCls, "-item-col-").concat(wrapperCol)] = enableCol && !!wrapperCol && label,
                _d)) },
            external_React_default().createElement("div", { className: classnames_default()("".concat(prefixCls, "-control-content")) },
                addonBefore && (external_React_default().createElement("div", { className: classnames_default()("".concat(prefixCls, "-addon-before")) }, addonBefore)),
                external_React_default().createElement("div", { style: wrapperStyle, className: classnames_default()((_e = {},
                        _e["".concat(prefixCls, "-control-content-component")] = true,
                        _e["".concat(prefixCls, "-control-content-component-has-feedback-icon")] = !!feedbackIcon,
                        _e)) },
                    external_React_default().createElement(FormLayoutShallowContext.Provider, { value: {} }, formatChildren),
                    feedbackIcon && (external_React_default().createElement("div", { className: classnames_default()("".concat(prefixCls, "-feedback-icon")) }, feedbackIcon))),
                addonAfter && (external_React_default().createElement("div", { className: classnames_default()("".concat(prefixCls, "-addon-after")) }, addonAfter))),
            !!feedbackText &&
                feedbackLayout !== 'popover' &&
                feedbackLayout !== 'none' && (external_React_default().createElement("div", { className: classnames_default()((_f = {},
                    _f["".concat(prefixCls, "-").concat(feedbackStatus, "-help")] = !!feedbackStatus,
                    _f["".concat(prefixCls, "-help")] = true,
                    _f["".concat(prefixCls, "-help-enter")] = true,
                    _f["".concat(prefixCls, "-help-enter-active")] = true,
                    _f)) }, feedbackText)),
            extra && external_React_default().createElement("div", { className: classnames_default()("".concat(prefixCls, "-extra")) }, extra))));
};
// 适配
var FormItem = Object.assign(connect(BaseItem, mapProps(function (props, field) {
    if (isVoidField(field))
        return {
            label: field.title || props.label,
            asterisk: props.asterisk,
            extra: props.extra || field.description,
        };
    if (!field)
        return props;
    var takeFeedbackStatus = function () {
        if (field.validating)
            return 'pending';
        return field.decoratorProps.feedbackStatus || field.validateStatus;
    };
    var takeMessage = function () {
        var split = function (messages) {
            return messages.reduce(function (buf, text, index) {
                if (!text)
                    return buf;
                return index < messages.length - 1
                    ? buf.concat([text, ', '])
                    : buf.concat([text]);
            }, []);
        };
        if (field.validating)
            return;
        if (props.feedbackText)
            return props.feedbackText;
        if (field.selfErrors.length)
            return split(field.selfErrors);
        if (field.selfWarnings.length)
            return split(field.selfWarnings);
        if (field.selfSuccesses.length)
            return split(field.selfSuccesses);
    };
    var takeAsterisk = function () {
        if ('asterisk' in props) {
            return props.asterisk;
        }
        if (field.required && field.pattern !== 'readPretty') {
            return true;
        }
        return false;
    };
    return {
        label: props.label || field.title,
        feedbackStatus: takeFeedbackStatus(),
        feedbackText: takeMessage(),
        asterisk: takeAsterisk(),
        extra: props.extra || field.description,
    };
})), {
    BaseItem: BaseItem,
});
/* harmony default export */ const form_item = ((/* unused pure expression or super */ null && (FormItem)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/hooks/useClickAway.js

var defaultEvent = 'click';
function getTargetElement(target, defaultElement) {
    if (!target) {
        return defaultElement;
    }
    var targetElement;
    if (typeof target === 'function') {
        targetElement = target();
    }
    else if ('current' in target) {
        targetElement = target.current;
    }
    else {
        targetElement = target;
    }
    return targetElement;
}
var useClickAway = function (onClickAway, target, eventName) {
    if (eventName === void 0) { eventName = defaultEvent; }
    var onClickAwayRef = (0,external_React_namespaceObject.useRef)(onClickAway);
    onClickAwayRef.current = onClickAway;
    (0,external_React_namespaceObject.useEffect)(function () {
        var handler = function (event) {
            var targets = Array.isArray(target) ? target : [target];
            if (targets.some(function (targetItem) {
                var targetElement = getTargetElement(targetItem);
                return !targetElement || (targetElement === null || targetElement === void 0 ? void 0 : targetElement.contains(event.target));
            })) {
                return;
            }
            onClickAwayRef.current(event);
        };
        document.addEventListener(eventName, handler);
        return function () {
            document.removeEventListener(eventName, handler);
        };
    }, [target, eventName]);
};
//# sourceMappingURL=useClickAway.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/editable/style.js

/* harmony default export */ const editable_style = (genStyleHook('editable', function (token) {
    var _a, _b, _c;
    var antCls = token.antCls, componentCls = token.componentCls, fontSizeSM = token.fontSizeSM, colorPrimary = token.colorPrimary;
    return _a = {},
        _a[componentCls] = (_b = {
                cursor: 'pointer',
                display: 'inline-block !important'
            },
            _b["".concat(antCls, "-form-text")] = (_c = {
                    display: 'flex',
                    alignItems: 'center'
                },
                _c["".concat(antCls, "-tag")] = {
                    transition: 'none !important',
                },
                _c["".concat(antCls, "-tag:last-child")] = {
                    paddingInlineEnd: '0 !important',
                },
                _c),
            _b["".concat(componentCls, "-content")] = {
                display: 'flex',
                alignItems: 'center',
                '> *': {
                    marginInlineEnd: 3,
                    '&:last-child': {
                        marginInlineEnd: 0,
                    },
                },
            },
            _b["".concat(componentCls, "-edit-btn,\n        ").concat(componentCls, "-close-btn")] = {
                transition: 'all .25s ease-in-out',
                color: '#aaa',
                fontSize: fontSizeSM,
                '&:hover': {
                    color: colorPrimary,
                },
            },
            _b["".concat(componentCls, "-preview")] = {
                whiteSpace: 'nowrap',
                textOverflow: 'ellipsis',
                overflow: 'hidden',
                wordBreak: 'break-all',
                maxWidth: '100%',
                display: 'block',
            },
            _b),
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/editable/index.js
var editable_assign = (undefined && undefined.__assign) || function () {
    editable_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return editable_assign.apply(this, arguments);
};
var editable_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var editable_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var editable_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};









var useParentPattern = function () {
    var _a, _b;
    var field = useField();
    return ((_a = field === null || field === void 0 ? void 0 : field.parent) === null || _a === void 0 ? void 0 : _a.pattern) || ((_b = field === null || field === void 0 ? void 0 : field.form) === null || _b === void 0 ? void 0 : _b.pattern);
};
var useEditable = function () {
    var pattern = useParentPattern();
    var field = useField();
    (0,external_React_namespaceObject.useLayoutEffect)(function () {
        if (pattern === 'editable') {
            return field.setPattern('readPretty');
        }
    }, [pattern]);
    return [
        field.pattern === 'editable',
        function (payload) {
            if (pattern !== 'editable')
                return;
            field.setPattern(payload ? 'editable' : 'readPretty');
        },
    ];
};
var useFormItemProps = function () {
    var field = useField();
    if (isVoidField(field))
        return {};
    if (!field)
        return {};
    var takeMessage = function () {
        if (field.selfErrors.length)
            return field.selfErrors;
        if (field.selfWarnings.length)
            return field.selfWarnings;
        if (field.selfSuccesses.length)
            return field.selfSuccesses;
    };
    return {
        feedbackStatus: field.validateStatus === 'validating' ? 'pending' : field.validateStatus,
        feedbackText: takeMessage(),
        extra: field.description,
    };
};
var InternalEditable = observer(function (props) {
    var _a = editable_read(useEditable(), 2), editable = _a[0], setEditable = _a[1];
    var pattern = useParentPattern();
    var itemProps = useFormItemProps();
    var field = useField();
    var basePrefixCls = usePrefixCls();
    var prefixCls = usePrefixCls('formily-editable');
    var _b = editable_read(editable_style(prefixCls), 2), wrapSSR = _b[0], hashId = _b[1];
    var ref = (0,external_React_namespaceObject.useRef)();
    var innerRef = (0,external_React_namespaceObject.useRef)(null);
    var recover = function () {
        var _a;
        if (ref.current && !((_a = field === null || field === void 0 ? void 0 : field.errors) === null || _a === void 0 ? void 0 : _a.length)) {
            setEditable(false);
        }
    };
    var renderEditHelper = function () {
        if (editable)
            return;
        return (external_React_default().createElement(BaseItem, editable_assign({}, props, itemProps),
            pattern === 'editable' && (external_React_default().createElement(external_icons_namespaceObject.EditOutlined, { className: "".concat(prefixCls, "-edit-btn") })),
            pattern !== 'editable' && (external_React_default().createElement(external_icons_namespaceObject.MessageOutlined, { className: "".concat(prefixCls, "-edit-btn") }))));
    };
    var renderCloseHelper = function () {
        if (!editable)
            return;
        return (external_React_default().createElement(BaseItem, editable_assign({}, props),
            external_React_default().createElement(external_icons_namespaceObject.CloseOutlined, { className: "".concat(prefixCls, "-close-btn") })));
    };
    useClickAway(function (e) {
        var target = e.target;
        if (target === null || target === void 0 ? void 0 : target.closest(".".concat(basePrefixCls, "-select-dropdown")))
            return;
        if (target === null || target === void 0 ? void 0 : target.closest(".".concat(basePrefixCls, "-picker-dropdown")))
            return;
        if (target === null || target === void 0 ? void 0 : target.closest(".".concat(basePrefixCls, "-cascader-menus")))
            return;
        recover();
    }, innerRef);
    var onClick = function (e) {
        var _a;
        var target = e.target;
        var close = ((_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(".".concat(prefixCls, "-close-btn"))) || null;
        if ((target === null || target === void 0 ? void 0 : target.contains(close)) || (close === null || close === void 0 ? void 0 : close.contains(target))) {
            recover();
        }
        else if (!ref.current) {
            setTimeout(function () {
                setEditable(true);
                setTimeout(function () {
                    var _a, _b;
                    (_b = (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('input')) === null || _b === void 0 ? void 0 : _b.focus();
                });
            });
        }
    };
    ref.current = editable;
    return wrapSSR(external_React_default().createElement("div", { className: classnames_default()(prefixCls, hashId), ref: innerRef, onClick: onClick },
        external_React_default().createElement("div", { className: "".concat(prefixCls, "-content") },
            external_React_default().createElement(BaseItem, editable_assign({}, props, itemProps), props.children),
            renderEditHelper(),
            renderCloseHelper())));
});
var Popover = observer(function (props) {
    var field = useField();
    var pattern = useParentPattern();
    var _a = editable_read((0,external_React_namespaceObject.useState)(false), 2), open = _a[0], setOpen = _a[1];
    var prefixCls = usePrefixCls('formily-editable');
    var _b = editable_read(editable_style(prefixCls), 2), wrapSSR = _b[0], hashId = _b[1];
    var closePopover = function () { return editable_awaiter(void 0, void 0, void 0, function () {
        var errors;
        return editable_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, , 2, 3]);
                    return [4 /*yield*/, field.form.validate("".concat(field.address, ".*"))];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    errors = field.form.queryFeedbacks({
                        type: 'error',
                        address: "".concat(field.address, ".*"),
                    });
                    if (errors === null || errors === void 0 ? void 0 : errors.length)
                        return [2 /*return*/];
                    setOpen(false);
                    return [7 /*endfinally*/];
                case 3: return [2 /*return*/];
            }
        });
    }); };
    var openPopover = function () {
        setOpen(true);
    };
    return wrapSSR(external_React_default().createElement(external_antd_namespaceObject.Popover, editable_assign({}, props, { title: props.title || field.title, open: open, className: classnames_default()(prefixCls, hashId, props.className), content: props.children, trigger: "click", destroyTooltipOnHide: true, onOpenChange: function (open) {
            if (open) {
                openPopover();
            }
            else {
                closePopover();
            }
        } }),
        external_React_default().createElement("div", null,
            external_React_default().createElement(BaseItem, { className: "".concat(prefixCls, "-trigger") },
                external_React_default().createElement("div", { className: "".concat(prefixCls, "-content") },
                    external_React_default().createElement("span", { className: "".concat(prefixCls, "-preview") }, props.title || field.title),
                    pattern === 'editable' && (external_React_default().createElement(external_icons_namespaceObject.EditOutlined, { className: "".concat(prefixCls, "-edit-btn") })),
                    pattern !== 'editable' && (external_React_default().createElement(external_icons_namespaceObject.MessageOutlined, { className: "".concat(prefixCls, "-edit-btn") })))))));
});
var Editable = Object.assign(InternalEditable, { Popover: Popover });
/* harmony default export */ const editable = ((/* unused pure expression or super */ null && (Editable)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form/index.js
var form_assign = (undefined && undefined.__assign) || function () {
    form_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_assign.apply(this, arguments);
};
var form_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





var form_Form = function (_a) {
    var form = _a.form, component = _a.component, onAutoSubmit = _a.onAutoSubmit, onAutoSubmitFailed = _a.onAutoSubmitFailed, previewTextPlaceholder = _a.previewTextPlaceholder, props = form_rest(_a, ["form", "component", "onAutoSubmit", "onAutoSubmitFailed", "previewTextPlaceholder"]);
    var top = useParentForm();
    var renderContent = function (form) { return (external_React_default().createElement(RecordScope, { getRecord: function () { return (isForm(form) ? form.values : form.value); } },
        external_React_default().createElement(PreviewText.Placeholder, { value: previewTextPlaceholder },
            external_React_default().createElement(FormLayout, form_assign({}, props), external_React_default().createElement(component, {
                onSubmit: function (e) {
                    var _a, _b;
                    (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);
                    (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);
                    form.submit(onAutoSubmit).catch(onAutoSubmitFailed);
                },
            }, props.children))))); };
    if (form)
        return external_React_default().createElement(FormProvider, { form: form }, renderContent(form));
    if (!top)
        throw new Error('must pass form instance by createForm');
    return renderContent(top);
};
form_Form.defaultProps = {
    component: 'form',
};
/* harmony default export */ const esm_form = ((/* unused pure expression or super */ null && (form_Form)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/resize-observer-polyfill@1.5.1/node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver_es_ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver_es_ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver_es_ResizeObserver;
})();

/* harmony default export */ const ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./node_modules/.pnpm/react-sticky-box@1.0.2_react@18.3.1/node_modules/react-sticky-box/dist/index.js
// src/index.jsx


var getScrollParent = (node) => {
  let parent = node;
  while (parent = parent.parentElement) {
    const overflowYVal = getComputedStyle(parent, null).getPropertyValue("overflow-y");
    if (parent === document.body)
      return window;
    if (overflowYVal === "auto" || overflowYVal === "scroll")
      return parent;
  }
  return window;
};
var offsetTill = (node, target) => {
  let current = node;
  let offset = 0;
  if (target.firstChild && target.firstChild.offsetParent !== target) {
    offset += node.offsetTop - target.offsetTop;
    target = node.offsetParent;
    offset += -node.offsetTop;
  }
  do {
    offset += current.offsetTop;
    current = current.offsetParent;
  } while (current && current !== target);
  return offset;
};
var getParentNode = (node) => {
  let currentParent = node.parentNode;
  while (currentParent) {
    const style = getComputedStyle(currentParent, null);
    if (style.getPropertyValue("display") !== "contents")
      break;
    currentParent = currentParent.parentNode;
  }
  return currentParent || window;
};
var stickyProp = null;
if (typeof CSS !== "undefined" && CSS.supports) {
  if (CSS.supports("position", "sticky"))
    stickyProp = "sticky";
  else if (CSS.supports("position", "-webkit-sticky"))
    stickyProp = "-webkit-sticky";
}
var passiveArg = false;
try {
  opts = Object.defineProperty({}, "passive", {
    get() {
      passiveArg = { passive: true };
    }
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e) {
}
var opts;
var registerNode = (node, { offsetTop, offsetBottom, bottom }) => {
  const scrollPane = getScrollParent(node);
  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;
  const unsubs = [];
  let mode, offset, nodeHeight, naturalTop, parentHeight, scrollPaneOffset, viewPortHeight;
  const getCurrentOffset = () => {
    if (mode === "relative")
      return offset;
    if (mode === "stickyTop") {
      return Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);
    }
    if (mode === "stickyBottom") {
      return Math.max(0, scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom));
    }
  };
  const changeToStickyBottomIfBoxTooLow = (scrollY) => {
    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + offset + offsetBottom) {
      changeMode("stickyBottom");
    }
  };
  const changeMode = (newMode) => {
    mode = newMode;
    if (newMode === "relative") {
      node.style.position = "relative";
      if (bottom) {
        const nextBottom = Math.max(0, parentHeight - nodeHeight - offset);
        node.style.bottom = `${nextBottom}px`;
      } else {
        node.style.top = `${offset}px`;
      }
    } else {
      node.style.position = stickyProp;
      if (newMode === "stickyBottom") {
        if (bottom) {
          node.style.bottom = `${offsetBottom}px`;
        } else {
          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;
        }
      } else {
        if (bottom) {
          node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;
        } else {
          node.style.top = `${offsetTop}px`;
        }
      }
    }
    offset = getCurrentOffset();
  };
  const initial = () => {
    if (bottom) {
      if (mode !== "stickyBottom")
        changeMode("stickyBottom");
    } else {
      if (mode !== "stickyTop")
        changeMode("stickyTop");
    }
  };
  const addListener = (element, event, handler, passive) => {
    element.addEventListener(event, handler, passive);
    unsubs.push(() => element.removeEventListener(event, handler));
  };
  const handleScroll = () => {
    const scrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;
    if (scrollY === latestScrollY)
      return;
    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {
      initial();
      latestScrollY = scrollY;
      return;
    }
    const scrollDelta = scrollY - latestScrollY;
    offset = getCurrentOffset();
    if (scrollDelta > 0) {
      if (mode === "stickyTop") {
        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {
          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + offset + offsetBottom) {
            changeMode("relative");
          } else {
            changeMode("stickyBottom");
          }
        }
      } else if (mode === "relative") {
        changeToStickyBottomIfBoxTooLow(scrollY);
      }
    } else {
      if (mode === "stickyBottom") {
        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {
          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + offset) {
            changeMode("relative");
          } else {
            changeMode("stickyTop");
          }
        }
      } else if (mode === "relative") {
        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + offset) {
          changeMode("stickyTop");
        }
      }
    }
    latestScrollY = scrollY;
  };
  const handleWindowResize = () => {
    viewPortHeight = window.innerHeight;
    scrollPaneOffset = 0;
    handleScroll();
  };
  const handleScrollPaneResize = () => {
    viewPortHeight = scrollPane.offsetHeight;
    if (viewPortHeight === 0) {
      console.warn(`react-sticky-box's scroll pane has a height of 0. This seems odd. Please check this node:`, scrollPane);
    }
    if (scrollPane.firstChild.offsetParent === scrollPane) {
      scrollPaneOffset = scrollPane.getBoundingClientRect().top;
    } else {
      scrollPaneOffset = 0;
    }
    handleScroll();
  };
  const handleParentNodeResize = () => {
    const parentNode = getParentNode(node);
    const computedParentStyle = getComputedStyle(parentNode, null);
    const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue("padding-top"), 10);
    const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue("padding-bottom"), 10);
    const verticalParentPadding = parentPaddingTop + parentPaddingBottom;
    naturalTop = offsetTill(parentNode, scrollPane) + parentPaddingTop + scrollPaneOffset;
    const oldParentHeight = parentHeight;
    parentHeight = parentNode.getBoundingClientRect().height - verticalParentPadding;
    if (mode === "relative") {
      if (bottom) {
        changeMode("relative");
      } else {
        if (oldParentHeight > parentHeight) {
          changeToStickyBottomIfBoxTooLow(latestScrollY);
        }
      }
    }
    if (oldParentHeight !== parentHeight && mode === "relative") {
      latestScrollY = Number.POSITIVE_INFINITY;
      handleScroll();
    }
  };
  const handleNodeResize = ({ initial: initialArg } = {}) => {
    const prevHeight = nodeHeight;
    nodeHeight = node.getBoundingClientRect().height;
    if (!initialArg && prevHeight !== nodeHeight) {
      if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {
        mode = void 0;
        initial();
        return;
      } else {
        const diff = prevHeight - nodeHeight;
        const lowestPossible = parentHeight - nodeHeight;
        const nextOffset = Math.min(lowestPossible, getCurrentOffset() + (bottom ? diff : 0));
        offset = Math.max(0, nextOffset);
        if (!bottom || mode !== "stickyBottom")
          changeMode("relative");
      }
    }
  };
  const addResizeObserver = (n, handler) => {
    const ro = new ResizeObserver_es(handler);
    ro.observe(n);
    unsubs.push(() => ro.disconnect());
  };
  addListener(scrollPane, "scroll", handleScroll, passiveArg);
  addListener(scrollPane, "mousewheel", handleScroll, passiveArg);
  if (scrollPane === window) {
    addListener(window, "resize", handleWindowResize);
    handleWindowResize();
  } else {
    addResizeObserver(scrollPane, handleScrollPaneResize);
    handleScrollPaneResize();
  }
  addResizeObserver(getParentNode(node), handleParentNodeResize);
  handleParentNodeResize();
  addResizeObserver(node, handleNodeResize);
  handleNodeResize({ initial: true });
  initial();
  return () => unsubs.forEach((fn) => fn());
};
var useStickyBox = ({ offsetTop = 0, offsetBottom = 0, bottom = false } = {}) => {
  const [node, setNode] = (0,external_React_namespaceObject.useState)(null);
  const argRef = (0,external_React_namespaceObject.useRef)({ offsetTop, offsetBottom, bottom });
  (0,external_React_namespaceObject.useEffect)(() => {
    argRef.current = { offsetTop, offsetBottom, bottom };
  });
  (0,external_React_namespaceObject.useEffect)(() => {
    if (!node)
      return;
    return registerNode(node, argRef.current);
  }, [node]);
  return setNode;
};
var StickyBox = ({ offsetTop, offsetBottom, bottom, children, className, style }) => {
  const ref = useStickyBox({ offsetTop, offsetBottom, bottom });
  return /* @__PURE__ */ external_React_namespaceObject.createElement("div", {
    className,
    style,
    ref
  }, children);
};
var src_default = StickyBox;


;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-button-group/style.js

/* harmony default export */ const form_button_group_style = (genStyleHook('form-button-group', function (token) {
    var _a, _b, _c;
    var componentCls = token.componentCls, antCls = token.antCls, colorBorder = token.colorBorder;
    return _a = {},
        _a[componentCls] = {
            '&-sticky': (_b = {
                    padding: '10px 0',
                    borderTop: "1px solid ".concat(colorBorder),
                    zIndex: 999
                },
                _b["".concat(componentCls, "-sticky-inner")] = (_c = {
                        display: 'flex'
                    },
                    _c["".concat(antCls, "-formily-item")] = {
                        flex: 2,
                    },
                    _c),
                _b),
        },
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-button-group/index.js
var form_button_group_assign = (undefined && undefined.__assign) || function () {
    form_button_group_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_button_group_assign.apply(this, arguments);
};
var form_button_group_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var form_button_group_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};







function getInheritedBackgroundColor(el) {
    // get default style for current browser
    var defaultStyle = getDefaultBackground(); // typically "rgba(0, 0, 0, 0)"
    // get computed color for el
    var backgroundColor = window.getComputedStyle(el).backgroundColor;
    // if we got a real value, return it
    if (backgroundColor != defaultStyle)
        return backgroundColor;
    // if we've reached the top parent el without getting an explicit color, return default
    if (!el.parentElement)
        return defaultStyle;
    // otherwise, recurse and try again on parent element
    return getInheritedBackgroundColor(el.parentElement);
}
function getDefaultBackground() {
    // have to add to the document in order to use getComputedStyle
    var div = document.createElement('div');
    document.head.appendChild(div);
    var bg = window.getComputedStyle(div).backgroundColor;
    document.head.removeChild(div);
    return bg;
}
var FormButtonGroup = function (_a) {
    var align = _a.align, gutter = _a.gutter, props = form_button_group_rest(_a, ["align", "gutter"]);
    var prefixCls = usePrefixCls('formily-button-group');
    return (external_React_default().createElement(external_antd_namespaceObject.Space, form_button_group_assign({}, props, { size: gutter, className: classnames_default()(prefixCls, props.className), style: form_button_group_assign(form_button_group_assign({}, props.style), { justifyContent: align === 'left'
                ? 'flex-start'
                : align === 'right'
                    ? 'flex-end'
                    : 'center', display: 'flex' }) }), props.children));
};
FormButtonGroup.defaultProps = {
    align: 'left',
};
FormButtonGroup.FormItem = function (_a) {
    var _b;
    var gutter = _a.gutter, props = form_button_group_rest(_a, ["gutter"]);
    return (external_React_default().createElement(BaseItem, form_button_group_assign({}, props, { label: " ", style: form_button_group_assign(form_button_group_assign({ margin: 0, padding: 0 }, props.style), { width: '100%' }), colon: false }), ((_b = props.children) === null || _b === void 0 ? void 0 : _b['length']) ? (external_React_default().createElement(external_antd_namespaceObject.Space, { size: gutter }, props.children)) : (props.children)));
};
FormButtonGroup.Sticky = function (_a) {
    var align = _a.align, props = form_button_group_rest(_a, ["align"]);
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var _b = form_button_group_read((0,external_React_namespaceObject.useState)('transparent'), 2), color = _b[0], setColor = _b[1];
    var prefixCls = usePrefixCls('formily-button-group');
    var _c = form_button_group_read(form_button_group_style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    (0,external_React_namespaceObject.useLayoutEffect)(function () {
        if (ref.current) {
            var computed = getInheritedBackgroundColor(ref.current);
            if (computed !== color) {
                setColor(computed);
            }
        }
    });
    return wrapSSR(external_React_default().createElement(src_default, form_button_group_assign({}, props, { className: classnames_default()("".concat(prefixCls, "-sticky"), hashId, props.className), style: form_button_group_assign({ backgroundColor: color }, props.style), bottom: true }),
        external_React_default().createElement("div", { ref: ref, className: "".concat(prefixCls, "-sticky-inner"), style: form_button_group_assign(form_button_group_assign({}, props.style), { justifyContent: align === 'left'
                    ? 'flex-start'
                    : align === 'right'
                        ? 'flex-end'
                        : 'center' }) }, props.children)));
};
FormButtonGroup.Sticky.defaultProps = {
    align: 'left',
};
/* harmony default export */ const form_button_group = ((/* unused pure expression or super */ null && (FormButtonGroup)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-collapse/index.js
var form_collapse_assign = (undefined && undefined.__assign) || function () {
    form_collapse_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_collapse_assign.apply(this, arguments);
};
var form_collapse_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







var usePanels = function () {
    var collapseField = useField();
    var schema = useFieldSchema();
    var panels = [];
    schema.mapProperties(function (schema, name) {
        var _a, _b, _c;
        var field = collapseField.query(collapseField.address.concat(name)).take();
        if ((field === null || field === void 0 ? void 0 : field.display) === 'none' || (field === null || field === void 0 ? void 0 : field.display) === 'hidden')
            return;
        if (((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('CollapsePanel')) > -1) {
            var key = ((_b = field === null || field === void 0 ? void 0 : field.componentProps) === null || _b === void 0 ? void 0 : _b.key) || ((_c = schema === null || schema === void 0 ? void 0 : schema['x-component-props']) === null || _c === void 0 ? void 0 : _c.key) || name;
            panels.push({
                name: name,
                props: form_collapse_assign(form_collapse_assign(form_collapse_assign({}, schema === null || schema === void 0 ? void 0 : schema['x-component-props']), field === null || field === void 0 ? void 0 : field.componentProps), { key: key }),
                schema: schema,
            });
        }
    });
    return panels;
};
var createFormCollapse = function (defaultActiveKeys) {
    var formCollapse = model({
        activeKeys: defaultActiveKeys,
        setActiveKeys: function (keys) {
            formCollapse.activeKeys = keys;
        },
        hasActiveKey: function (key) {
            if (Array.isArray(formCollapse.activeKeys)) {
                if (formCollapse.activeKeys.includes(key)) {
                    return true;
                }
            }
            else if (formCollapse.activeKeys == key) {
                return true;
            }
            return false;
        },
        addActiveKey: function (key) {
            if (formCollapse.hasActiveKey(key))
                return;
            formCollapse.activeKeys = toArr(formCollapse.activeKeys).concat(key);
        },
        removeActiveKey: function (key) {
            if (Array.isArray(formCollapse.activeKeys)) {
                formCollapse.activeKeys = formCollapse.activeKeys.filter(function (item) { return item != key; });
            }
            else {
                formCollapse.activeKeys = '';
            }
        },
        toggleActiveKey: function (key) {
            if (formCollapse.hasActiveKey(key)) {
                formCollapse.removeActiveKey(key);
            }
            else {
                formCollapse.addActiveKey(key);
            }
        },
    });
    return markRaw(formCollapse);
};
var InternalFormCollapse = observer(function (_a) {
    var formCollapse = _a.formCollapse, props = form_collapse_rest(_a, ["formCollapse"]);
    var field = useField();
    var panels = usePanels();
    var prefixCls = usePrefixCls('formily-collapse', props);
    var _formCollapse = (0,external_React_namespaceObject.useMemo)(function () {
        return formCollapse
            ? formCollapse
            : createFormCollapse(props.defaultActiveKey);
    }, []);
    var takeActiveKeys = function () {
        var _a;
        if (props.activeKey)
            return props.activeKey;
        if (_formCollapse === null || _formCollapse === void 0 ? void 0 : _formCollapse.activeKeys)
            return _formCollapse === null || _formCollapse === void 0 ? void 0 : _formCollapse.activeKeys;
        if (props.accordion)
            return (_a = panels[0]) === null || _a === void 0 ? void 0 : _a.name;
        return panels.map(function (item) { return item.name; });
    };
    var badgedHeader = function (key, props) {
        var errors = field.form.queryFeedbacks({
            type: 'error',
            address: "".concat(field.address.concat(key), ".*"),
        });
        if (errors.length) {
            return (external_React_default().createElement(external_antd_namespaceObject.Badge, { size: "small", className: "errors-badge", count: errors.length }, props.header));
        }
        return props.header;
    };
    return (external_React_default().createElement(external_antd_namespaceObject.Collapse, form_collapse_assign({}, props, { className: classnames_default()(prefixCls, props.className), activeKey: takeActiveKeys(), onChange: function (key) {
            var _a, _b;
            (_a = props === null || props === void 0 ? void 0 : props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
            (_b = _formCollapse === null || _formCollapse === void 0 ? void 0 : _formCollapse.setActiveKeys) === null || _b === void 0 ? void 0 : _b.call(_formCollapse, key);
        } }), panels.map(function (_a, index) {
        var props = _a.props, schema = _a.schema, name = _a.name;
        return (external_React_default().createElement(external_antd_namespaceObject.Collapse.Panel, form_collapse_assign({ key: index }, props, { header: badgedHeader(name, props), forceRender: true }),
            external_React_default().createElement(RecursionField, { schema: schema, name: name })));
    })));
});
var form_collapse_CollapsePanel = function (_a) {
    var children = _a.children;
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, children);
};
var FormCollapse = Object.assign(InternalFormCollapse, {
    CollapsePanel: form_collapse_CollapsePanel,
    createFormCollapse: createFormCollapse,
});
/* harmony default export */ const form_collapse = ((/* unused pure expression or super */ null && (FormCollapse)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/render.js
var render_assign = (undefined && undefined.__assign) || function () {
    render_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return render_assign.apply(this, arguments);
};
var render_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var render_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

// Let compiler not to search module usage
var render_fullClone = render_assign({}, external_ReactDOM_);
var version = render_fullClone.version, reactRender = render_fullClone.render, unmountComponentAtNode = render_fullClone.unmountComponentAtNode;
var createRoot;
try {
    var mainVersion = Number((version || '').split('.')[0]);
    if (mainVersion >= 18 && render_fullClone.createRoot) {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        createRoot = render_fullClone.createRoot;
    }
}
catch (e) {
    // Do nothing;
}
function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = render_fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED &&
        typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === 'object') {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint =
            skip;
    }
}
var MARK = '__antd_mobile_root__';
function legacyRender(node, container) {
    reactRender(node, container);
}
function concurrentRender(node, container) {
    toggleWarning(true);
    var root = container[MARK] || createRoot(container);
    toggleWarning(false);
    root.render(node);
    container[MARK] = root;
}
function _builtins_render_render(node, container) {
    if (createRoot) {
        concurrentRender(node, container);
        return;
    }
    legacyRender(node, container);
}
// ========================== Unmount =========================
function legacyUnmount(container) {
    return unmountComponentAtNode(container);
}
function concurrentUnmount(container) {
    return render_awaiter(this, void 0, void 0, function () {
        return render_generator(this, function (_a) {
            // Delay to unmount to avoid React 18 sync warning
            return [2 /*return*/, Promise.resolve().then(function () {
                    var _a;
                    (_a = container[MARK]) === null || _a === void 0 ? void 0 : _a.unmount();
                    delete container[MARK];
                })];
        });
    });
}
function render_unmount(container) {
    if (createRoot) {
        return concurrentUnmount(container);
    }
    return legacyUnmount(container);
}
//# sourceMappingURL=render.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/portal.js





var PortalMap = esm_observable_observable(new Map());
var createPortalProvider = function (id) {
    var Portal = function (props) {
        if (props.id && !PortalMap.has(props.id)) {
            PortalMap.set(props.id, null);
        }
        return (external_React_default().createElement(external_React_namespaceObject.Fragment, null,
            props.children,
            external_React_default().createElement(Observer, null, function () {
                if (!props.id)
                    return external_React_default().createElement((external_React_default()).Fragment, null);
                var portal = PortalMap.get(props.id);
                if (portal)
                    return (0,external_ReactDOM_.createPortal)(portal, document.body);
                return external_React_default().createElement((external_React_default()).Fragment, null);
            })));
    };
    Portal.defaultProps = {
        id: id,
    };
    return Portal;
};
function createPortalRoot(host, id) {
    function render(renderer) {
        if (PortalMap.has(id)) {
            PortalMap.set(id, renderer === null || renderer === void 0 ? void 0 : renderer());
        }
        else if (host) {
            _builtins_render_render(external_React_default().createElement(external_React_namespaceObject.Fragment, null, renderer === null || renderer === void 0 ? void 0 : renderer()), host);
        }
    }
    function unmount() {
        var _a;
        if (PortalMap.has(id)) {
            PortalMap.set(id, null);
        }
        if (host) {
            var unmountResult = render_unmount(host);
            if (unmountResult && host.parentNode) {
                (_a = host.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(host);
            }
        }
    }
    return {
        render: render,
        unmount: unmount,
    };
}
//# sourceMappingURL=portal.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/__builtins__/loading.js
var loading_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var loading_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var loading = function (title, processor) {
    if (title === void 0) { title = 'Loading...'; }
    return loading_awaiter(void 0, void 0, void 0, function () {
        var hide, loading;
        return loading_generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    hide = null;
                    loading = setTimeout(function () {
                        hide = external_antd_namespaceObject.message.loading(title);
                    }, 100);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, processor()];
                case 2: return [2 /*return*/, _a.sent()];
                case 3:
                    hide === null || hide === void 0 ? void 0 : hide();
                    clearTimeout(loading);
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    });
};
//# sourceMappingURL=loading.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-dialog/index.js
var form_dialog_assign = (undefined && undefined.__assign) || function () {
    form_dialog_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_dialog_assign.apply(this, arguments);
};
var form_dialog_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var form_dialog_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var form_dialog_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};








var isModalTitle = function (props) {
    return (isNum(props) || checkers_isStr(props) || isBool(props) || external_React_default().isValidElement(props));
};
var getModelProps = function (props) {
    if (isModalTitle(props)) {
        return {
            title: props,
        };
    }
    else {
        return props;
    }
};
function FormDialog(title, id, renderer) {
    var _this = this;
    if (checkers_isFn(id) || external_React_default().isValidElement(id)) {
        renderer = id;
        id = 'form-dialog';
    }
    var env = {
        host: document.createElement('div'),
        form: null,
        promise: null,
        openMiddlewares: [],
        confirmMiddlewares: [],
        cancelMiddlewares: [],
    };
    var root = createPortalRoot(env.host, id);
    var props = getModelProps(title);
    var modal = form_dialog_assign(form_dialog_assign({}, props), { afterClose: function () {
            var _a;
            (_a = props === null || props === void 0 ? void 0 : props.afterClose) === null || _a === void 0 ? void 0 : _a.call(props);
            root.unmount();
        } });
    var DialogContent = observer(function () {
        return external_React_default().createElement(external_React_namespaceObject.Fragment, null, checkers_isFn(renderer) ? renderer(env.form) : renderer);
    });
    var renderDialog = function (open, resolve, reject) {
        if (open === void 0) { open = true; }
        var form = env.form;
        if (!form)
            return null;
        return (external_React_default().createElement(Observer, null, function () { return (external_React_default().createElement(external_antd_namespaceObject.Modal, form_dialog_assign({}, modal, { open: open, confirmLoading: form.submitting, onCancel: function (e) {
                var _a;
                if (((_a = modal === null || modal === void 0 ? void 0 : modal.onCancel) === null || _a === void 0 ? void 0 : _a.call(modal, e)) !== false) {
                    reject === null || reject === void 0 ? void 0 : reject();
                }
            }, onOk: function (e) { return form_dialog_awaiter(_this, void 0, void 0, function () {
                var _a;
                return form_dialog_generator(this, function (_b) {
                    if (((_a = modal === null || modal === void 0 ? void 0 : modal.onOk) === null || _a === void 0 ? void 0 : _a.call(modal, e)) !== false) {
                        resolve === null || resolve === void 0 ? void 0 : resolve();
                    }
                    return [2 /*return*/];
                });
            }); } }),
            external_React_default().createElement(FormProvider, { form: form },
                external_React_default().createElement(DialogContent, null)))); }));
    };
    document.body.appendChild(env.host);
    var formDialog = {
        forOpen: function (middleware) {
            if (checkers_isFn(middleware)) {
                env.openMiddlewares.push(middleware);
            }
            return formDialog;
        },
        forConfirm: function (middleware) {
            if (checkers_isFn(middleware)) {
                env.confirmMiddlewares.push(middleware);
            }
            return formDialog;
        },
        forCancel: function (middleware) {
            if (checkers_isFn(middleware)) {
                env.cancelMiddlewares.push(middleware);
            }
            return formDialog;
        },
        open: function (props) { return form_dialog_awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return form_dialog_generator(this, function (_a) {
                if (env.promise)
                    return [2 /*return*/, env.promise];
                env.promise = new Promise(function (resolve, reject) { return form_dialog_awaiter(_this, void 0, void 0, function () {
                    var e_1;
                    var _this = this;
                    return form_dialog_generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, loading(modal.loadingText, function () {
                                        return applyMiddleware(props, env.openMiddlewares);
                                    })];
                            case 1:
                                props = _a.sent();
                                env.form = env.form || createForm(props);
                                return [3 /*break*/, 3];
                            case 2:
                                e_1 = _a.sent();
                                reject(e_1);
                                return [3 /*break*/, 3];
                            case 3:
                                root.render(function () {
                                    return renderDialog(true, function () {
                                        var _a;
                                        (_a = env.form) === null || _a === void 0 ? void 0 : _a.submit(function () { return form_dialog_awaiter(_this, void 0, void 0, function () {
                                            var _a;
                                            return form_dialog_generator(this, function (_b) {
                                                switch (_b.label) {
                                                    case 0: return [4 /*yield*/, applyMiddleware(env.form, env.confirmMiddlewares)];
                                                    case 1:
                                                        _b.sent();
                                                        resolve(toJS((_a = env.form) === null || _a === void 0 ? void 0 : _a.values));
                                                        formDialog.close();
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); }).catch(function () { });
                                    }, function () { return form_dialog_awaiter(_this, void 0, void 0, function () {
                                        return form_dialog_generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, loading(modal.loadingText, function () {
                                                        return applyMiddleware(env.form, env.cancelMiddlewares);
                                                    })];
                                                case 1:
                                                    _a.sent();
                                                    formDialog.close();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                });
                                return [2 /*return*/];
                        }
                    });
                }); });
                return [2 /*return*/, env.promise];
            });
        }); },
        close: function () {
            if (!env.host)
                return;
            root.render(function () { return renderDialog(false); });
        },
    };
    return formDialog;
}
var DialogFooter = function (props) {
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var _a = form_dialog_read((0,external_React_namespaceObject.useState)(), 2), footer = _a[0], setFooter = _a[1];
    var footerRef = (0,external_React_namespaceObject.useRef)();
    var prefixCls = usePrefixCls('modal');
    (0,external_React_namespaceObject.useLayoutEffect)(function () {
        var _a;
        var content = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.closest(".".concat(prefixCls, "-content"));
        if (content) {
            if (!footerRef.current) {
                footerRef.current = content.querySelector(".".concat(prefixCls, "-footer"));
                if (!footerRef.current) {
                    footerRef.current = document.createElement('div');
                    footerRef.current.classList.add("".concat(prefixCls, "-footer"));
                    content.appendChild(footerRef.current);
                }
            }
            setFooter(footerRef.current);
        }
    });
    footerRef.current = footer;
    return (external_React_default().createElement("div", { ref: ref, style: { display: 'none' } }, footer && (0,external_ReactDOM_.createPortal)(props.children, footer)));
};
FormDialog.Footer = DialogFooter;
FormDialog.Portal = createPortalProvider('form-dialog');
/* harmony default export */ const form_dialog = ((/* unused pure expression or super */ null && (FormDialog)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-drawer/index.js
var form_drawer_assign = (undefined && undefined.__assign) || function () {
    form_drawer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_drawer_assign.apply(this, arguments);
};
var form_drawer_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var form_drawer_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var form_drawer_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};








var isDrawerTitle = function (props) {
    return (isNum(props) || checkers_isStr(props) || isBool(props) || external_React_default().isValidElement(props));
};
var getDrawerProps = function (props) {
    if (isDrawerTitle(props)) {
        return {
            title: props,
        };
    }
    else {
        return props;
    }
};
function FormDrawer(title, id, renderer) {
    var _this = this;
    if (checkers_isFn(id) || external_React_default().isValidElement(id)) {
        renderer = id;
        id = 'form-drawer';
    }
    var env = {
        host: document.createElement('div'),
        openMiddlewares: [],
        form: null,
        promise: null,
    };
    var root = createPortalRoot(env.host, id);
    var props = getDrawerProps(title);
    var drawer = form_drawer_assign(form_drawer_assign({ width: '40%' }, props), { onClose: function (e) {
            var _a;
            if (((_a = props === null || props === void 0 ? void 0 : props.onClose) === null || _a === void 0 ? void 0 : _a.call(props, e)) !== false) {
                formDrawer.close();
            }
        }, afterOpenChange: function (open) {
            var _a;
            (_a = props === null || props === void 0 ? void 0 : props.afterOpenChange) === null || _a === void 0 ? void 0 : _a.call(props, open);
            if (open)
                return;
            root.unmount();
        } });
    var DrawerContent = observer(function () {
        return external_React_default().createElement(external_React_namespaceObject.Fragment, null, checkers_isFn(renderer) ? renderer(env.form) : renderer);
    });
    var renderDrawer = function (open) {
        if (open === void 0) { open = true; }
        var form = env.form;
        if (!form)
            return null;
        return (external_React_default().createElement(external_antd_namespaceObject.Drawer, form_drawer_assign({}, drawer, { open: open }),
            external_React_default().createElement(FormProvider, { form: form },
                external_React_default().createElement(DrawerContent, null))));
    };
    document.body.appendChild(env.host);
    var formDrawer = {
        forOpen: function (middleware) {
            if (checkers_isFn(middleware)) {
                env.openMiddlewares.push(middleware);
            }
            return formDrawer;
        },
        open: function (props) {
            if (env.promise)
                return env.promise;
            env.promise = new Promise(function (resolve, reject) { return form_drawer_awaiter(_this, void 0, void 0, function () {
                var e_1;
                return form_drawer_generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, loading(drawer.loadingText, function () {
                                    return applyMiddleware(props, env.openMiddlewares);
                                })];
                        case 1:
                            props = _a.sent();
                            env.form =
                                env.form ||
                                    createForm(form_drawer_assign(form_drawer_assign({}, props), { effects: function (form) {
                                            var _a;
                                            onFormSubmitSuccess(function () {
                                                resolve(toJS(form.values));
                                                formDrawer.close();
                                            });
                                            (_a = props === null || props === void 0 ? void 0 : props.effects) === null || _a === void 0 ? void 0 : _a.call(props, form);
                                        } }));
                            return [3 /*break*/, 3];
                        case 2:
                            e_1 = _a.sent();
                            reject(e_1);
                            return [3 /*break*/, 3];
                        case 3:
                            root.render(function () { return renderDrawer(false); });
                            setTimeout(function () {
                                root.render(function () { return renderDrawer(true); });
                            }, 16);
                            return [2 /*return*/];
                    }
                });
            }); });
            return env.promise;
        },
        close: function () {
            if (!env.host)
                return;
            root.render(function () { return renderDrawer(false); });
        },
    };
    return formDrawer;
}
var DrawerExtra = function (props) {
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var _a = form_drawer_read((0,external_React_namespaceObject.useState)(), 2), extra = _a[0], setExtra = _a[1];
    var extraRef = (0,external_React_namespaceObject.useRef)();
    var prefixCls = usePrefixCls('drawer');
    (0,external_React_namespaceObject.useLayoutEffect)(function () {
        var _a, _b;
        var content = (_b = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.closest(".".concat(prefixCls, "-content"))) === null || _b === void 0 ? void 0 : _b.querySelector(".".concat(prefixCls, "-header"));
        if (content) {
            if (!extraRef.current) {
                extraRef.current = content.querySelector(".".concat(prefixCls, "-extra"));
                if (!extraRef.current) {
                    extraRef.current = document.createElement('div');
                    extraRef.current.classList.add("".concat(prefixCls, "-extra"));
                    content.appendChild(extraRef.current);
                }
            }
            setExtra(extraRef.current);
        }
    });
    extraRef.current = extra;
    return (external_React_default().createElement("div", { ref: ref, style: { display: 'none' } }, extra && (0,external_ReactDOM_.createPortal)(props.children, extra)));
};
var DrawerFooter = function (props) {
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var _a = form_drawer_read((0,external_React_namespaceObject.useState)(), 2), footer = _a[0], setFooter = _a[1];
    var footerRef = (0,external_React_namespaceObject.useRef)();
    var prefixCls = usePrefixCls('drawer');
    (0,external_React_namespaceObject.useLayoutEffect)(function () {
        var _a;
        var content = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.closest(".".concat(prefixCls, "-content"));
        if (content) {
            if (!footerRef.current) {
                footerRef.current = content.querySelector(".".concat(prefixCls, "-footer"));
                if (!footerRef.current) {
                    footerRef.current = document.createElement('div');
                    footerRef.current.classList.add("".concat(prefixCls, "-footer"));
                    content.appendChild(footerRef.current);
                }
            }
            setFooter(footerRef.current);
        }
    });
    footerRef.current = footer;
    return (external_React_default().createElement("div", { ref: ref, style: { display: 'none' } }, footer && (0,external_ReactDOM_.createPortal)(props.children, footer)));
};
FormDrawer.Extra = DrawerExtra;
FormDrawer.Footer = DrawerFooter;
FormDrawer.Portal = createPortalProvider('form-drawer');
/* harmony default export */ const form_drawer = ((/* unused pure expression or super */ null && (FormDrawer)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/checkers.js
var reactive_esm_checkers_toString = Object.prototype.toString;
var esm_checkers_isMap = function (val) {
    return val && val instanceof Map;
};
var esm_checkers_isSet = function (val) { return val && val instanceof Set; };
var esm_checkers_isWeakMap = function (val) {
    return val && val instanceof WeakMap;
};
var esm_checkers_isWeakSet = function (val) {
    return val && val instanceof WeakSet;
};
var reactive_esm_checkers_isFn = function (val) { return typeof val === 'function'; };
var reactive_esm_checkers_isArr = Array.isArray;
var reactive_esm_checkers_isPlainObj = function (val) {
    return reactive_esm_checkers_toString.call(val) === '[object Object]';
};
var esm_checkers_isValid = function (val) { return val !== null && val !== undefined; };
var checkers_isCollectionType = function (target) {
    return (esm_checkers_isMap(target) || esm_checkers_isWeakMap(target) || esm_checkers_isSet(target) || esm_checkers_isWeakSet(target));
};
var checkers_isNormalType = function (target) {
    return reactive_esm_checkers_isPlainObj(target) || reactive_esm_checkers_isArr(target);
};
//# sourceMappingURL=checkers.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/array.js
var array_toArray = function (value) {
    return Array.isArray(value)
        ? value
        : value !== undefined && value !== null
            ? [value]
            : [];
};
var array_ArraySet = /** @class */ (function () {
    function ArraySet(value) {
        if (value === void 0) { value = []; }
        this.forEachIndex = 0;
        this.value = value;
    }
    ArraySet.prototype.add = function (item) {
        if (!this.has(item)) {
            this.value.push(item);
        }
    };
    ArraySet.prototype.has = function (item) {
        return this.value.indexOf(item) > -1;
    };
    ArraySet.prototype.delete = function (item) {
        var len = this.value.length;
        if (len === 0)
            return;
        if (len === 1 && this.value[0] === item) {
            this.value = [];
            return;
        }
        var findIndex = this.value.indexOf(item);
        if (findIndex > -1) {
            this.value.splice(findIndex, 1);
            if (findIndex <= this.forEachIndex) {
                this.forEachIndex -= 1;
            }
        }
    };
    ArraySet.prototype.forEach = function (callback) {
        if (this.value.length === 0)
            return;
        this.forEachIndex = 0;
        for (; this.forEachIndex < this.value.length; this.forEachIndex++) {
            callback(this.value[this.forEachIndex]);
        }
    };
    ArraySet.prototype.batchDelete = function (callback) {
        if (this.value.length === 0)
            return;
        this.forEachIndex = 0;
        for (; this.forEachIndex < this.value.length; this.forEachIndex++) {
            var value = this.value[this.forEachIndex];
            this.value.splice(this.forEachIndex, 1);
            this.forEachIndex--;
            callback(value);
        }
    };
    ArraySet.prototype.clear = function () {
        this.value.length = 0;
    };
    return ArraySet;
}());

//# sourceMappingURL=array.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/environment.js

var environment_ProxyRaw = new WeakMap();
var environment_RawProxy = new WeakMap();
var environment_RawShallowProxy = new WeakMap();
var environment_RawNode = new WeakMap();
var environment_RawReactionsMap = new WeakMap();
var environment_ReactionStack = [];
var environment_BatchCount = { value: 0 };
var environment_UntrackCount = { value: 0 };
var environment_BatchScope = { value: false };
var esm_environment_DependencyCollected = { value: false };
var environment_PendingReactions = new array_ArraySet();
var environment_PendingScopeReactions = new array_ArraySet();
var environment_BatchEndpoints = new array_ArraySet();
var esm_environment_ObserverListeners = new array_ArraySet();
var environment_MakeObModelSymbol = Symbol('MakeObModelSymbol');
var environment_ObModelSymbol = Symbol('ObModelSymbol');
var environment_ObModelNodeSymbol = Symbol('ObModelNodeSymbol');
//# sourceMappingURL=environment.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/reaction.js



var reaction_ITERATION_KEY = Symbol('iteration key');
var reaction_addRawReactionsMap = function (target, key, reaction) {
    var reactionsMap = environment_RawReactionsMap.get(target);
    if (reactionsMap) {
        var reactions = reactionsMap.get(key);
        if (reactions) {
            reactions.add(reaction);
        }
        else {
            reactionsMap.set(key, new array_ArraySet([reaction]));
        }
        return reactionsMap;
    }
    else {
        var reactionsMap_1 = new Map([
            [key, new array_ArraySet([reaction])],
        ]);
        environment_RawReactionsMap.set(target, reactionsMap_1);
        return reactionsMap_1;
    }
};
var reaction_addReactionsMapToReaction = function (reaction, reactionsMap) {
    var bindSet = reaction._reactionsSet;
    if (bindSet) {
        bindSet.add(reactionsMap);
    }
    else {
        reaction._reactionsSet = new array_ArraySet([reactionsMap]);
    }
    return bindSet;
};
var reaction_getReactionsFromTargetKey = function (target, key) {
    var reactionsMap = environment_RawReactionsMap.get(target);
    var reactions = [];
    if (reactionsMap) {
        var map = reactionsMap.get(key);
        if (map) {
            map.forEach(function (reaction) {
                if (reactions.indexOf(reaction) === -1) {
                    reactions.push(reaction);
                }
            });
        }
    }
    return reactions;
};
var reaction_runReactions = function (target, key) {
    var reactions = reaction_getReactionsFromTargetKey(target, key);
    var prevUntrackCount = environment_UntrackCount.value;
    environment_UntrackCount.value = 0;
    for (var i = 0, len = reactions.length; i < len; i++) {
        var reaction = reactions[i];
        if (reaction._isComputed) {
            reaction._scheduler(reaction);
        }
        else if (reaction_isScopeBatching()) {
            environment_PendingScopeReactions.add(reaction);
        }
        else if (reaction_isBatching()) {
            environment_PendingReactions.add(reaction);
        }
        else {
            if (reactive_esm_checkers_isFn(reaction._scheduler)) {
                reaction._scheduler(reaction);
            }
            else {
                reaction();
            }
        }
    }
    environment_UntrackCount.value = prevUntrackCount;
};
var reaction_notifyObservers = function (operation) {
    esm_environment_ObserverListeners.forEach(function (fn) { return fn(operation); });
};
var reaction_bindTargetKeyWithCurrentReaction = function (operation) {
    var key = operation.key, type = operation.type, target = operation.target;
    if (type === 'iterate') {
        key = reaction_ITERATION_KEY;
    }
    var reactionLen = environment_ReactionStack.length;
    if (reactionLen === 0)
        return;
    var current = environment_ReactionStack[reactionLen - 1];
    if (reaction_isUntracking())
        return;
    if (current) {
        esm_environment_DependencyCollected.value = true;
        reaction_addReactionsMapToReaction(current, reaction_addRawReactionsMap(target, key, current));
    }
};
var reaction_bindComputedReactions = function (reaction) {
    if (reactive_esm_checkers_isFn(reaction)) {
        var current = environment_ReactionStack[environment_ReactionStack.length - 1];
        if (current) {
            var computes = current._computesSet;
            if (computes) {
                computes.add(reaction);
            }
            else {
                current._computesSet = new array_ArraySet([reaction]);
            }
        }
    }
};
var reaction_runReactionsFromTargetKey = function (operation) {
    var key = operation.key, type = operation.type, target = operation.target, oldTarget = operation.oldTarget;
    reaction_batchStart();
    reaction_notifyObservers(operation);
    if (type === 'clear') {
        oldTarget.forEach(function (_, key) {
            reaction_runReactions(target, key);
        });
    }
    else {
        reaction_runReactions(target, key);
    }
    if (type === 'add' || type === 'delete' || type === 'clear') {
        var newKey = Array.isArray(target) ? 'length' : reaction_ITERATION_KEY;
        reaction_runReactions(target, newKey);
    }
    reaction_batchEnd();
};
var reaction_hasRunningReaction = function () {
    return environment_ReactionStack.length > 0;
};
var reaction_releaseBindingReactions = function (reaction) {
    var _a;
    (_a = reaction._reactionsSet) === null || _a === void 0 ? void 0 : _a.forEach(function (reactionsMap) {
        reactionsMap.forEach(function (reactions) {
            reactions.delete(reaction);
        });
    });
    environment_PendingReactions.delete(reaction);
    environment_PendingScopeReactions.delete(reaction);
    delete reaction._reactionsSet;
};
var reaction_suspendComputedReactions = function (current) {
    var _a;
    (_a = current._computesSet) === null || _a === void 0 ? void 0 : _a.forEach(function (reaction) {
        var reactions = reaction_getReactionsFromTargetKey(reaction._context, reaction._property);
        if (reactions.length === 0) {
            reaction_disposeBindingReactions(reaction);
            reaction._dirty = true;
        }
    });
};
var reaction_disposeBindingReactions = function (reaction) {
    reaction._disposed = true;
    reaction_releaseBindingReactions(reaction);
    reaction_suspendComputedReactions(reaction);
};
var reaction_batchStart = function () {
    environment_BatchCount.value++;
};
var reaction_batchEnd = function () {
    environment_BatchCount.value--;
    if (environment_BatchCount.value === 0) {
        var prevUntrackCount = environment_UntrackCount.value;
        environment_UntrackCount.value = 0;
        reaction_executePendingReactions();
        reaction_executeBatchEndpoints();
        environment_UntrackCount.value = prevUntrackCount;
    }
};
var reaction_batchScopeStart = function () {
    environment_BatchScope.value = true;
};
var reaction_batchScopeEnd = function () {
    var prevUntrackCount = environment_UntrackCount.value;
    environment_BatchScope.value = false;
    environment_UntrackCount.value = 0;
    environment_PendingScopeReactions.batchDelete(function (reaction) {
        if (reactive_esm_checkers_isFn(reaction._scheduler)) {
            reaction._scheduler(reaction);
        }
        else {
            reaction();
        }
    });
    environment_UntrackCount.value = prevUntrackCount;
};
var reaction_untrackStart = function () {
    environment_UntrackCount.value++;
};
var reaction_untrackEnd = function () {
    environment_UntrackCount.value--;
};
var reaction_isBatching = function () { return environment_BatchCount.value > 0; };
var reaction_isScopeBatching = function () { return environment_BatchScope.value; };
var reaction_isUntracking = function () { return environment_UntrackCount.value > 0; };
var reaction_executePendingReactions = function () {
    environment_PendingReactions.batchDelete(function (reaction) {
        if (reactive_esm_checkers_isFn(reaction._scheduler)) {
            reaction._scheduler(reaction);
        }
        else {
            reaction();
        }
    });
};
var reaction_executeBatchEndpoints = function () {
    environment_BatchEndpoints.batchDelete(function (callback) {
        callback();
    });
};
var reaction_hasDepsChange = function (newDeps, oldDeps) {
    if (newDeps === oldDeps)
        return false;
    if (newDeps.length !== oldDeps.length)
        return true;
    if (newDeps.some(function (value, index) { return value !== oldDeps[index]; }))
        return true;
    return false;
};
var reaction_disposeEffects = function (reaction) {
    if (reaction._effects) {
        try {
            reaction_batchStart();
            reaction._effects.queue.forEach(function (item) {
                if (!item || !item.dispose)
                    return;
                item.dispose();
            });
        }
        finally {
            reaction_batchEnd();
        }
    }
};
//# sourceMappingURL=reaction.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/tree.js


var esm_tree_DataChange = /** @class */ (function () {
    function DataChange(operation, node) {
        this.node = node;
        this.key = operation.key;
        this.type = operation.type;
        this.object = operation.target;
        this.value = operation.value;
        this.oldValue = operation.oldValue;
    }
    Object.defineProperty(DataChange.prototype, "path", {
        get: function () {
            return this.node.path.concat(this.key);
        },
        enumerable: false,
        configurable: true
    });
    return DataChange;
}());

var tree_DataNode = /** @class */ (function () {
    function DataNode(target, key, value) {
        this.target = target;
        this.key = key;
        this.value = value;
    }
    Object.defineProperty(DataNode.prototype, "path", {
        get: function () {
            if (!this.parent)
                return this.key ? [this.key] : [];
            return this.parent.path.concat(this.key);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataNode.prototype, "targetRaw", {
        get: function () {
            return esm_externals_raw(this.target);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataNode.prototype, "parent", {
        get: function () {
            if (!this.target)
                return;
            return esm_tree_getDataNode(this.targetRaw);
        },
        enumerable: false,
        configurable: true
    });
    DataNode.prototype.isEqual = function (node) {
        if (this.key) {
            return node.targetRaw === this.targetRaw && node.key === this.key;
        }
        return node.value === this.value;
    };
    DataNode.prototype.contains = function (node) {
        if (node === this)
            return true;
        var parent = node.parent;
        while (!!parent) {
            if (this.isEqual(parent))
                return true;
            parent = parent.parent;
        }
        return false;
    };
    return DataNode;
}());

var esm_tree_getDataNode = function (raw) {
    if (raw === null || raw === void 0 ? void 0 : raw[environment_ObModelNodeSymbol]) {
        return raw[environment_ObModelNodeSymbol];
    }
    return environment_RawNode.get(raw);
};
var tree_setDataNode = function (raw, node) {
    if (raw === null || raw === void 0 ? void 0 : raw[environment_ObModelSymbol]) {
        raw[environment_ObModelNodeSymbol] = node;
        return;
    }
    environment_RawNode.set(raw, node);
};
var tree_buildDataTree = function (target, key, value) {
    var raw = esm_externals_raw(value);
    var currentNode = esm_tree_getDataNode(raw);
    if (currentNode)
        return currentNode;
    tree_setDataNode(raw, new tree_DataNode(target, key, value));
};
//# sourceMappingURL=tree.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/externals.js



var externals_RAW_TYPE = Symbol('RAW_TYPE');
var externals_OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE');
var esm_externals_hasOwnProperty = Object.prototype.hasOwnProperty;
var externals_isObservable = function (target) {
    return environment_ProxyRaw.has(target) || !!(target === null || target === void 0 ? void 0 : target[environment_ObModelSymbol]);
};
var externals_isAnnotation = function (target) {
    return target && !!target[environment_MakeObModelSymbol];
};
var externals_isSupportObservable = function (target) {
    if (!esm_checkers_isValid(target))
        return false;
    if (reactive_esm_checkers_isArr(target))
        return true;
    if (reactive_esm_checkers_isPlainObj(target)) {
        if (target[externals_RAW_TYPE]) {
            return false;
        }
        if (target[externals_OBSERVABLE_TYPE]) {
            return true;
        }
        if ('$$typeof' in target && '_owner' in target) {
            return false;
        }
        if (target['_isAMomentObject']) {
            return false;
        }
        if (target['_isJSONSchemaObject']) {
            return false;
        }
        if (reactive_esm_checkers_isFn(target['toJS'])) {
            return false;
        }
        if (reactive_esm_checkers_isFn(target['toJSON'])) {
            return false;
        }
        return true;
    }
    if (esm_checkers_isMap(target) || esm_checkers_isWeakMap(target) || esm_checkers_isSet(target) || esm_checkers_isWeakSet(target))
        return true;
    return false;
};
var externals_markRaw = function (target) {
    if (!target)
        return;
    if (isFn(target)) {
        target.prototype[externals_RAW_TYPE] = true;
    }
    else {
        target[externals_RAW_TYPE] = true;
    }
    return target;
};
var externals_markObservable = function (target) {
    if (!target)
        return;
    if (isFn(target)) {
        target.prototype[externals_OBSERVABLE_TYPE] = true;
    }
    else {
        target[externals_OBSERVABLE_TYPE] = true;
    }
    return target;
};
var esm_externals_raw = function (target) {
    if (target === null || target === void 0 ? void 0 : target[environment_ObModelSymbol])
        return target[environment_ObModelSymbol];
    return environment_ProxyRaw.get(target) || target;
};
var externals_toJS = function (values) {
    var visited = new WeakSet();
    var _toJS = function (values) {
        if (visited.has(values)) {
            return values;
        }
        if (values && values[externals_RAW_TYPE])
            return values;
        if (isArr(values)) {
            if (externals_isObservable(values)) {
                visited.add(values);
                var res_1 = [];
                values.forEach(function (item) {
                    res_1.push(_toJS(item));
                });
                visited.delete(values);
                return res_1;
            }
        }
        else if (isPlainObj(values)) {
            if (externals_isObservable(values)) {
                visited.add(values);
                var res = {};
                for (var key in values) {
                    if (esm_externals_hasOwnProperty.call(values, key)) {
                        res[key] = _toJS(values[key]);
                    }
                }
                visited.delete(values);
                return res;
            }
        }
        return values;
    };
    return _toJS(values);
};
var externals_contains = function (target, property) {
    var targetRaw = esm_externals_raw(target);
    var propertyRaw = esm_externals_raw(property);
    if (targetRaw === propertyRaw)
        return true;
    var targetNode = getDataNode(targetRaw);
    var propertyNode = getDataNode(propertyRaw);
    if (!targetNode)
        return false;
    if (!propertyNode)
        return false;
    return targetNode.contains(propertyNode);
};
var externals_hasCollected = function (callback) {
    DependencyCollected.value = false;
    callback === null || callback === void 0 ? void 0 : callback();
    return DependencyCollected.value;
};
//# sourceMappingURL=externals.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/handlers.js
var esm_handlers_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var esm_handlers_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var handlers_a;




var handlers_wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .reduce(function (buf, key) {
    if (key === 'arguments' || key === 'caller')
        return buf;
    var value = Symbol[key];
    if (typeof value === 'symbol')
        return buf.concat(value);
    return buf;
}, []));
var esm_handlers_hasOwnProperty = Object.prototype.hasOwnProperty;
function handlers_findObservable(target, key, value) {
    var observableObj = environment_RawProxy.get(value);
    if (observableObj) {
        return observableObj;
    }
    if (!externals_isObservable(value) && externals_isSupportObservable(value)) {
        return internals_createObservable(target, key, value);
    }
    return value;
}
function handlers_patchIterator(target, key, iterator, isEntries) {
    var originalNext = iterator.next;
    iterator.next = function () {
        var _a = originalNext.call(iterator), done = _a.done, value = _a.value;
        if (!done) {
            if (isEntries) {
                value[1] = handlers_findObservable(target, key, value[1]);
            }
            else {
                value = handlers_findObservable(target, key, value);
            }
        }
        return { done: done, value: value };
    };
    return iterator;
}
var handlers_instrumentations = (handlers_a = {
        has: function (key) {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'has' });
            return proto.has.apply(target, arguments);
        },
        get: function (key) {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'get' });
            return handlers_findObservable(target, key, proto.get.apply(target, arguments));
        },
        add: function (key) {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadKey = proto.has.call(target, key);
            // forward the operation before queueing reactions
            var result = proto.add.apply(target, arguments);
            if (!hadKey) {
                reaction_runReactionsFromTargetKey({ target: target, key: key, value: key, type: 'add' });
            }
            return result;
        },
        set: function (key, value) {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadKey = proto.has.call(target, key);
            var oldValue = proto.get.call(target, key);
            // forward the operation before queueing reactions
            var result = proto.set.apply(target, arguments);
            if (!hadKey) {
                reaction_runReactionsFromTargetKey({ target: target, key: key, value: value, type: 'add' });
            }
            else if (value !== oldValue) {
                reaction_runReactionsFromTargetKey({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });
            }
            return result;
        },
        delete: function (key) {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadKey = proto.has.call(target, key);
            var oldValue = proto.get ? proto.get.call(target, key) : undefined;
            // forward the operation before queueing reactions
            var result = proto.delete.apply(target, arguments);
            if (hadKey) {
                reaction_runReactionsFromTargetKey({ target: target, key: key, oldValue: oldValue, type: 'delete' });
            }
            return result;
        },
        clear: function () {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            var hadItems = target.size !== 0;
            var oldTarget = target instanceof Map ? new Map(target) : new Set(target);
            // forward the operation before queueing reactions
            var result = proto.clear.apply(target, arguments);
            if (hadItems) {
                reaction_runReactionsFromTargetKey({ target: target, oldTarget: oldTarget, type: 'clear' });
            }
            return result;
        },
        forEach: function (cb) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            // swap out the raw values with their observable pairs
            // before passing them to the callback
            var wrappedCb = function (value, key) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                return cb.apply(void 0, esm_handlers_spreadArray([handlers_findObservable(target, key, value), key], esm_handlers_read(args), false));
            };
            return (_a = proto.forEach).call.apply(_a, esm_handlers_spreadArray([target, wrappedCb], esm_handlers_read(args), false));
        },
        keys: function () {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            return proto.keys.apply(target, arguments);
        },
        values: function () {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            var iterator = proto.values.apply(target, arguments);
            return handlers_patchIterator(target, '', iterator, false);
        },
        entries: function () {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            var iterator = proto.entries.apply(target, arguments);
            return handlers_patchIterator(target, '', iterator, true);
        }
    },
    handlers_a[Symbol.iterator] = function () {
        var target = environment_ProxyRaw.get(this);
        var proto = Reflect.getPrototypeOf(this);
        reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
        var iterator = proto[Symbol.iterator].apply(target, arguments);
        return handlers_patchIterator(target, '', iterator, target instanceof Map);
    },
    Object.defineProperty(handlers_a, "size", {
        get: function () {
            var target = environment_ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            return Reflect.get(proto, 'size', target);
        },
        enumerable: false,
        configurable: true
    }),
    handlers_a);
var handlers_collectionHandlers = {
    get: function (target, key, receiver) {
        // instrument methods and property accessors to be reactive
        target = esm_handlers_hasOwnProperty.call(handlers_instrumentations, key)
            ? handlers_instrumentations
            : target;
        return Reflect.get(target, key, receiver);
    },
};
var handlers_baseHandlers = {
    get: function (target, key, receiver) {
        if (!key)
            return;
        var result = target[key]; // use Reflect.get is too slow
        if (typeof key === 'symbol' && handlers_wellKnownSymbols.has(key)) {
            return result;
        }
        reaction_bindTargetKeyWithCurrentReaction({ target: target, key: key, receiver: receiver, type: 'get' });
        var observableResult = environment_RawProxy.get(result);
        if (observableResult) {
            return observableResult;
        }
        if (!externals_isObservable(result) && externals_isSupportObservable(result)) {
            var descriptor = Reflect.getOwnPropertyDescriptor(target, key);
            if (!descriptor ||
                !(descriptor.writable === false && descriptor.configurable === false)) {
                return internals_createObservable(target, key, result);
            }
        }
        return result;
    },
    has: function (target, key) {
        var result = Reflect.has(target, key);
        reaction_bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'has' });
        return result;
    },
    ownKeys: function (target) {
        var keys = Reflect.ownKeys(target);
        reaction_bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
        return keys;
    },
    set: function (target, key, value, receiver) {
        var hadKey = esm_handlers_hasOwnProperty.call(target, key);
        var newValue = internals_createObservable(target, key, value);
        var oldValue = target[key];
        target[key] = newValue; // use Reflect.set is too slow
        if (!hadKey) {
            reaction_runReactionsFromTargetKey({
                target: target,
                key: key,
                value: newValue,
                oldValue: oldValue,
                receiver: receiver,
                type: 'add',
            });
        }
        else if (value !== oldValue) {
            reaction_runReactionsFromTargetKey({
                target: target,
                key: key,
                value: newValue,
                oldValue: oldValue,
                receiver: receiver,
                type: 'set',
            });
        }
        return true;
    },
    deleteProperty: function (target, key) {
        var oldValue = target[key];
        delete target[key];
        reaction_runReactionsFromTargetKey({
            target: target,
            key: key,
            oldValue: oldValue,
            type: 'delete',
        });
        return true;
    },
};
//# sourceMappingURL=handlers.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/internals.js





var internals_createNormalProxy = function (target, shallow) {
    var proxy = new Proxy(target, handlers_baseHandlers);
    environment_ProxyRaw.set(proxy, target);
    if (shallow) {
        environment_RawShallowProxy.set(target, proxy);
    }
    else {
        environment_RawProxy.set(target, proxy);
    }
    return proxy;
};
var internals_createCollectionProxy = function (target, shallow) {
    var proxy = new Proxy(target, handlers_collectionHandlers);
    environment_ProxyRaw.set(proxy, target);
    if (shallow) {
        environment_RawShallowProxy.set(target, proxy);
    }
    else {
        environment_RawProxy.set(target, proxy);
    }
    return proxy;
};
var internals_createShallowProxy = function (target) {
    if (checkers_isNormalType(target))
        return internals_createNormalProxy(target, true);
    if (checkers_isCollectionType(target))
        return internals_createCollectionProxy(target, true);
    return target;
};
var internals_createObservable = function (target, key, value, shallow) {
    if (typeof value !== 'object')
        return value;
    var raw = environment_ProxyRaw.get(value);
    if (!!raw) {
        var node = esm_tree_getDataNode(raw);
        if (!node.target)
            node.target = target;
        node.key = key;
        return value;
    }
    if (!externals_isSupportObservable(value))
        return value;
    if (target) {
        var parentRaw = environment_ProxyRaw.get(target) || target;
        var isShallowParent = environment_RawShallowProxy.get(parentRaw);
        if (isShallowParent)
            return value;
    }
    tree_buildDataTree(target, key, value);
    if (shallow)
        return internals_createShallowProxy(value);
    if (checkers_isNormalType(value))
        return internals_createNormalProxy(value);
    if (checkers_isCollectionType(value))
        return internals_createCollectionProxy(value);
    return value;
};
var internals_createAnnotation = function (maker) {
    var annotation = function (target) {
        return maker({ value: target });
    };
    if (reactive_esm_checkers_isFn(maker)) {
        annotation[environment_MakeObModelSymbol] = maker;
    }
    return annotation;
};
var internals_getObservableMaker = function (target) {
    if (target[environment_MakeObModelSymbol]) {
        if (!target[environment_MakeObModelSymbol][environment_MakeObModelSymbol]) {
            return target[environment_MakeObModelSymbol];
        }
        return internals_getObservableMaker(target[environment_MakeObModelSymbol]);
    }
};
var internals_createBoundaryFunction = function (start, end) {
    function boundary(fn) {
        var results;
        try {
            start();
            if (reactive_esm_checkers_isFn(fn)) {
                results = fn();
            }
        }
        finally {
            end();
        }
        return results;
    }
    boundary.bound = internals_createBindFunction(boundary);
    return boundary;
};
var internals_createBindFunction = function (boundary) {
    function bind(callback, context) {
        return (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return boundary(function () { return callback.apply(context, args); });
        });
    }
    return bind;
};
var internals_createBoundaryAnnotation = function (start, end) {
    var boundary = internals_createBoundaryFunction(start, end);
    var annotation = internals_createAnnotation(function (_a) {
        var target = _a.target, key = _a.key;
        target[key] = boundary.bound(target[key], target);
        return target;
    });
    boundary[environment_MakeObModelSymbol] = annotation;
    boundary.bound[environment_MakeObModelSymbol] = annotation;
    return boundary;
};
//# sourceMappingURL=internals.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/batch.js




var batch_batch = internals_createBoundaryAnnotation(reaction_batchStart, reaction_batchEnd);
batch_batch.scope = internals_createBoundaryAnnotation(reaction_batchScopeStart, reaction_batchScopeEnd);
batch_batch.endpoint = function (callback) {
    if (!reactive_esm_checkers_isFn(callback))
        return;
    if (environment_BatchCount.value === 0) {
        callback();
    }
    else {
        environment_BatchEndpoints.add(callback);
    }
};
//# sourceMappingURL=batch.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/action.js


var esm_action_action = internals_createBoundaryAnnotation(function () {
    reaction_batchStart();
    reaction_untrackStart();
}, function () {
    reaction_untrackEnd();
    reaction_batchEnd();
});
esm_action_action.scope = internals_createBoundaryAnnotation(function () {
    reaction_batchScopeStart();
    reaction_untrackStart();
}, function () {
    reaction_untrackEnd();
    reaction_batchScopeEnd();
});
//# sourceMappingURL=action.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/untracked.js


var untracked_untracked = internals_createBoundaryFunction(reaction_untrackStart, reaction_untrackEnd);
//# sourceMappingURL=untracked.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/annotations/observable.js


var annotations_observable_observable = internals_createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: internals_createObservable(target, key, target ? target[key] : value),
    };
    function get() {
        reaction_bindTargetKeyWithCurrentReaction({
            target: target,
            key: key,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        value = internals_createObservable(target, key, value);
        store.value = value;
        if (oldValue === value)
            return;
        reaction_runReactionsFromTargetKey({
            target: target,
            key: key,
            type: 'set',
            oldValue: oldValue,
            value: value,
        });
    }
    if (target) {
        Object.defineProperty(target, key, {
            set: set,
            get: get,
            enumerable: true,
            configurable: false,
        });
        return target;
    }
    return store.value;
});
//# sourceMappingURL=observable.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/annotations/box.js




var box_box = internals_createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: target ? target[key] : value,
    };
    var proxy = {
        set: set,
        get: get,
    };
    environment_ProxyRaw.set(proxy, store);
    environment_RawProxy.set(store, proxy);
    tree_buildDataTree(target, key, store);
    function get() {
        reaction_bindTargetKeyWithCurrentReaction({
            target: store,
            key: key,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        store.value = value;
        if (oldValue !== value) {
            reaction_runReactionsFromTargetKey({
                target: store,
                key: key,
                type: 'set',
                oldValue: oldValue,
                value: value,
            });
        }
    }
    if (target) {
        Object.defineProperty(target, key, {
            value: proxy,
            enumerable: true,
            configurable: false,
            writable: false,
        });
        return target;
    }
    return proxy;
});
//# sourceMappingURL=box.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/annotations/ref.js




var ref_ref = internals_createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: target ? target[key] : value,
    };
    var proxy = {};
    var context = target ? target : store;
    var property = target ? key : 'value';
    function get() {
        reaction_bindTargetKeyWithCurrentReaction({
            target: context,
            key: property,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        store.value = value;
        if (oldValue !== value) {
            reaction_runReactionsFromTargetKey({
                target: context,
                key: property,
                type: 'set',
                oldValue: oldValue,
                value: value,
            });
        }
    }
    if (target) {
        Object.defineProperty(target, key, {
            get: get,
            set: set,
            enumerable: true,
        });
        return target;
    }
    else {
        Object.defineProperty(proxy, 'value', {
            set: set,
            get: get,
        });
        tree_buildDataTree(target, key, store);
        proxy[environment_ObModelSymbol] = store;
    }
    return proxy;
});
//# sourceMappingURL=ref.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/annotations/shallow.js


var shallow_shallow = internals_createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {
        value: internals_createObservable(target, key, target ? target[key] : value, true),
    };
    function get() {
        reaction_bindTargetKeyWithCurrentReaction({
            target: target,
            key: key,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var oldValue = store.value;
        value = internals_createObservable(target, key, value, true);
        store.value = value;
        if (oldValue === value)
            return;
        reaction_runReactionsFromTargetKey({
            target: target,
            key: key,
            type: 'set',
            oldValue: oldValue,
            value: value,
        });
    }
    if (target) {
        Object.defineProperty(target, key, {
            set: set,
            get: get,
            enumerable: true,
            configurable: false,
        });
        return target;
    }
    return store.value;
});
//# sourceMappingURL=shallow.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/annotations/computed.js





var computed_getDescriptor = Object.getOwnPropertyDescriptor;
var computed_getProto = Object.getPrototypeOf;
var computed_ClassDescriptorSymbol = Symbol('ClassDescriptorSymbol');
function computed_getPropertyDescriptor(obj, key) {
    if (!obj)
        return;
    return computed_getDescriptor(obj, key) || computed_getPropertyDescriptor(computed_getProto(obj), key);
}
function computed_getPropertyDescriptorCache(obj, key) {
    var constructor = obj.constructor;
    if (constructor === Object || constructor === Array)
        return computed_getPropertyDescriptor(obj, key);
    var cache = constructor[computed_ClassDescriptorSymbol] || {};
    var descriptor = cache[key];
    if (descriptor)
        return descriptor;
    var newDesc = computed_getPropertyDescriptor(obj, key);
    constructor[computed_ClassDescriptorSymbol] = cache;
    cache[key] = newDesc;
    return newDesc;
}
function computed_getPrototypeDescriptor(target, key, value) {
    if (!target) {
        if (value) {
            if (reactive_esm_checkers_isFn(value)) {
                return { get: value };
            }
            else {
                return value;
            }
        }
        return {};
    }
    var descriptor = computed_getPropertyDescriptorCache(target, key);
    if (descriptor) {
        return descriptor;
    }
    return {};
}
var computed_computed = internals_createAnnotation(function (_a) {
    var target = _a.target, key = _a.key, value = _a.value;
    var store = {};
    var proxy = {};
    var context = target ? target : store;
    var property = target ? key : 'value';
    var descriptor = computed_getPrototypeDescriptor(target, property, value);
    function compute() {
        var _a;
        store.value = (_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(context);
    }
    function reaction() {
        if (environment_ReactionStack.indexOf(reaction) === -1) {
            reaction_releaseBindingReactions(reaction);
            try {
                environment_ReactionStack.push(reaction);
                compute();
            }
            finally {
                environment_ReactionStack.pop();
            }
        }
    }
    reaction._name = 'ComputedReaction';
    reaction._scheduler = function () {
        reaction._dirty = true;
        reaction_runReactionsFromTargetKey({
            target: context,
            key: property,
            value: store.value,
            type: 'set',
        });
    };
    reaction._isComputed = true;
    reaction._dirty = true;
    reaction._context = context;
    reaction._property = property;
    function get() {
        if (reaction_hasRunningReaction()) {
            reaction_bindComputedReactions(reaction);
        }
        if (!reaction_isUntracking()) {
            //如果允许untracked过程中收集依赖，那么永远不会存在绑定，因为_dirty已经设置为false
            if (reaction._dirty) {
                reaction();
                reaction._dirty = false;
            }
        }
        else {
            compute();
        }
        reaction_bindTargetKeyWithCurrentReaction({
            target: context,
            key: property,
            type: 'get',
        });
        return store.value;
    }
    function set(value) {
        var _a;
        try {
            reaction_batchStart();
            (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call(context, value);
        }
        finally {
            reaction_batchEnd();
        }
    }
    if (target) {
        Object.defineProperty(target, key, {
            get: get,
            set: set,
            enumerable: true,
        });
        return target;
    }
    else {
        Object.defineProperty(proxy, 'value', {
            set: set,
            get: get,
        });
        tree_buildDataTree(target, key, store);
        proxy[environment_ObModelSymbol] = store;
    }
    return proxy;
});
//# sourceMappingURL=computed.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/annotations/index.js





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/observable.js



function reactive_esm_observable_observable(target) {
    return internals_createObservable(null, null, target);
}
reactive_esm_observable_observable.box = box_box;
reactive_esm_observable_observable.ref = ref_ref;
reactive_esm_observable_observable.deep = annotations_observable_observable;
reactive_esm_observable_observable.shallow = shallow_shallow;
reactive_esm_observable_observable.computed = computed_computed;
reactive_esm_observable_observable[environment_MakeObModelSymbol] = annotations_observable_observable;
//# sourceMappingURL=observable.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/model.js







function esm_model_define(target, annotations) {
    if (externals_isObservable(target))
        return target;
    if (!externals_isSupportObservable(target))
        return target;
    target[environment_ObModelSymbol] = target;
    tree_buildDataTree(undefined, undefined, target);
    for (var key in annotations) {
        var annotation = annotations[key];
        if (externals_isAnnotation(annotation)) {
            internals_getObservableMaker(annotation)({
                target: target,
                key: key,
            });
        }
    }
    return target;
}
function model_model(target) {
    var annotations = Object.keys(target || {}).reduce(function (buf, key) {
        var descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor && descriptor.get) {
            buf[key] = observable.computed;
        }
        else if (isFn(target[key])) {
            buf[key] = action;
        }
        else {
            buf[key] = observable;
        }
        return buf;
    }, {});
    return esm_model_define(target, annotations);
}
//# sourceMappingURL=model.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/autorun.js
var esm_autorun_assign = (undefined && undefined.__assign) || function () {
    esm_autorun_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return esm_autorun_assign.apply(this, arguments);
};




var autorun_autorun = function (tracker, name) {
    if (name === void 0) { name = 'AutoRun'; }
    var reaction = function () {
        if (!reactive_esm_checkers_isFn(tracker))
            return;
        if (reaction._boundary > 0)
            return;
        if (environment_ReactionStack.indexOf(reaction) === -1) {
            reaction_releaseBindingReactions(reaction);
            try {
                reaction_batchStart();
                environment_ReactionStack.push(reaction);
                tracker();
            }
            finally {
                environment_ReactionStack.pop();
                reaction._boundary++;
                reaction_batchEnd();
                reaction._boundary = 0;
                reaction._memos.cursor = 0;
                reaction._effects.cursor = 0;
            }
        }
    };
    var cleanRefs = function () {
        reaction._memos = {
            queue: [],
            cursor: 0,
        };
        reaction._effects = {
            queue: [],
            cursor: 0,
        };
    };
    reaction._boundary = 0;
    reaction._name = name;
    cleanRefs();
    reaction();
    return function () {
        reaction_disposeBindingReactions(reaction);
        reaction_disposeEffects(reaction);
        cleanRefs();
    };
};
autorun_autorun.memo = function (callback, dependencies) {
    if (!reactive_esm_checkers_isFn(callback))
        return;
    var current = environment_ReactionStack[environment_ReactionStack.length - 1];
    if (!current || !current._memos)
        throw new Error('autorun.memo must used in autorun function body.');
    var deps = array_toArray(dependencies || []);
    var id = current._memos.cursor++;
    var old = current._memos.queue[id];
    if (!old || reaction_hasDepsChange(deps, old.deps)) {
        var value = callback();
        current._memos.queue[id] = {
            value: value,
            deps: deps,
        };
        return value;
    }
    return old.value;
};
autorun_autorun.effect = function (callback, dependencies) {
    if (!reactive_esm_checkers_isFn(callback))
        return;
    var current = environment_ReactionStack[environment_ReactionStack.length - 1];
    if (!current || !current._effects)
        throw new Error('autorun.effect must used in autorun function body.');
    var effects = current._effects;
    var deps = array_toArray(dependencies || [{}]);
    var id = effects.cursor++;
    var old = effects.queue[id];
    if (!old || reaction_hasDepsChange(deps, old.deps)) {
        Promise.resolve(0).then(function () {
            if (current._disposed)
                return;
            var dispose = callback();
            if (reactive_esm_checkers_isFn(dispose)) {
                effects.queue[id].dispose = dispose;
            }
        });
        effects.queue[id] = {
            deps: deps,
        };
    }
};
var autorun_reaction = function (tracker, subscriber, options) {
    var realOptions = esm_autorun_assign({ name: 'Reaction' }, options);
    var value = {};
    var dirtyCheck = function () {
        if (reactive_esm_checkers_isFn(realOptions.equals))
            return !realOptions.equals(value.oldValue, value.currentValue);
        return value.oldValue !== value.currentValue;
    };
    var fireAction = function () {
        try {
            //如果untrack的话，会导致用户如果在scheduler里同步调用setState影响下次React渲染的依赖收集
            reaction_batchStart();
            if (reactive_esm_checkers_isFn(subscriber))
                subscriber(value.currentValue, value.oldValue);
        }
        finally {
            reaction_batchEnd();
        }
    };
    var reaction = function () {
        if (environment_ReactionStack.indexOf(reaction) === -1) {
            reaction_releaseBindingReactions(reaction);
            try {
                environment_ReactionStack.push(reaction);
                value.currentValue = tracker();
            }
            finally {
                environment_ReactionStack.pop();
            }
        }
    };
    reaction._scheduler = function (looping) {
        looping();
        if (dirtyCheck())
            fireAction();
        value.oldValue = value.currentValue;
    };
    reaction._name = realOptions.name;
    reaction();
    value.oldValue = value.currentValue;
    if (realOptions.fireImmediately) {
        fireAction();
    }
    return function () {
        reaction_disposeBindingReactions(reaction);
    };
};
//# sourceMappingURL=autorun.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/tracker.js



var tracker_Tracker = /** @class */ (function () {
    function Tracker(scheduler, name) {
        if (name === void 0) { name = 'TrackerReaction'; }
        var _this = this;
        this.track = function (tracker) {
            if (!reactive_esm_checkers_isFn(tracker))
                return _this.results;
            if (_this.track._boundary > 0)
                return;
            if (environment_ReactionStack.indexOf(_this.track) === -1) {
                reaction_releaseBindingReactions(_this.track);
                try {
                    reaction_batchStart();
                    environment_ReactionStack.push(_this.track);
                    _this.results = tracker();
                }
                finally {
                    environment_ReactionStack.pop();
                    _this.track._boundary++;
                    reaction_batchEnd();
                    _this.track._boundary = 0;
                }
            }
            return _this.results;
        };
        this.dispose = function () {
            reaction_disposeBindingReactions(_this.track);
        };
        this.track._scheduler = function (callback) {
            if (_this.track._boundary === 0)
                _this.dispose();
            if (reactive_esm_checkers_isFn(callback))
                scheduler(callback);
        };
        this.track._name = name;
        this.track._boundary = 0;
    }
    return Tracker;
}());

//# sourceMappingURL=tracker.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/observe.js




var observe_observe = function (target, observer, deep) {
    if (deep === void 0) { deep = true; }
    var addListener = function (target) {
        var raw = getRaw(target);
        var node = getDataNode(raw);
        var listener = function (operation) {
            var targetRaw = getRaw(operation.target);
            var targetNode = getDataNode(targetRaw);
            if (deep) {
                if (node.contains(targetNode)) {
                    observer(new DataChange(operation, targetNode));
                    return;
                }
            }
            if (node === targetNode ||
                (node.targetRaw === targetRaw && node.key === operation.key)) {
                observer(new DataChange(operation, targetNode));
            }
        };
        if (node && isFn(observer)) {
            ObserverListeners.add(listener);
        }
        return function () {
            ObserverListeners.delete(listener);
        };
    };
    if (target && typeof target !== 'object')
        throw Error("Can not observe ".concat(typeof target, " type."));
    return addListener(target);
};
//# sourceMappingURL=observe.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/types.js

//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+reactive@2.2.22/node_modules/@formily/reactive/esm/index.js










//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+grid@2.2.22_typescript@5.4.5/node_modules/@formily/grid/esm/observer.js
var esm_observer_assign = (undefined && undefined.__assign) || function () {
    esm_observer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return esm_observer_assign.apply(this, arguments);
};
var observer_isHTMLElement = function (node) { return node.nodeType === 1; };
var ChildListMutationObserver = /** @class */ (function () {
    function ChildListMutationObserver(callback) {
        var _this = this;
        this.childList = [];
        this.handler = function (mutations) {
            mutations.forEach(function (mutation) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function (node) {
                        if (observer_isHTMLElement(node)) {
                            _this.addObserver(node);
                        }
                    });
                    mutation.removedNodes.forEach(function (node) {
                        if (observer_isHTMLElement(node)) {
                            _this.removeObserver(node);
                        }
                    });
                }
            });
            _this.callback(mutations, _this.observer);
        };
        this.observe = function (element, init) {
            _this.init = init;
            _this.observeChildList(element);
            _this.observer.observe(element, esm_observer_assign(esm_observer_assign({}, _this.init), { subtree: false, childList: true, characterData: false, characterDataOldValue: false, attributeOldValue: false }));
        };
        this.disconnect = function () {
            _this.observer.disconnect();
        };
        this.callback = callback;
        this.observer = new MutationObserver(this.handler);
    }
    ChildListMutationObserver.prototype.observeChildList = function (element) {
        var _this = this;
        Array.from(element.children).forEach(function (node) {
            _this.addObserver(node);
        });
    };
    ChildListMutationObserver.prototype.addObserver = function (element) {
        var _this = this;
        var child = this.childList.find(function (t) { return t.element === element; });
        if (!child) {
            var childIndex_1 = this.childList.length;
            var child_1 = {
                element: element,
                observer: new MutationObserver(this.callback),
                dispose: function () {
                    if (child_1.observer) {
                        child_1.observer.disconnect();
                        delete child_1.observer;
                        _this.childList.splice(childIndex_1, 1);
                    }
                },
            };
            child_1.observer.observe(child_1.element, esm_observer_assign(esm_observer_assign({}, this.init), { subtree: false, childList: false, characterData: false, characterDataOldValue: false, attributeOldValue: false }));
            this.childList.push(child_1);
        }
    };
    ChildListMutationObserver.prototype.removeObserver = function (element) {
        var _a;
        var child = this.childList.find(function (t) { return t.element === element; });
        if (child) {
            (_a = child.dispose) === null || _a === void 0 ? void 0 : _a.call(child);
        }
    };
    return ChildListMutationObserver;
}());

//# sourceMappingURL=observer.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js

var hasActiveObservations = function () {
    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js

var hasSkippedObservations = function () {
    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = 'ResizeObserver loop completed with undelivered notifications.';
var deliverResizeLoopError = function () {
    var event;
    if (typeof ErrorEvent === 'function') {
        event = new ErrorEvent('error', {
            message: msg
        });
    }
    else {
        event = document.createEvent('Event');
        event.initEvent('error', false, false);
        event.message = msg;
    }
    window.dispatchEvent(event);
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function (ResizeObserverBoxOptions) {
    ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
    ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
    ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function (obj) { return Object.freeze(obj); };

;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js

var ResizeObserverSize = (function () {
    function ResizeObserverSize(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
    }
    return ResizeObserverSize;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js

var DOMRectReadOnly_DOMRectReadOnly = (function () {
    function DOMRectReadOnly(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
    }
    DOMRectReadOnly.prototype.toJSON = function () {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
    };
    DOMRectReadOnly.fromRect = function (rectangle) {
        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
    };
    return DOMRectReadOnly;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
var isHidden = function (target) {
    if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
    }
    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
    return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function (obj) {
    var _a;
    if (obj instanceof Element) {
        return true;
    }
    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
    return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function (target) {
    switch (target.tagName) {
        case 'INPUT':
            if (target.type !== 'image') {
                break;
            }
        case 'VIDEO':
        case 'AUDIO':
        case 'EMBED':
        case 'OBJECT':
        case 'CANVAS':
        case 'IFRAME':
        case 'IMG':
            return true;
    }
    return false;
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/global.js
var global = typeof window !== 'undefined' ? window : {};

;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js






var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);
var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
var size = function (inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) { inlineSize = 0; }
    if (blockSize === void 0) { blockSize = 0; }
    if (switchSizes === void 0) { switchSizes = false; }
    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new DOMRectReadOnly_DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function (target, forceRecalculation) {
    if (forceRecalculation === void 0) { forceRecalculation = false; }
    if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
    }
    if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
    }
    var cs = getComputedStyle(target);
    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly_DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
};
var calculateBoxSize = function (target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
    switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
            return borderBoxSize;
        default:
            return contentBoxSize;
    }
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js


var ResizeObserverEntry_ResizeObserverEntry = (function () {
    function ResizeObserverEntry(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
    }
    return ResizeObserverEntry;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js

var calculateDepthForNode = function (node) {
    if (isHidden(node)) {
        return Infinity;
    }
    var depth = 0;
    var parent = node.parentNode;
    while (parent) {
        depth += 1;
        parent = parent.parentNode;
    }
    return depth;
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js




var broadcastActiveObservations = function () {
    var shallowestDepth = Infinity;
    var callbacks = [];
    resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
            return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new ResizeObserverEntry_ResizeObserverEntry(ot.target);
            var targetDepth = calculateDepthForNode(ot.target);
            entries.push(entry);
            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
                shallowestDepth = targetDepth;
            }
        });
        callbacks.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
    });
    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
    }
    return shallowestDepth;
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js


var gatherActiveObservationsAtDepth = function (depth) {
    resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
                if (calculateDepthForNode(ot.target) > depth) {
                    ro.activeTargets.push(ot);
                }
                else {
                    ro.skippedTargets.push(ot);
                }
            }
        });
    });
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/process.js





var process = function () {
    var depth = 0;
    gatherActiveObservationsAtDepth(depth);
    while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
    }
    if (hasSkippedObservations()) {
        deliverResizeLoopError();
    }
    return depth > 0;
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var queueMicroTask_notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
var queueMicroTask = function (callback) {
    if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode('');
        var config = { characterData: true };
        new MutationObserver(function () { return queueMicroTask_notify(); }).observe(el_1, config);
        trigger = function () { el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++); };
    }
    callbacks.push(callback);
    trigger();
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js

var queueResizeObserver = function (cb) {
    queueMicroTask(function ResizeObserver() {
        requestAnimationFrame(cb);
    });
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/utils/scheduler.js



var watching = 0;
var isWatching = function () { return !!watching; };
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var scheduler_events = [
    'resize',
    'load',
    'transitionend',
    'animationend',
    'animationstart',
    'animationiteration',
    'keyup',
    'keydown',
    'mouseup',
    'mousedown',
    'mouseover',
    'mouseout',
    'blur',
    'focus'
];
var time = function (timeout) {
    if (timeout === void 0) { timeout = 0; }
    return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = (function () {
    function Scheduler() {
        var _this = this;
        this.stopped = true;
        this.listener = function () { return _this.schedule(); };
    }
    Scheduler.prototype.run = function (timeout) {
        var _this = this;
        if (timeout === void 0) { timeout = CATCH_PERIOD; }
        if (scheduled) {
            return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function () {
            var elementsHaveResized = false;
            try {
                elementsHaveResized = process();
            }
            finally {
                scheduled = false;
                timeout = until - time();
                if (!isWatching()) {
                    return;
                }
                if (elementsHaveResized) {
                    _this.run(1000);
                }
                else if (timeout > 0) {
                    _this.run(timeout);
                }
                else {
                    _this.start();
                }
            }
        });
    };
    Scheduler.prototype.schedule = function () {
        this.stop();
        this.run();
    };
    Scheduler.prototype.observe = function () {
        var _this = this;
        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);
    };
    Scheduler.prototype.start = function () {
        var _this = this;
        if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            scheduler_events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });
        }
    };
    Scheduler.prototype.stop = function () {
        var _this = this;
        if (!this.stopped) {
            this.observer && this.observer.disconnect();
            scheduler_events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });
            this.stopped = true;
        }
    };
    return Scheduler;
}());
var scheduler = new Scheduler();
var updateCount = function (n) {
    !watching && n > 0 && scheduler.start();
    watching += n;
    !watching && scheduler.stop();
};


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObservation.js



var skipNotifyOnElement = function (target) {
    return !isSVG(target)
        && !isReplacedElement(target)
        && getComputedStyle(target).display === 'inline';
};
var ResizeObservation_ResizeObservation = (function () {
    function ResizeObservation(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
        };
    }
    ResizeObservation.prototype.isActive = function () {
        var size = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size;
        }
        if (this.lastReportedSize.inlineSize !== size.inlineSize
            || this.lastReportedSize.blockSize !== size.blockSize) {
            return true;
        }
        return false;
    };
    return ResizeObservation;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = (function () {
    function ResizeObserverDetail(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
    }
    return ResizeObserverDetail;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserverController.js




var observerMap = new WeakMap();
var getObservationIndex = function (observationTargets, target) {
    for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
            return i;
        }
    }
    return -1;
};
var ResizeObserverController_ResizeObserverController = (function () {
    function ResizeObserverController() {
    }
    ResizeObserverController.connect = function (resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
    };
    ResizeObserverController.observe = function (resizeObserver, target, options) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && resizeObservers.push(detail);
            detail.observationTargets.push(new ResizeObservation_ResizeObservation(target, options && options.box));
            updateCount(1);
            scheduler.schedule();
        }
    };
    ResizeObserverController.unobserve = function (resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            updateCount(-1);
        }
    };
    ResizeObserverController.disconnect = function (resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
        detail.activeTargets.splice(0, detail.activeTargets.length);
    };
    return ResizeObserverController;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/ResizeObserver.js


var ResizeObserver_ResizeObserver = (function () {
    function ResizeObserver(callback) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== 'function') {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController_ResizeObserverController.connect(this, callback);
    }
    ResizeObserver.prototype.observe = function (target, options) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController_ResizeObserverController.observe(this, target, options);
    };
    ResizeObserver.prototype.unobserve = function (target) {
        if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController_ResizeObserverController.unobserve(this, target);
    };
    ResizeObserver.prototype.disconnect = function () {
        ResizeObserverController_ResizeObserverController.disconnect(this);
    };
    ResizeObserver.toString = function () {
        return 'function ResizeObserver () { [polyfill code] }';
    };
    return ResizeObserver;
}());


;// CONCATENATED MODULE: ./node_modules/.pnpm/@juggle+resize-observer@3.4.0/node_modules/@juggle/resize-observer/lib/exports/resize-observer.js




;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+grid@2.2.22_typescript@5.4.5/node_modules/@formily/grid/esm/index.js
var esm_assign = (undefined && undefined.__assign) || function () {
    esm_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return esm_assign.apply(this, arguments);
};
var grid_esm_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var grid_esm_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



var SpanRegExp = /span\s*(\d+)/;
var grid_esm_isValid = function (value) { return value !== undefined && value !== null; };
var esm_calcBreakpointIndex = function (breakpoints, width) {
    if (Array.isArray(breakpoints)) {
        for (var i = 0; i < breakpoints.length; i++) {
            if (width <= breakpoints[i]) {
                return i;
            }
        }
    }
    return -1;
};
var esm_calcFactor = function (value, breakpointIndex) {
    var _a;
    if (Array.isArray(value)) {
        if (breakpointIndex === -1)
            return value[0];
        return (_a = value[breakpointIndex]) !== null && _a !== void 0 ? _a : value[value.length - 1];
    }
    else {
        return value;
    }
};
var parseGridNode = function (elements) {
    return Array.from(elements).reduce(function (buf, element, index) {
        var _a;
        var style = getComputedStyle(element);
        var visible = !(style.display === 'none');
        var origin = element.getAttribute('data-grid-span');
        var span = (_a = parseSpan(style.gridColumnStart)) !== null && _a !== void 0 ? _a : 1;
        var originSpan = Number(origin !== null && origin !== void 0 ? origin : span);
        var node = {
            index: index,
            span: span,
            visible: visible,
            originSpan: originSpan,
            element: element,
        };
        if (!origin) {
            element.setAttribute('data-grid-span', String(span));
        }
        return buf.concat(node);
    }, []);
};
var calcChildTotalColumns = function (nodes, shadow) {
    if (shadow === void 0) { shadow = false; }
    return nodes.reduce(function (buf, node) {
        var _a;
        if (!shadow) {
            if (!node.visible)
                return buf;
        }
        if (node.originSpan === -1)
            return buf + ((_a = node.span) !== null && _a !== void 0 ? _a : 1);
        return buf + node.span;
    }, 0);
};
var calcChildOriginTotalColumns = function (nodes, shadow) {
    if (shadow === void 0) { shadow = false; }
    return nodes.reduce(function (buf, node) {
        var _a;
        if (!shadow) {
            if (!node.visible)
                return buf;
        }
        if (node.originSpan === -1)
            return buf + ((_a = node.span) !== null && _a !== void 0 ? _a : 1);
        return buf + node.originSpan;
    }, 0);
};
var calcSatisfyColumns = function (width, maxColumns, minColumns, maxWidth, minWidth, gap) {
    var results = [];
    for (var columns = minColumns; columns <= maxColumns; columns++) {
        var innerWidth_1 = width - (columns - 1) * gap;
        var columnWidth = innerWidth_1 / columns;
        if (columnWidth >= minWidth && columnWidth <= maxWidth) {
            results.push(columns);
        }
        else if (columnWidth < minWidth) {
            results.push(Math.min(Math.floor(innerWidth_1 / minWidth), maxColumns));
        }
        else if (columnWidth > maxWidth) {
            results.push(Math.min(Math.floor(innerWidth_1 / maxWidth), maxColumns));
        }
    }
    return Math.max.apply(Math, grid_esm_spreadArray([], grid_esm_read(results), false));
};
var parseSpan = function (gridColumnStart) {
    var _a, _b;
    return Number((_b = (_a = String(gridColumnStart).match(SpanRegExp)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : 1);
};
var esm_factor = function (value, grid) {
    return grid_esm_isValid(value) ? esm_calcFactor(value, grid.breakpoint) : value;
};
var resolveChildren = function (grid) {
    var walked = 0, shadowWalked = 0, rowIndex = 0, shadowRowIndex = 0;
    if (!grid.ready)
        return;
    grid.children = grid.children.map(function (node) {
        var _a;
        var columnIndex = walked % grid.columns;
        var shadowColumnIndex = shadowWalked % grid.columns;
        var remainColumns = grid.columns - columnIndex;
        var originSpan = node.originSpan;
        var targetSpan = originSpan > grid.columns ? grid.columns : originSpan;
        var span = grid.options.strictAutoFit
            ? targetSpan
            : targetSpan > remainColumns
                ? remainColumns
                : targetSpan;
        var gridColumn = originSpan === -1 ? "span ".concat(remainColumns, " / -1") : "span ".concat(span, " / auto");
        if (node.element.style.gridColumn !== gridColumn) {
            node.element.style.gridColumn = gridColumn;
        }
        if (node.visible) {
            walked += span;
        }
        shadowWalked += span;
        if (columnIndex === 0) {
            rowIndex++;
        }
        if (shadowColumnIndex == 0) {
            shadowRowIndex++;
        }
        node.shadowRow = shadowRowIndex;
        node.shadowColumn = shadowColumnIndex + 1;
        if (node.visible) {
            node.row = rowIndex;
            node.column = columnIndex + 1;
        }
        if ((_a = grid.options) === null || _a === void 0 ? void 0 : _a.shouldVisible) {
            if (!grid.options.shouldVisible(node, grid)) {
                if (node.visible) {
                    node.element.style.display = 'none';
                }
                node.visible = false;
            }
            else {
                if (!node.visible) {
                    node.element.style.display = '';
                }
                node.visible = true;
            }
        }
        return node;
    });
};
var nextTick = function (callback) { return Promise.resolve(0).then(callback); };
var Grid = /** @class */ (function () {
    function Grid(options) {
        var _this = this;
        this.width = 0;
        this.height = 0;
        this.children = [];
        this.childTotalColumns = 0;
        this.shadowChildTotalColumns = 0;
        this.childOriginTotalColumns = 0;
        this.shadowChildOriginTotalColumns = 0;
        this.ready = false;
        this.connect = function (container) {
            if (container) {
                _this.container = container;
                var initialize = batch_batch.bound(function () {
                    digest_1();
                    _this.ready = true;
                });
                var digest_1 = batch_batch.bound(function () {
                    _this.children = parseGridNode(_this.container.children);
                    _this.childTotalColumns = calcChildTotalColumns(_this.children);
                    _this.shadowChildTotalColumns = calcChildTotalColumns(_this.children, true);
                    _this.childOriginTotalColumns = calcChildOriginTotalColumns(_this.children);
                    _this.shadowChildOriginTotalColumns = calcChildOriginTotalColumns(_this.children, true);
                    var rect = _this.container.getBoundingClientRect();
                    if (rect.width && rect.height) {
                        _this.width = rect.width;
                        _this.height = rect.height;
                    }
                    resolveChildren(_this);
                    nextTick(function () {
                        var _a, _b;
                        (_b = (_a = _this.options) === null || _a === void 0 ? void 0 : _a.onDigest) === null || _b === void 0 ? void 0 : _b.call(_a, _this);
                    });
                    if (!_this.ready) {
                        nextTick(function () {
                            var _a, _b;
                            (_b = (_a = _this.options) === null || _a === void 0 ? void 0 : _a.onInitialized) === null || _b === void 0 ? void 0 : _b.call(_a, _this);
                        });
                    }
                });
                var mutationObserver_1 = new ChildListMutationObserver(digest_1);
                var resizeObserver_1 = new ResizeObserver_ResizeObserver(digest_1);
                var dispose_1 = autorun_reaction(function () { return (esm_assign({}, _this.options)); }, digest_1);
                resizeObserver_1.observe(_this.container);
                mutationObserver_1.observe(_this.container, {
                    attributeFilter: ['data-grid-span'],
                    attributes: true,
                });
                initialize();
                return function () {
                    resizeObserver_1.unobserve(_this.container);
                    resizeObserver_1.disconnect();
                    mutationObserver_1.disconnect();
                    dispose_1();
                    _this.children = [];
                };
            }
            return function () { };
        };
        this.options = esm_assign({ breakpoints: [720, 1280, 1920], columnGap: 8, rowGap: 4, minWidth: 100, colWrap: true, strictAutoFit: false }, options);
        esm_model_define(this, {
            options: reactive_esm_observable_observable.shallow,
            width: reactive_esm_observable_observable.ref,
            height: reactive_esm_observable_observable.ref,
            ready: reactive_esm_observable_observable.ref,
            children: reactive_esm_observable_observable.ref,
            childOriginTotalColumns: reactive_esm_observable_observable.ref,
            shadowChildOriginTotalColumns: reactive_esm_observable_observable.ref,
            shadowChildTotalColumns: reactive_esm_observable_observable.ref,
            childTotalColumns: reactive_esm_observable_observable.ref,
            columns: reactive_esm_observable_observable.computed,
            templateColumns: reactive_esm_observable_observable.computed,
            gap: reactive_esm_observable_observable.computed,
            maxColumns: reactive_esm_observable_observable.computed,
            minColumns: reactive_esm_observable_observable.computed,
            maxWidth: reactive_esm_observable_observable.computed,
            minWidth: reactive_esm_observable_observable.computed,
            breakpoints: reactive_esm_observable_observable.computed,
            breakpoint: reactive_esm_observable_observable.computed,
            rowGap: reactive_esm_observable_observable.computed,
            columnGap: reactive_esm_observable_observable.computed,
            colWrap: reactive_esm_observable_observable.computed,
        });
    }
    Object.defineProperty(Grid.prototype, "breakpoints", {
        get: function () {
            return this.options.breakpoints;
        },
        set: function (breakpoints) {
            this.options.breakpoints = breakpoints;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "breakpoint", {
        get: function () {
            return esm_calcBreakpointIndex(this.options.breakpoints, this.width);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "maxWidth", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.maxWidth, this)) !== null && _a !== void 0 ? _a : Infinity;
        },
        set: function (maxWidth) {
            this.options.maxWidth = maxWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "minWidth", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.minWidth, this)) !== null && _a !== void 0 ? _a : 100;
        },
        set: function (minWidth) {
            this.options.minWidth = minWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "maxColumns", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.maxColumns, this)) !== null && _a !== void 0 ? _a : Infinity;
        },
        set: function (maxColumns) {
            this.options.maxColumns = maxColumns;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "maxRows", {
        get: function () {
            var _a;
            return (_a = this.options.maxRows) !== null && _a !== void 0 ? _a : Infinity;
        },
        set: function (maxRows) {
            this.options.maxRows = maxRows;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "minColumns", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.minColumns, this)) !== null && _a !== void 0 ? _a : 1;
        },
        set: function (minColumns) {
            this.options.minColumns = minColumns;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "rowGap", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.rowGap, this)) !== null && _a !== void 0 ? _a : 5;
        },
        set: function (rowGap) {
            this.options.rowGap = rowGap;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "columnGap", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.columnGap, this)) !== null && _a !== void 0 ? _a : 10;
        },
        set: function (columnGap) {
            this.options.columnGap = columnGap;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "colWrap", {
        get: function () {
            var _a;
            return (_a = esm_factor(this.options.colWrap, this)) !== null && _a !== void 0 ? _a : true;
        },
        set: function (colWrap) {
            this.options.colWrap = colWrap;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "columns", {
        get: function () {
            if (!this.ready)
                return 0;
            var originTotalColumns = this.childOriginTotalColumns;
            if (this.colWrap === false) {
                return originTotalColumns;
            }
            var baseColumns = this.childSize;
            var strictMaxWidthColumns = Math.round(this.width / (this.maxWidth + this.columnGap));
            var looseMaxWidthColumns = Math.min(originTotalColumns, strictMaxWidthColumns);
            var maxWidthColumns = this.options.strictAutoFit
                ? strictMaxWidthColumns
                : looseMaxWidthColumns;
            var strictMinWidthColumns = Math.round(this.width / (this.minWidth + this.columnGap));
            var looseMinWidthColumns = Math.min(originTotalColumns, strictMinWidthColumns);
            var minWidthColumns = this.options.strictAutoFit
                ? strictMinWidthColumns
                : looseMinWidthColumns;
            var minCalculatedColumns = Math.min(baseColumns, originTotalColumns, maxWidthColumns, minWidthColumns);
            var maxCalculatedColumns = Math.max(baseColumns, originTotalColumns, maxWidthColumns, minWidthColumns);
            var finalColumns = calcSatisfyColumns(this.width, maxCalculatedColumns, minCalculatedColumns, this.maxWidth, this.minWidth, this.columnGap);
            if (finalColumns >= this.maxColumns) {
                return this.maxColumns;
            }
            if (finalColumns <= this.minColumns) {
                return this.minColumns;
            }
            return finalColumns;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "rows", {
        get: function () {
            return Math.ceil(this.childTotalColumns / this.columns);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "shadowRows", {
        get: function () {
            return Math.ceil(this.shadowChildTotalColumns / this.columns);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "templateColumns", {
        get: function () {
            if (!this.width)
                return '';
            if (this.maxWidth === Infinity) {
                return "repeat(".concat(this.columns, ",minmax(0,1fr))");
            }
            if (this.options.strictAutoFit !== true) {
                var columnWidth = (this.width - (this.columns - 1) * this.columnGap) / this.columns;
                if (columnWidth < this.minWidth || columnWidth > this.maxWidth) {
                    return "repeat(".concat(this.columns, ",minmax(0,1fr))");
                }
            }
            return "repeat(".concat(this.columns, ",minmax(").concat(this.minWidth, "px,").concat(this.maxWidth, "px))");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "gap", {
        get: function () {
            return "".concat(this.rowGap, "px ").concat(this.columnGap, "px");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "childSize", {
        get: function () {
            return this.children.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "fullnessLastColumn", {
        get: function () {
            var _a;
            return this.columns === ((_a = this.children[this.childSize - 1]) === null || _a === void 0 ? void 0 : _a.span);
        },
        enumerable: false,
        configurable: true
    });
    Grid.id = function (options) {
        if (options === void 0) { options = {}; }
        return JSON.stringify([
            'maxRows',
            'maxColumns',
            'minColumns',
            'maxWidth',
            'minWidth',
            'breakpoints',
            'columnGap',
            'rowGap',
            'colWrap',
            'strictAutoFit',
        ].map(function (key) { return options[key]; }));
    };
    return Grid;
}());

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-grid/style.js

/* harmony default export */ const form_grid_style = (genStyleHook('form-grid', function (token) {
    var _a;
    var componentCls = token.componentCls;
    return _a = {},
        _a["".concat(componentCls, "-layout")] = {
            display: 'grid',
        },
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-grid/index.js
var form_grid_assign = (undefined && undefined.__assign) || function () {
    form_grid_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_grid_assign.apply(this, arguments);
};
var form_grid_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var form_grid_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};








var FormGridContext = external_React_default().createContext(null);
var createFormGrid = function (props) {
    return markRaw(new Grid(props));
};
var useFormGrid = function () { return (0,external_React_namespaceObject.useContext)(FormGridContext); };
var InternalFormGrid = observer(function (_a) {
    var _b, _c;
    var children = _a.children, className = _a.className, style = _a.style, props = form_grid_rest(_a, ["children", "className", "style"]);
    var layout = useFormLayout();
    var options = form_grid_assign({ columnGap: (_b = layout === null || layout === void 0 ? void 0 : layout.gridColumnGap) !== null && _b !== void 0 ? _b : 8, rowGap: (_c = layout === null || layout === void 0 ? void 0 : layout.gridRowGap) !== null && _c !== void 0 ? _c : 4 }, props);
    var grid = (0,external_React_namespaceObject.useMemo)(function () { return markRaw((options === null || options === void 0 ? void 0 : options.grid) ? options.grid : new Grid(options)); }, [Grid.id(options)]);
    var ref = (0,external_React_namespaceObject.useRef)(null);
    var prefixCls = usePrefixCls('formily-grid', props);
    var _d = form_grid_read(form_grid_style(prefixCls), 2), wrapSSR = _d[0], hashId = _d[1];
    var dataProps = pickDataProps(props);
    (0,external_React_namespaceObject.useLayoutEffect)(function () {
        if (ref.current) {
            return grid.connect(ref.current);
        }
    }, [grid]);
    return (external_React_default().createElement(FormGridContext.Provider, { value: grid }, wrapSSR(external_React_default().createElement("div", form_grid_assign({}, dataProps, { className: classnames_default()("".concat(prefixCls, "-layout"), hashId, className), style: form_grid_assign(form_grid_assign({}, style), { gridTemplateColumns: grid.templateColumns, gap: grid.gap }), ref: ref }), children))));
}, {
    forwardRef: true,
});
var GridColumn = observer(function (_a) {
    var gridSpan = _a.gridSpan, children = _a.children, props = form_grid_rest(_a, ["gridSpan", "children"]);
    return (external_React_default().createElement("div", form_grid_assign({}, props, { style: props.style, "data-grid-span": gridSpan }), children));
});
GridColumn.defaultProps = {
    gridSpan: 1,
};
var FormGrid = Object.assign(InternalFormGrid, {
    createFormGrid: createFormGrid,
    useFormGrid: useFormGrid,
    GridColumn: GridColumn,
});
/* harmony default export */ const form_grid = ((/* unused pure expression or super */ null && (FormGrid)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-step/index.js
var form_step_assign = (undefined && undefined.__assign) || function () {
    form_step_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_step_assign.apply(this, arguments);
};
var form_step_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var form_step_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var form_step_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






var parseSteps = function (schema) {
    var steps = [];
    schema.mapProperties(function (schema, name) {
        var _a;
        if (((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('StepPane')) > -1) {
            steps.push({
                name: name,
                props: schema['x-component-props'],
                schema: schema,
            });
        }
    });
    return steps;
};
var createFormStep = function (defaultCurrent) {
    var _a, _b, _c;
    if (defaultCurrent === void 0) { defaultCurrent = 0; }
    var env = model_define({
        form: null,
        field: null,
        steps: [],
    }, {
        form: esm_observable_observable.ref,
        field: esm_observable_observable.ref,
        steps: esm_observable_observable.shallow,
    });
    var setDisplay = (_a = action_action.bound) === null || _a === void 0 ? void 0 : _a.call(action_action, function (target) {
        var currentStep = env.steps[target];
        env.steps.forEach(function (_a) {
            var _b, _c;
            var name = _a.name;
            (_b = env.form) === null || _b === void 0 ? void 0 : _b.query("".concat((_c = env.field) === null || _c === void 0 ? void 0 : _c.address, ".").concat(name)).take(function (field) {
                if (name === currentStep.name) {
                    field.setDisplay('visible');
                }
                else {
                    field.setDisplay('hidden');
                }
            });
        });
    });
    var next = (_b = action_action.bound) === null || _b === void 0 ? void 0 : _b.call(action_action, function () {
        if (formStep.allowNext) {
            formStep.setCurrent(formStep.current + 1);
        }
    });
    var back = (_c = action_action.bound) === null || _c === void 0 ? void 0 : _c.call(action_action, function () {
        if (formStep.allowBack) {
            formStep.setCurrent(formStep.current - 1);
        }
    });
    var formStep = model({
        connect: function (steps, field) {
            env.steps = steps;
            env.form = field === null || field === void 0 ? void 0 : field.form;
            env.field = field;
        },
        current: defaultCurrent,
        setCurrent: function (key) {
            setDisplay === null || setDisplay === void 0 ? void 0 : setDisplay(key);
            formStep.current = key;
        },
        get allowNext() {
            return formStep.current < env.steps.length - 1;
        },
        get allowBack() {
            return formStep.current > 0;
        },
        next: function () {
            var _a, _b;
            return form_step_awaiter(this, void 0, void 0, function () {
                var _c;
                return form_step_generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 2, , 3]);
                            return [4 /*yield*/, ((_a = env.form) === null || _a === void 0 ? void 0 : _a.validate())];
                        case 1:
                            _d.sent();
                            if ((_b = env.form) === null || _b === void 0 ? void 0 : _b.valid) {
                                next === null || next === void 0 ? void 0 : next();
                            }
                            return [3 /*break*/, 3];
                        case 2:
                            _c = _d.sent();
                            return [3 /*break*/, 3];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        },
        back: function () {
            return form_step_awaiter(this, void 0, void 0, function () {
                return form_step_generator(this, function (_a) {
                    back === null || back === void 0 ? void 0 : back();
                    return [2 /*return*/];
                });
            });
        },
        submit: function (onSubmit) {
            var _a, _b;
            return form_step_awaiter(this, void 0, void 0, function () {
                return form_step_generator(this, function (_c) {
                    return [2 /*return*/, (_b = (_a = env.form) === null || _a === void 0 ? void 0 : _a.submit) === null || _b === void 0 ? void 0 : _b.call(_a, onSubmit)];
                });
            });
        },
    });
    return markRaw(formStep);
};
var FormStep = connect(observer(function (_a) {
    var _b;
    var formStep = _a.formStep, className = _a.className, props = form_step_rest(_a, ["formStep", "className"]);
    var field = useField();
    var prefixCls = usePrefixCls('formily-step', props);
    var schema = useFieldSchema();
    var steps = parseSteps(schema);
    var current = props.current || (formStep === null || formStep === void 0 ? void 0 : formStep.current) || 0;
    (_b = formStep === null || formStep === void 0 ? void 0 : formStep.connect) === null || _b === void 0 ? void 0 : _b.call(formStep, steps, field);
    return (external_React_default().createElement("div", { className: classnames_default()(prefixCls, className) },
        external_React_default().createElement(external_antd_namespaceObject.Steps, form_step_assign({}, props, { style: form_step_assign({ marginBottom: 10 }, props.style), current: current }), steps.map(function (_a, key) {
            var props = _a.props;
            return external_React_default().createElement(external_antd_namespaceObject.Steps.Step, form_step_assign({}, props, { key: key }));
        })),
        steps.map(function (_a, key) {
            var name = _a.name, schema = _a.schema;
            if (key !== current)
                return;
            return external_React_default().createElement(RecursionField, { key: key, name: name, schema: schema });
        })));
}));
var StepPane = function (_a) {
    var children = _a.children;
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, children);
};
FormStep.StepPane = StepPane;
FormStep.createFormStep = createFormStep;
/* harmony default export */ const form_step = ((/* unused pure expression or super */ null && (FormStep)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/form-tab/index.js
var form_tab_assign = (undefined && undefined.__assign) || function () {
    form_tab_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return form_tab_assign.apply(this, arguments);
};
var form_tab_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






var useTabs = function () {
    var tabsField = useField();
    var schema = useFieldSchema();
    var tabs = [];
    schema.mapProperties(function (schema, name) {
        var _a, _b, _c;
        var field = tabsField.query(tabsField.address.concat(name)).take();
        if ((field === null || field === void 0 ? void 0 : field.display) === 'none' || (field === null || field === void 0 ? void 0 : field.display) === 'hidden')
            return;
        if (((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('TabPane')) > -1) {
            var key = ((_b = field === null || field === void 0 ? void 0 : field.componentProps) === null || _b === void 0 ? void 0 : _b.key) || ((_c = schema === null || schema === void 0 ? void 0 : schema['x-component-props']) === null || _c === void 0 ? void 0 : _c.key) || name;
            tabs.push({
                name: name,
                props: form_tab_assign(form_tab_assign(form_tab_assign({}, schema === null || schema === void 0 ? void 0 : schema['x-component-props']), field === null || field === void 0 ? void 0 : field.componentProps), { key: key }),
                schema: schema,
            });
        }
    });
    return tabs;
};
var form_tab_FeedbackBadge = observer(function (props) {
    var field = useField();
    var errors = field.form.queryFeedbacks({
        type: 'error',
        address: "".concat(field.address.concat(props.name), ".*"),
    });
    if (errors.length) {
        return (external_React_default().createElement(external_antd_namespaceObject.Badge, { size: "small", className: "errors-badge", count: errors.length }, props.tab));
    }
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, props.tab);
});
var createFormTab = function (defaultActiveKey) {
    var formTab = model({
        activeKey: defaultActiveKey,
        setActiveKey: function (key) {
            formTab.activeKey = key;
        },
    });
    return markRaw(formTab);
};
var FormTab = observer(function (_a) {
    var formTab = _a.formTab, props = form_tab_rest(_a, ["formTab"]);
    var tabs = useTabs();
    var _formTab = (0,external_React_namespaceObject.useMemo)(function () {
        return formTab ? formTab : createFormTab();
    }, []);
    var prefixCls = usePrefixCls('formily-tab', props);
    var activeKey = props.activeKey || (_formTab === null || _formTab === void 0 ? void 0 : _formTab.activeKey);
    return (external_React_default().createElement(external_antd_namespaceObject.Tabs, form_tab_assign({}, props, { className: classnames_default()(prefixCls, props.className), activeKey: activeKey, onChange: function (key) {
            var _a, _b;
            (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
            (_b = _formTab === null || _formTab === void 0 ? void 0 : _formTab.setActiveKey) === null || _b === void 0 ? void 0 : _b.call(_formTab, key);
        }, items: tabs.map(function (_a, key) {
            var props = _a.props, schema = _a.schema, name = _a.name;
            return form_tab_assign(form_tab_assign({ key: key, label: external_React_default().createElement(form_tab_FeedbackBadge, { name: name, tab: props.tab }) }, props), { children: external_React_default().createElement(RecursionField, { schema: schema, name: name }) });
        }) })));
});
var TabPane = function (_a) {
    var children = _a.children;
    return external_React_default().createElement(external_React_namespaceObject.Fragment, null, children);
};
FormTab.TabPane = TabPane;
FormTab.createFormTab = createFormTab;
/* harmony default export */ const form_tab = ((/* unused pure expression or super */ null && (FormTab)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/input/index.js
var input_assign = (undefined && undefined.__assign) || function () {
    input_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return input_assign.apply(this, arguments);
};





var InternalInput = connect(external_antd_namespaceObject.Input, mapProps(function (props, field) {
    return input_assign(input_assign({}, props), { suffix: (external_React_default().createElement("span", null, (field === null || field === void 0 ? void 0 : field['loading']) || (field === null || field === void 0 ? void 0 : field['validating']) ? (external_React_default().createElement(external_icons_namespaceObject.LoadingOutlined, null)) : (props.suffix))) });
}), mapReadPretty(PreviewText.Input));
var TextArea = connect(external_antd_namespaceObject.Input.TextArea, mapReadPretty(PreviewText.Input));
var input_Input = Object.assign(InternalInput, {
    TextArea: TextArea,
});
/* harmony default export */ const input = ((/* unused pure expression or super */ null && (input_Input)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/number-picker/index.js



var number_picker_NumberPicker = connect(external_antd_namespaceObject.InputNumber, mapReadPretty(PreviewText.NumberPicker));
/* harmony default export */ const number_picker = ((/* unused pure expression or super */ null && (number_picker_NumberPicker)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/password/PasswordStrength.js


var PasswordStrength_isNum = function (c) {
    return c >= 48 && c <= 57;
};
var isLower = function (c) {
    return c >= 97 && c <= 122;
};
var isUpper = function (c) {
    return c >= 65 && c <= 90;
};
var isSymbol = function (c) {
    return !(isLower(c) || isUpper(c) || PasswordStrength_isNum(c));
};
var isLetter = function (c) {
    return isLower(c) || isUpper(c);
};
var getStrength = function (val) {
    if (!val)
        return 0;
    var num = 0;
    var lower = 0;
    var upper = 0;
    var symbol = 0;
    var MNS = 0;
    var rep = 0;
    var repC = 0;
    var consecutive = 0;
    var sequential = 0;
    var len = function () { return num + lower + upper + symbol; };
    var callme = function () {
        var re = num > 0 ? 1 : 0;
        re += lower > 0 ? 1 : 0;
        re += upper > 0 ? 1 : 0;
        re += symbol > 0 ? 1 : 0;
        if (re > 2 && len() >= 8) {
            return re + 1;
        }
        else {
            return 0;
        }
    };
    for (var i = 0; i < val.length; i++) {
        var c = val.charCodeAt(i);
        if (PasswordStrength_isNum(c)) {
            num++;
            if (i !== 0 && i !== val.length - 1) {
                MNS++;
            }
            if (i > 0 && PasswordStrength_isNum(val.charCodeAt(i - 1))) {
                consecutive++;
            }
        }
        else if (isLower(c)) {
            lower++;
            if (i > 0 && isLower(val.charCodeAt(i - 1))) {
                consecutive++;
            }
        }
        else if (isUpper(c)) {
            upper++;
            if (i > 0 && isUpper(val.charCodeAt(i - 1))) {
                consecutive++;
            }
        }
        else {
            symbol++;
            if (i !== 0 && i !== val.length - 1) {
                MNS++;
            }
        }
        var exists = false;
        for (var j = 0; j < val.length; j++) {
            if (val[i] === val[j] && i !== j) {
                exists = true;
                repC += Math.abs(val.length / (j - i));
            }
        }
        if (exists) {
            rep++;
            var unique = val.length - rep;
            repC = unique ? Math.ceil(repC / unique) : Math.ceil(repC);
        }
        if (i > 1) {
            var last1 = val.charCodeAt(i - 1);
            var last2 = val.charCodeAt(i - 2);
            if (isLetter(c)) {
                if (isLetter(last1) && isLetter(last2)) {
                    var v = val.toLowerCase();
                    var vi = v.charCodeAt(i);
                    var vi1 = v.charCodeAt(i - 1);
                    var vi2 = v.charCodeAt(i - 2);
                    if (vi - vi1 === vi1 - vi2 && Math.abs(vi - vi1) === 1) {
                        sequential++;
                    }
                }
            }
            else if (PasswordStrength_isNum(c)) {
                if (PasswordStrength_isNum(last1) && PasswordStrength_isNum(last2)) {
                    if (c - last1 === last1 - last2 && Math.abs(c - last1) === 1) {
                        sequential++;
                    }
                }
            }
            else {
                if (isSymbol(last1) && isSymbol(last2)) {
                    if (c - last1 === last1 - last2 && Math.abs(c - last1) === 1) {
                        sequential++;
                    }
                }
            }
        }
    }
    var sum = 0;
    var length = len();
    sum += 4 * length;
    if (lower > 0) {
        sum += 2 * (length - lower);
    }
    if (upper > 0) {
        sum += 2 * (length - upper);
    }
    if (num !== length) {
        sum += 4 * num;
    }
    sum += 6 * symbol;
    sum += 2 * MNS;
    sum += 2 * callme();
    if (length === lower + upper) {
        sum -= length;
    }
    if (length === num) {
        sum -= num;
    }
    sum -= repC;
    sum -= 2 * consecutive;
    sum -= 3 * sequential;
    sum = sum < 0 ? 0 : sum;
    sum = sum > 100 ? 100 : sum;
    if (sum >= 80) {
        return 100;
    }
    else if (sum >= 60) {
        return 80;
    }
    else if (sum >= 40) {
        return 60;
    }
    else if (sum >= 20) {
        return 40;
    }
    else {
        return 20;
    }
};
var PasswordStrength = function (props) {
    if (checkers_isFn(props.children)) {
        return props.children(getStrength(String(props.value)));
    }
    else {
        return external_React_default().createElement(external_React_namespaceObject.Fragment, null, props.children);
    }
};
//# sourceMappingURL=PasswordStrength.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/password/index.js
var password_assign = (undefined && undefined.__assign) || function () {
    password_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return password_assign.apply(this, arguments);
};
var password_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





var Password = connect(function (props) {
    var value = props.value, className = props.className, checkStrength = props.checkStrength, others = password_rest(props, ["value", "className", "checkStrength"]);
    var blockStyle = {
        position: 'absolute',
        zIndex: 1,
        height: 8,
        top: 0,
        background: '#fff',
        width: 1,
        transform: 'translate(-50%, 0)',
    };
    return (external_React_default().createElement("span", { className: className },
        external_React_default().createElement(external_antd_namespaceObject.Input.Password, password_assign({}, others, { value: value })),
        checkStrength && (external_React_default().createElement(PasswordStrength, { value: String(value) }, function (score) {
            return (external_React_default().createElement("div", { style: {
                    background: '#e0e0e0',
                    marginBottom: 3,
                    position: 'relative',
                } },
                external_React_default().createElement("div", { style: password_assign(password_assign({}, blockStyle), { left: '20%' }) }),
                external_React_default().createElement("div", { style: password_assign(password_assign({}, blockStyle), { left: '40%' }) }),
                external_React_default().createElement("div", { style: password_assign(password_assign({}, blockStyle), { left: '60%' }) }),
                external_React_default().createElement("div", { style: password_assign(password_assign({}, blockStyle), { left: '80%' }) }),
                external_React_default().createElement("div", { style: {
                        position: 'relative',
                        backgroundImage: '-webkit-linear-gradient(left, #ff5500, #ff9300)',
                        transition: 'all 0.35s ease-in-out',
                        height: 8,
                        width: '100%',
                        marginTop: 5,
                        clipPath: "polygon(0 0,".concat(score, "% 0,").concat(score, "% 100%,0 100%)"),
                    } })));
        }))));
}, mapReadPretty(PreviewText.Input));
/* harmony default export */ const esm_password = ((/* unused pure expression or super */ null && (Password)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/radio/index.js



var InternalRadio = connect(external_antd_namespaceObject.Radio, mapProps({
    value: 'checked',
    onInput: 'onChange',
}));
var radio_Group = connect(external_antd_namespaceObject.Radio.Group, mapProps({
    dataSource: 'options',
}), mapReadPretty(PreviewText.Select));
var Radio = Object.assign(InternalRadio, {
    __ANT_RADIO: true,
    Group: radio_Group,
});
/* harmony default export */ const esm_radio = ((/* unused pure expression or super */ null && (Radio)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/reset/index.js
var reset_assign = (undefined && undefined.__assign) || function () {
    reset_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return reset_assign.apply(this, arguments);
};
var reset_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




var Reset = function (_a) {
    var forceClear = _a.forceClear, validate = _a.validate, onResetValidateSuccess = _a.onResetValidateSuccess, onResetValidateFailed = _a.onResetValidateFailed, props = reset_rest(_a, ["forceClear", "validate", "onResetValidateSuccess", "onResetValidateFailed"]);
    var form = useParentForm();
    return (external_React_default().createElement(external_antd_namespaceObject.Button, reset_assign({}, props, { onClick: function (e) {
            if (checkers_isFn(props.onClick)) {
                if (props.onClick(e) === false)
                    return;
            }
            form
                .reset('*', {
                forceClear: forceClear,
                validate: validate,
            })
                .then(onResetValidateSuccess)
                .catch(onResetValidateFailed);
        } }), props.children));
};
/* harmony default export */ const esm_reset = ((/* unused pure expression or super */ null && (Reset)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select/index.js
var select_assign = (undefined && undefined.__assign) || function () {
    select_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return select_assign.apply(this, arguments);
};





var select_Select = connect(external_antd_namespaceObject.Select, mapProps({
    dataSource: 'options',
    loading: true,
}, function (props, field) {
    return select_assign(select_assign({}, props), { suffixIcon: (field === null || field === void 0 ? void 0 : field['loading']) || (field === null || field === void 0 ? void 0 : field['validating']) ? (external_React_default().createElement(external_icons_namespaceObject.LoadingOutlined, null)) : (props.suffixIcon) });
}), mapReadPretty(PreviewText.Select));
/* harmony default export */ const esm_select = ((/* unused pure expression or super */ null && (select_Select)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/hooks/useSize.js
var useSize = function (fieldSize, searchSize, tableSize) {
    if (fieldSize === void 0) { fieldSize = 'middle'; }
    var fieldSizeMap = {
        small: {
            searchSize: 'small',
            tableSize: 'small',
        },
        default: {
            searchSize: 'middle',
            tableSize: 'middle',
        },
        large: {
            searchSize: 'large',
            tableSize: 'default',
        },
    };
    var _a = fieldSizeMap[fieldSize] || {}, fieldSearchSize = _a.searchSize, fieldTableSize = _a.tableSize;
    return {
        searchSize: searchSize || fieldSearchSize,
        tableSize: tableSize || fieldTableSize,
    };
};

//# sourceMappingURL=useSize.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/hooks/useFilterOptions.js
var useFilterOptions_assign = (undefined && undefined.__assign) || function () {
    useFilterOptions_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return useFilterOptions_assign.apply(this, arguments);
};


function useFilterOptions_includes(test, search) {
    return useFilterOptions_toArray(test).join('').toUpperCase().includes(search);
}
function includesOption(option, search) {
    var searched = new Set();
    var _includesOption = function (option) {
        var keys = Object.keys(option || {});
        return keys.some(function (key) {
            if (key === '__level') {
                return false;
            }
            var value = option[key];
            if (external_React_namespaceObject.isValidElement(value))
                return false;
            if (key !== 'children' && !searched.has(value)) {
                if (typeof value === 'object') {
                    searched.add(value);
                    return _includesOption(value);
                }
                return useFilterOptions_includes(value, search);
            }
            return false;
        });
    };
    return _includesOption(option);
}
function useFilterOptions_toArray(value) {
    if (checkers_isArr(value)) {
        return value;
    }
    return value !== undefined ? [value] : [];
}
var useFilterOptions = function (options, searchValue, filterOption, checkStrictly) {
    return external_React_namespaceObject.useMemo(function () {
        if (!searchValue || filterOption === false) {
            return options;
        }
        var filterFunc = checkers_isFn(filterOption)
            ? filterOption
            : function (value, option) { return includesOption(option, value.toUpperCase()); };
        var doFilter = function (arr) {
            var filterArr = [];
            arr === null || arr === void 0 ? void 0 : arr.forEach(function (item) {
                var _a;
                if ((_a = item === null || item === void 0 ? void 0 : item.children) === null || _a === void 0 ? void 0 : _a.length) {
                    var filterChildren = doFilter(item.children);
                    if (filterChildren.length) {
                        filterArr.push(useFilterOptions_assign(useFilterOptions_assign({}, item), { children: filterChildren }));
                    }
                    else if (filterFunc(searchValue, item) && checkStrictly !== false) {
                        // 父子关系启用时，没有可用子元素，不添加父元素
                        filterArr.push(useFilterOptions_assign(useFilterOptions_assign({}, item), { children: [] }));
                    }
                }
                else if (filterFunc(searchValue, item)) {
                    filterArr.push(item);
                }
            });
            return filterArr;
        };
        return doFilter(options);
    }, [options, searchValue, filterOption]);
};

//# sourceMappingURL=useFilterOptions.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/hooks/useFlatOptions.js
var useFlatOptions_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var useFlatOptions_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var useFlatOptions = function (tree) {
    var flatData = function (data) {
        var list = [];
        data === null || data === void 0 ? void 0 : data.forEach(function (item) {
            var _a;
            list = useFlatOptions_spreadArray(useFlatOptions_spreadArray([], useFlatOptions_read(list), false), [item], false);
            if ((_a = item === null || item === void 0 ? void 0 : item.children) === null || _a === void 0 ? void 0 : _a.length) {
                list = useFlatOptions_spreadArray(useFlatOptions_spreadArray([], useFlatOptions_read(list), false), useFlatOptions_read(flatData(item.children)), false);
            }
        });
        return list;
    };
    return flatData(tree);
};

//# sourceMappingURL=useFlatOptions.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/utils.js
var utils_assign = (undefined && undefined.__assign) || function () {
    utils_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return utils_assign.apply(this, arguments);
};
var utils_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var utils_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};


/**
 * 获取树列表某个键值的集合
 * @param tree 树列表
 * @param primaryKey 键名称
 * @returns 键值数组集合
 */
var getTreeKeys = function (tree, primaryKey) {
    if (primaryKey === void 0) { primaryKey = ''; }
    return checkers_isArr(tree)
        ? tree.reduce(function (prev, current) {
            if (current === null || current === void 0 ? void 0 : current.disabled) {
                return prev;
            }
            return utils_spreadArray(utils_spreadArray(utils_spreadArray([], utils_read(prev), false), [
                current[primaryKey]
            ], false), utils_read(getTreeKeys(current === null || current === void 0 ? void 0 : current.children, primaryKey)), false);
        }, [])
        : [];
};
/**
 * 判断树列表中是否有任一 key 被选中
 * @param tree 树列表
 * @param selected 已选中的 keys
 * @param primaryKey 键名
 * @returns
 */
var hasSelectedKey = function (tree, selected, primaryKey) {
    var keys = getTreeKeys(tree, primaryKey);
    var mergedKeys = utils_spreadArray(utils_spreadArray([], utils_read(keys), false), utils_read(selected), false);
    var validKeys = utils_spreadArray([], utils_read(new Set(mergedKeys)), false);
    return validKeys.length !== mergedKeys.length;
};
/**
 * 判断列表项是否全部被选中
 * @param list 一阶列表
 * @param selected 当前选中的字段值集合
 * @param primaryKey 键名称
 * @returns 是否全部被选中
 */
var isAllSelected = function (list, selected, primaryKey) {
    if (primaryKey === void 0) { primaryKey = ''; }
    var validList = list.filter(function (item) { return !(item === null || item === void 0 ? void 0 : item.disabled); });
    var selectedList = validList.filter(function (item) {
        return selected === null || selected === void 0 ? void 0 : selected.includes(item[primaryKey]);
    });
    return selectedList.length === validList.length;
};
/**
 * 完善TableUI Keys（添加选中所有子元素的父元素，或移除未选中所有子元素的父元素）
 * @param flatDataSource 完整数据平铺列表
 * @param selected 当前选中的字段值集合
 * @param primaryKey 键名称
 * @returns 完整的字段值集合
 */
var completedKeys = function (flatDataSource, selected, primaryKey) {
    if (flatDataSource === void 0) { flatDataSource = []; }
    if (primaryKey === void 0) { primaryKey = ''; }
    var allSelectedKeys = utils_spreadArray([], utils_read(selected), false);
    flatDataSource.forEach(function (item) {
        var _a;
        if ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length) {
            // 优先递归子元素
            allSelectedKeys = completedKeys(item.children, allSelectedKeys, primaryKey);
            if (isAllSelected(item.children, allSelectedKeys, primaryKey)) {
                // 如果该元素的子元素全部选中，且该元素未禁用，则也选中该项（即包含全选子元素的父元素）
                if (!(item === null || item === void 0 ? void 0 : item.disabled)) {
                    allSelectedKeys = utils_spreadArray([], utils_read(new Set(utils_spreadArray(utils_spreadArray([], utils_read(allSelectedKeys), false), [item[primaryKey]], false))), false);
                }
            }
            else {
                // 如果该元素的子元素未全部选中，则移除该项
                allSelectedKeys = allSelectedKeys.filter(function (key) { return key !== item[primaryKey]; });
            }
        }
    });
    return allSelectedKeys;
};
/**
 * 获取数列表中被选中的有效路径
 * @param tree 数列表
 * @param selected 当前选中的字段值集合
 * @param primaryKey 键名称
 * @returns 有效的树路径
 */
var getSelectedPath = function (tree, selected, primaryKey) {
    if (tree === void 0) { tree = []; }
    var pathData = [];
    tree.forEach(function (item) {
        var validChildren = getSelectedPath(item.children, selected, primaryKey);
        if (validChildren.length || (selected === null || selected === void 0 ? void 0 : selected.includes(item[primaryKey]))) {
            pathData.push(utils_assign(utils_assign({}, item), (validChildren.length ? { children: validChildren } : {})));
        }
    });
    return pathData;
};
/**
 * 删除树列表的某个 key/value 键值对
 * @param tree
 * @param key
 * @returns
 */
var deleteTreeItem = function (tree, key) {
    return tree.map(function (item) {
        var _a;
        var validItem = utils_assign({}, item);
        delete validItem[key];
        if ((_a = validItem.children) === null || _a === void 0 ? void 0 : _a.length) {
            validItem.children = deleteTreeItem(validItem.children, key);
        }
        return validItem;
    });
};
/**
 * 根据 valueType 获取最终输出值
 * @param keys 当前选中的 key 集合（all完整类型）
 * @param records 当前选中的 option 集合
 * @param dataSource 数据源集合
 * @param primaryKey 键名
 * @param originalValueType 值输出类型
 * @param originalOptionAsValue
 * @param mode
 * @param checkStrictly
 * @returns 最终输出的 keys 和 options
 */
var getOutputData = function (keys, // selected
options, dataSource, primaryKey, originalValueType, originalOptionAsValue, mode, checkStrictly) {
    if (primaryKey === void 0) { primaryKey = ''; }
    if (originalValueType === void 0) { originalValueType = ''; }
    if (originalOptionAsValue === void 0) { originalOptionAsValue = false; }
    if (mode === void 0) { mode = ''; }
    var valueType = checkStrictly !== false ? 'all' : originalValueType; // valueType 在 Strictly 为 false 时生效
    var optionAsValue = valueType === 'path' ? false : originalOptionAsValue; // optionAsValue 在 path 模式不生效
    var outputValue = [];
    var outputOptions = [];
    if (valueType === 'parent') {
        // 移除所有选中值的子值
        var childrenKeys_1 = [];
        options.forEach(function (option) {
            childrenKeys_1 = utils_spreadArray(utils_spreadArray([], utils_read(childrenKeys_1), false), utils_read(getTreeKeys(option.children, primaryKey)), false);
        });
        outputValue = keys.filter(function (key) { return !childrenKeys_1.includes(key); });
        outputOptions = options.filter(function (options) {
            return outputValue.includes(options[primaryKey]);
        });
    }
    else if (valueType === 'child') {
        outputValue = utils_spreadArray([], utils_read(keys), false);
        outputOptions = utils_spreadArray([], utils_read(options), false);
        outputOptions.forEach(function (option) {
            // 移除当前有子值被选中的父值
            if (hasSelectedKey(option.children, keys, primaryKey)) {
                outputValue = outputValue.filter(function (key) { return key !== option[primaryKey]; });
                outputOptions = outputOptions.filter(function (options) { return options[primaryKey] !== option[primaryKey]; });
            }
        });
    }
    else if (valueType === 'path') {
        outputValue = getSelectedPath(dataSource, keys, primaryKey);
        outputOptions = utils_spreadArray([], utils_read(options), false);
    }
    else {
        // valueType === 'all'
        outputValue = utils_spreadArray([], utils_read(keys), false);
        outputOptions = utils_spreadArray([], utils_read(options), false);
    }
    outputOptions = deleteTreeItem(outputOptions, '__formily_key__');
    outputValue =
        optionAsValue && valueType !== 'path' ? outputOptions : outputValue;
    if (mode === 'single') {
        outputValue = outputValue[0];
        outputOptions = outputOptions[0];
    }
    return { outputValue: outputValue, outputOptions: outputOptions };
};
/**
 * 根据 valueType 获取 TableUI 显示值
 * @param keys 回填的数据（输出的）keys 集合
 * @param flatDataSource 平铺的数据源集合
 * @param primaryKey 键名称
 * @param originalValueType 值输出类型
 * @param originalOptionAsValue
 * @param mode
 * @param checkStrictly
 * @param rowKey
 * @returns [] TableUI keys 集合
 */
var getUISelected = function (value, flatDataSource, primaryKey, originalValueType, originalOptionAsValue, mode, checkStrictly, rowKey) {
    var valueType = checkStrictly !== false ? 'all' : originalValueType; // valueType 在 Strictly 为 false 时生效
    var optionAsValue = valueType === 'path' ? false : originalOptionAsValue; // optionAsValue 在 path 模式不生效
    var keys = mode === 'single' ? [value] : checkers_isArr(value) ? value : [];
    keys =
        optionAsValue && valueType !== 'path'
            ? keys.map(function (record) {
                return checkers_isFn(rowKey) ? rowKey(record) : record === null || record === void 0 ? void 0 : record[primaryKey || ''];
            })
            : keys;
    var newKeys = [];
    if (valueType === 'parent') {
        var options = flatDataSource === null || flatDataSource === void 0 ? void 0 : flatDataSource.filter(function (item) {
            return keys.includes(item[primaryKey || '']);
        });
        var childrenKeys_2 = [];
        options === null || options === void 0 ? void 0 : options.forEach(function (option) {
            childrenKeys_2 = utils_spreadArray(utils_spreadArray([], utils_read(childrenKeys_2), false), utils_read(getTreeKeys(option.children, primaryKey)), false);
        });
        newKeys = utils_spreadArray([], utils_read(new Set(utils_spreadArray(utils_spreadArray([], utils_read(keys), false), utils_read(childrenKeys_2), false))), false);
    }
    else if (valueType === 'child') {
        newKeys = completedKeys(flatDataSource, keys, primaryKey);
    }
    else if (valueType === 'path') {
        var pathKeys = useFlatOptions(keys).map(function (item) { return item[primaryKey || '']; });
        newKeys = completedKeys(flatDataSource, pathKeys, primaryKey);
    }
    else {
        // valueType === 'all'
        newKeys = utils_spreadArray([], utils_read(keys), false);
    }
    return newKeys;
};
/**
 * 获取兼容筛选模式下是否全部选中子元素
 * @param selected 已选中项
 * @param dataSource 当前数据结构
 * @param usableKeys 当前数据结构的可执行项
 * @param checkStrictly
 * @param primaryKey
 * @returns 是否全部选中
 */
var getCompatibleAllSelected = function (selected, dataSource, usableKeys, checkStrictly, primaryKey) {
    if (!usableKeys.length) {
        return false;
    }
    // 当前模式下已选中的项
    var currentSelected = selected.filter(function (item) {
        return usableKeys.includes(item);
    });
    // 获取有效选中（父子模式或非父子模式）
    var validSelected = checkStrictly !== false
        ? currentSelected // 非父子模式选中项
        : completedKeys(dataSource, currentSelected, primaryKey); // 父子模式选中项
    // 有效选中项数量等于可执行项数量则全部选中子元素
    return validSelected.length === usableKeys.length;
};

//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/hooks/useCheckSlackly.js
var useCheckSlackly_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var useCheckSlackly_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

/**
 * 判断该字段的 indeterminate 属性
 * @param record 当前字段
 * @param flatDataSource 完整平铺数据
 * @param selected 已选中的字段值集合
 * @param primaryKey 键名称
 * @returns indeterminate 属性值
 */
var getIndeterminate = function (record, flatDataSource, selected, primaryKey) {
    if (primaryKey === void 0) { primaryKey = ''; }
    if (selected === null || selected === void 0 ? void 0 : selected.includes(record[primaryKey])) {
        return undefined;
    }
    var wholeRecord = flatDataSource.find(function (item) { return item[primaryKey] === record[primaryKey]; });
    return hasSelectedKey(wholeRecord.children, selected, primaryKey) || undefined;
};
// 父子节点（节点状态按全完整数据计算，节点操作按筛选数据计算）
var useCheckSlackly = function (currentSelected, // onChange 返回的 keys
selected, // Table UI 展示的 keys
flatDataSource, flatFilteredDataSource, primaryKey, checkStrictly) {
    if (primaryKey === void 0) { primaryKey = ''; }
    var isSelected = currentSelected.length > selected.length; // 判断是选中还是取消
    var currentKey = useCheckSlackly_spreadArray(useCheckSlackly_spreadArray([], useCheckSlackly_read(currentSelected), false), useCheckSlackly_read(selected), false).find(function (key) { return !(currentSelected.includes(key) && selected.includes(key)); } // 当前变化key不同时存在于两个selected
    );
    // 从过滤后的数据中获取当前record
    var currentRecord = flatFilteredDataSource.find(function (item) { return item[primaryKey] === currentKey; });
    var currentTreeKeys = getTreeKeys(currentRecord.children, primaryKey);
    // 在筛选状态下（按钮的indeterminate状态处于异常）需要通过数据对比判断是否处于全选中状态
    if (getCompatibleAllSelected(selected, currentRecord.children, currentTreeKeys, checkStrictly, primaryKey)) {
        isSelected = false;
    }
    var newSelected = [];
    if (isSelected) {
        // 选中当前key及其子keys
        newSelected = useCheckSlackly_spreadArray([], useCheckSlackly_read(new Set(useCheckSlackly_spreadArray(useCheckSlackly_spreadArray(useCheckSlackly_spreadArray([], useCheckSlackly_read(selected), false), [currentKey], false), useCheckSlackly_read(currentTreeKeys), false))), false);
    }
    else {
        // 移除当前key及其子keys
        newSelected = selected.filter(function (key) { return !useCheckSlackly_spreadArray([currentKey], useCheckSlackly_read(currentTreeKeys), false).includes(key); });
    }
    newSelected = completedKeys(flatDataSource, newSelected, primaryKey);
    return { selectedRowKeys: newSelected };
};

//# sourceMappingURL=useCheckSlackly.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/hooks/useTitleAddon.js
var useTitleAddon_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var useTitleAddon_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



// 重写表格表头Checkbox（节点状态按全完整数据计算，节点操作按筛选数据计算）
var newCheckbox = function (selected, flatDataSource, flatFilteredDataSource, primaryKey, disabled, readOnly, checkStrictly, onChange) {
    return function () {
        // 全选框是否选中
        var checked = Boolean((selected === null || selected === void 0 ? void 0 : selected.length) &&
            (selected === null || selected === void 0 ? void 0 : selected.length) ===
                flatDataSource.filter(function (item) { return !item.disabled; }).length);
        // 全选框是否未完全选中
        var indeterminate = Boolean((selected === null || selected === void 0 ? void 0 : selected.length) && !checked);
        var onInnerChange = function (e) {
            if (!readOnly) {
                var isSelected = e.target.checked;
                // 当前可执行全选的keys
                var usableKeys_1 = flatFilteredDataSource
                    .filter(function (item) { return !item.disabled; })
                    .map(function (item) { return item === null || item === void 0 ? void 0 : item[primaryKey]; });
                // 在筛选状态下（按钮的indeterminate状态处于异常）需要通过数据对比判断是否处于全选中状态
                if (getCompatibleAllSelected(selected, flatFilteredDataSource, usableKeys_1, checkStrictly, primaryKey)) {
                    isSelected = false;
                }
                var newSelected = [];
                if (isSelected) {
                    // 执行全选
                    newSelected = useTitleAddon_spreadArray([], useTitleAddon_read(new Set(useTitleAddon_spreadArray(useTitleAddon_spreadArray([], useTitleAddon_read(selected), false), useTitleAddon_read(usableKeys_1), false))), false);
                }
                else {
                    // 执行取消全选
                    newSelected = selected.filter(function (key) { return !usableKeys_1.includes(key); });
                }
                newSelected = completedKeys(flatDataSource, newSelected, primaryKey);
                onChange === null || onChange === void 0 ? void 0 : onChange(newSelected);
            }
        };
        return (external_React_default().createElement(external_antd_namespaceObject.Checkbox, { key: "titleAddons", disabled: disabled, checked: checked, indeterminate: indeterminate, onChange: onInnerChange }));
    };
};
var useTitleAddon = function (selected, flatDataSource, flatFilteredDataSource, primaryKey, mode, disabled, readOnly, checkStrictly, onChange) {
    if (mode === 'single') {
        return {};
    }
    return {
        columnTitle: newCheckbox(selected, flatDataSource, flatFilteredDataSource, primaryKey, disabled, readOnly, checkStrictly, onChange),
    };
};

//# sourceMappingURL=useTitleAddon.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/style.js

/* harmony default export */ const select_table_style = (genStyleHook('select-table', function (token) {
    var _a, _b;
    var componentCls = token.componentCls;
    return _a = {},
        _a[componentCls] = (_b = {},
            _b["".concat(componentCls, "-search")] = {
                marginBottom: 8,
            },
            _b),
        _a;
}));
//# sourceMappingURL=style.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/select-table/index.js
var select_table_assign = (undefined && undefined.__assign) || function () {
    select_table_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return select_table_assign.apply(this, arguments);
};
var select_table_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var select_table_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var select_table_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};









var Search = external_antd_namespaceObject.Input.Search;
var select_table_isColumnComponent = function (schema) {
    var _a;
    return ((_a = schema['x-component']) === null || _a === void 0 ? void 0 : _a.indexOf('Column')) > -1;
};
var useSources = function () {
    var arrayField = useField();
    var schema = useFieldSchema();
    var parseSources = function (schema) {
        var _a, _b, _c;
        if (select_table_isColumnComponent(schema)) {
            if (!((_a = schema['x-component-props']) === null || _a === void 0 ? void 0 : _a['dataIndex']) && !schema['name'])
                return [];
            var name_1 = ((_b = schema['x-component-props']) === null || _b === void 0 ? void 0 : _b['dataIndex']) || schema['name'];
            var field = arrayField.query(arrayField.address.concat(name_1)).take();
            var columnProps = ((_c = field === null || field === void 0 ? void 0 : field.component) === null || _c === void 0 ? void 0 : _c[1]) || schema['x-component-props'] || {};
            var display = (field === null || field === void 0 ? void 0 : field.display) || schema['x-display'];
            return [
                {
                    name: name_1,
                    display: display,
                    field: field,
                    schema: schema,
                    columnProps: select_table_assign({ title: (field === null || field === void 0 ? void 0 : field.title) || columnProps.title }, columnProps),
                },
            ];
        }
        else if (schema.properties) {
            return schema.reduceProperties(function (buf, schema) {
                return buf.concat(parseSources(schema));
            }, []);
        }
        return [];
    };
    var parseArrayItems = function (schema) {
        if (!schema)
            return [];
        var sources = [];
        var items = checkers_isArr(schema) ? schema : [schema];
        return items.reduce(function (columns, schema) {
            var item = parseSources(schema);
            if (item) {
                return columns.concat(item);
            }
            return columns;
        }, sources);
    };
    var validSchema = ((schema === null || schema === void 0 ? void 0 : schema.type) === 'array' && (schema === null || schema === void 0 ? void 0 : schema.items) ? schema.items : schema);
    return parseArrayItems(validSchema);
};
var useColumns = function (sources) {
    return sources.reduce(function (buf, _a, key) {
        var name = _a.name, columnProps = _a.columnProps, schema = _a.schema, display = _a.display;
        if (display !== 'visible')
            return buf;
        if (!select_table_isColumnComponent(schema))
            return buf;
        return buf.concat(select_table_assign(select_table_assign({}, columnProps), { key: key, dataIndex: name }));
    }, []);
};
var addPrimaryKey = function (dataSource, rowKey, primaryKey) {
    return dataSource.map(function (item) {
        var _a;
        var children = checkers_isArr(item.children)
            ? addPrimaryKey(item.children, rowKey, primaryKey)
            : {};
        return select_table_assign(select_table_assign(select_table_assign({}, item), children), (_a = {}, _a[primaryKey] = rowKey(item), _a));
    });
};
var InternalSelectTable = observer(function (props) {
    var _a, _b;
    var mode = props.mode, propsDataSource = props.dataSource, optionAsValue = props.optionAsValue, valueType = props.valueType, showSearch = props.showSearch, filterOption = props.filterOption, filterSort = props.filterSort, onSearch = props.onSearch, searchProps = props.searchProps, className = props.className, value = props.value, onChange = props.onChange, rowSelection = props.rowSelection, rowKey = props.primaryKey, otherTableProps = select_table_rest(props, ["mode", "dataSource", "optionAsValue", "valueType", "showSearch", "filterOption", "filterSort", "onSearch", "searchProps", "className", "value", "onChange", "rowSelection", "primaryKey"]);
    var prefixCls = usePrefixCls('formily-select-table', props);
    var _c = select_table_read(select_table_style(prefixCls), 2), wrapSSR = _c[0], hashId = _c[1];
    var _d = select_table_read((0,external_React_namespaceObject.useState)(), 2), searchValue = _d[0], setSearchValue = _d[1];
    var field = useField();
    var loading = isBool(props.loading) ? props.loading : field.loading;
    var disabled = field.disabled;
    var readOnly = field.readOnly;
    var readPretty = field.readPretty;
    var _e = useSize((_a = field.decoratorProps) === null || _a === void 0 ? void 0 : _a.size, searchProps === null || searchProps === void 0 ? void 0 : searchProps.size, props === null || props === void 0 ? void 0 : props.size), searchSize = _e.searchSize, tableSize = _e.tableSize;
    var primaryKey = checkers_isFn(rowKey) ? '__formily_key__' : rowKey;
    var sources = useSources();
    var columns = useColumns(sources);
    // dataSource
    var dataSource = checkers_isArr(propsDataSource) ? propsDataSource : field.dataSource;
    dataSource = checkers_isFn(rowKey)
        ? addPrimaryKey(dataSource, rowKey, primaryKey)
        : dataSource;
    // Filter dataSource By Search
    var filteredDataSource = useFilterOptions(dataSource, searchValue, filterOption, rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly);
    // Order dataSource By filterSort
    var orderedFilteredDataSource = (0,external_React_namespaceObject.useMemo)(function () {
        if (!filterSort) {
            return filteredDataSource;
        }
        return select_table_spreadArray([], select_table_read(filteredDataSource), false).sort(function (a, b) { return filterSort(a, b); });
    }, [filteredDataSource, filterSort]);
    var flatDataSource = useFlatOptions(dataSource);
    var flatFilteredDataSource = useFlatOptions(filteredDataSource);
    // 分页或异步查询时，dataSource会丢失已选数据，配置optionAsValue则无法获取已选数据，需要进行合并
    var getWholeDataSource = function () {
        if (optionAsValue && mode === 'multiple' && (value === null || value === void 0 ? void 0 : value.length)) {
            var map_1 = new Map();
            var arr = select_table_spreadArray(select_table_spreadArray([], select_table_read(flatDataSource), false), select_table_read(value), false);
            arr.forEach(function (item) {
                if (!primaryKey)
                    return;
                if (!map_1.has(item[primaryKey])) {
                    map_1.set(item[primaryKey], item);
                }
            });
            return select_table_spreadArray([], select_table_read(map_1.values()), false);
        }
        return flatDataSource;
    };
    // selected keys for Table UI
    var selected = getUISelected(value, flatDataSource, primaryKey, valueType, optionAsValue, mode, rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly, rowKey);
    // readPretty Value
    var readPrettyDataSource = useFilterOptions(orderedFilteredDataSource, selected, function (value, item) { return primaryKey && value.includes(item[primaryKey]); });
    var onInnerSearch = function (searchText) {
        var formatted = (searchText || '').trim();
        setSearchValue(searchText);
        onSearch === null || onSearch === void 0 ? void 0 : onSearch(formatted);
    };
    var onInnerChange = function (selectedRowKeys) {
        if (readOnly) {
            return;
        }
        // 筛选后onChange默认的records数据不完整，此处需使用完整数据过滤
        var wholeRecords = getWholeDataSource().filter(function (item) { return primaryKey && selectedRowKeys.includes(item === null || item === void 0 ? void 0 : item[primaryKey]); });
        var _a = getOutputData(selectedRowKeys, wholeRecords, dataSource, primaryKey, valueType, optionAsValue, mode, rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly), outputValue = _a.outputValue, outputOptions = _a.outputOptions;
        onChange === null || onChange === void 0 ? void 0 : onChange(outputValue, outputOptions);
    };
    var onRowClick = function (record) {
        if (readPretty || disabled || readOnly || (record === null || record === void 0 ? void 0 : record.disabled)) {
            return;
        }
        var selectedRowKey = primaryKey ? record === null || record === void 0 ? void 0 : record[primaryKey] : null;
        var isSelected = selectedRowKey
            ? selected === null || selected === void 0 ? void 0 : selected.includes(selectedRowKey)
            : false;
        var selectedRowKeys = [];
        if (mode === 'single' && selectedRowKey) {
            selectedRowKeys = [selectedRowKey];
        }
        else {
            if (isSelected) {
                selectedRowKeys = selected.filter(function (item) { return item !== selectedRowKey; });
            }
            else {
                selectedRowKeys = select_table_spreadArray(select_table_spreadArray([], select_table_read(selected), false), [selectedRowKey], false);
            }
        }
        if ((rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly) !== false) {
            onInnerChange(selectedRowKeys);
        }
        else {
            onSlacklyChange(selectedRowKeys);
        }
    };
    // TreeData SlacklyChange
    var onSlacklyChange = function (currentSelected) {
        var selectedRowKeys = useCheckSlackly(currentSelected, selected, flatDataSource, flatFilteredDataSource, primaryKey, rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly).selectedRowKeys;
        onInnerChange(selectedRowKeys);
    };
    // Table All Checkbox
    var titleAddon = useTitleAddon(selected, flatDataSource, flatFilteredDataSource, primaryKey, mode, disabled, readOnly, rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly, onInnerChange);
    // Antd rowSelection type
    var modeAsType = (_b = { multiple: 'checkbox', single: 'radio' }) === null || _b === void 0 ? void 0 : _b[mode || ''];
    return wrapSSR(external_React_default().createElement("div", { className: classnames_default()(prefixCls, hashId) },
        showSearch ? (external_React_default().createElement(Search, select_table_assign({}, searchProps, { className: classnames_default()("".concat(prefixCls, "-search"), searchProps === null || searchProps === void 0 ? void 0 : searchProps.className), style: select_table_assign({ width: '100%' }, searchProps === null || searchProps === void 0 ? void 0 : searchProps.style), onSearch: onInnerSearch, onChange: function (e) { return onInnerSearch(e.target.value); }, disabled: disabled, readOnly: readOnly, size: searchSize, loading: loading }))) : null,
        external_React_default().createElement(external_antd_namespaceObject.Table, select_table_assign({}, otherTableProps, { className: classnames_default()("".concat(prefixCls, "-table"), className), dataSource: readPretty ? readPrettyDataSource : orderedFilteredDataSource, rowSelection: readPretty
                ? undefined
                : select_table_assign(select_table_assign(select_table_assign(select_table_assign(select_table_assign({}, rowSelection), titleAddon), { getCheckboxProps: function (record) {
                        var _a;
                        return (select_table_assign(select_table_assign({}, (_a = rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.getCheckboxProps) === null || _a === void 0 ? void 0 : _a.call(rowSelection, record)), { disabled: disabled || (record === null || record === void 0 ? void 0 : record.disabled) }));
                    } }), ((rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly) !== false
                    ? {}
                    : {
                        renderCell: function (checked, record, index, originNode) {
                            return external_React_default().cloneElement(originNode, {
                                indeterminate: getIndeterminate(record, flatDataSource, selected, primaryKey),
                            });
                        },
                    })), { selectedRowKeys: selected, onChange: (rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.checkStrictly) !== false
                        ? onInnerChange
                        : onSlacklyChange, type: modeAsType, preserveSelectedRowKeys: true, checkStrictly: true }), columns: props.columns || columns, rowKey: primaryKey, loading: loading, size: tableSize, onRow: function (record) {
                var _a;
                // antd
                var onRowResult = (_a = otherTableProps.onRow) === null || _a === void 0 ? void 0 : _a.call(otherTableProps, record);
                return select_table_assign(select_table_assign({}, onRowResult), { onClick: function (e) {
                        var _a;
                        (_a = onRowResult === null || onRowResult === void 0 ? void 0 : onRowResult.onClick) === null || _a === void 0 ? void 0 : _a.call(onRowResult, e);
                        onRowClick(record);
                    } });
            } }), ''),
        sources.map(function (column, key) {
            //专门用来承接对Column的状态管理
            if (!select_table_isColumnComponent(column.schema))
                return;
            return external_React_default().createElement(RecursionField, {
                name: column.name,
                schema: column.schema,
                onlyRenderSelf: true,
                key: key,
            });
        })));
});
var TableColumn = function () { return external_React_default().createElement((external_React_default()).Fragment, null); };
var SelectTable = Object.assign(InternalSelectTable, {
    Column: TableColumn,
});
SelectTable.defaultProps = {
    showSearch: false,
    valueType: 'all',
    primaryKey: 'key',
    mode: 'multiple',
};
/* harmony default export */ const select_table = ((/* unused pure expression or super */ null && (SelectTable)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/space/index.js
var space_assign = (undefined && undefined.__assign) || function () {
    space_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return space_assign.apply(this, arguments);
};



var Space = function (props) {
    var _a;
    var layout = useFormLayout();
    return external_React_default().createElement(external_antd_namespaceObject.Space, space_assign({ size: (_a = props.size) !== null && _a !== void 0 ? _a : layout === null || layout === void 0 ? void 0 : layout.spaceGap }, props));
};
/* harmony default export */ const space = ((/* unused pure expression or super */ null && (Space)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/submit/index.js
var submit_assign = (undefined && undefined.__assign) || function () {
    submit_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return submit_assign.apply(this, arguments);
};
var submit_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



var Submit = observer(function (_a) {
    var onSubmit = _a.onSubmit, onSubmitFailed = _a.onSubmitFailed, onSubmitSuccess = _a.onSubmitSuccess, props = submit_rest(_a, ["onSubmit", "onSubmitFailed", "onSubmitSuccess"]);
    var form = useParentForm();
    return (external_React_default().createElement(external_antd_namespaceObject.Button, submit_assign({ htmlType: onSubmit ? 'button' : 'submit', type: "primary" }, props, { loading: props.loading !== undefined ? props.loading : form.submitting, onClick: function (e) {
            if (props.onClick) {
                if (props.onClick(e) === false)
                    return;
            }
            if (onSubmit) {
                form.submit(onSubmit).then(onSubmitSuccess).catch(onSubmitFailed);
            }
        } }), props.children));
}, {
    forwardRef: true,
});
/* harmony default export */ const esm_submit = ((/* unused pure expression or super */ null && (Submit)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/switch/index.js
var switch_assign = (undefined && undefined.__assign) || function () {
    switch_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return switch_assign.apply(this, arguments);
};


var Switch = connect(external_antd_namespaceObject.Switch, mapProps({
    value: 'checked',
}, function (props) {
    delete props['value'];
    return switch_assign({}, props);
}));
/* harmony default export */ const esm_switch = ((/* unused pure expression or super */ null && (Switch)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/time-picker/index.js
var time_picker_assign = (undefined && undefined.__assign) || function () {
    time_picker_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return time_picker_assign.apply(this, arguments);
};




var mapTimeFormat = function () {
    return function (props) {
        var format = props['format'] || 'HH:mm:ss';
        var onChange = props.onChange;
        return time_picker_assign(time_picker_assign({}, props), { format: format, value: dayjsable(props.value, format), onChange: function (value) {
                if (onChange) {
                    onChange(formatDayjsValue(value, format));
                }
            } });
    };
};
var InternalTimePicker = connect(external_antd_namespaceObject.TimePicker, mapProps(mapTimeFormat()), mapReadPretty(PreviewText.TimePicker));
var time_picker_RangePicker = connect(external_antd_namespaceObject.TimePicker.RangePicker, mapProps(mapTimeFormat()), mapReadPretty(PreviewText.TimeRangePicker));
var time_picker_TimePicker = Object.assign(InternalTimePicker, { RangePicker: time_picker_RangePicker });
/* harmony default export */ const time_picker = ((/* unused pure expression or super */ null && (time_picker_TimePicker)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/transfer/index.js
var transfer_assign = (undefined && undefined.__assign) || function () {
    transfer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return transfer_assign.apply(this, arguments);
};



var Transfer = connect(external_antd_namespaceObject.Transfer, mapProps({
    value: 'targetKeys',
}, function (props, field) {
    var _a;
    if (isVoidField(field))
        return props;
    return transfer_assign(transfer_assign({}, props), { dataSource: ((_a = field.dataSource) === null || _a === void 0 ? void 0 : _a.map(function (item) {
            return transfer_assign(transfer_assign({}, item), { title: item.title || item.label, key: item.key || item.value });
        })) || [] });
}));
Transfer.defaultProps = {
    render: function (item) { var _a; return (_a = item.title) !== null && _a !== void 0 ? _a : null; },
};
/* harmony default export */ const transfer = ((/* unused pure expression or super */ null && (Transfer)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/tree-select/index.js
var tree_select_assign = (undefined && undefined.__assign) || function () {
    tree_select_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return tree_select_assign.apply(this, arguments);
};





var tree_select_TreeSelect = connect(external_antd_namespaceObject.TreeSelect, mapProps({
    dataSource: 'treeData',
}, function (props, field) {
    return tree_select_assign(tree_select_assign({}, props), { suffixIcon: (field === null || field === void 0 ? void 0 : field['loading']) || (field === null || field === void 0 ? void 0 : field['validating']) ? (external_React_default().createElement(external_icons_namespaceObject.LoadingOutlined, null)) : (props.suffixIcon) });
}), mapReadPretty(PreviewText.TreeSelect));
/* harmony default export */ const tree_select = ((/* unused pure expression or super */ null && (tree_select_TreeSelect)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/upload/placeholder.js
var UPLOAD_PLACEHOLDER = [
    {
        ext: /\.docx/i,
        icon: '//img.alicdn.com/tfs/TB1n8jfr1uSBuNjy1XcXXcYjFXa-200-200.png',
    },
    {
        ext: /\.pptx/i,
        icon: '//img.alicdn.com/tfs/TB1ItgWr_tYBeNjy1XdXXXXyVXa-200-200.png',
    },
    {
        ext: /\.jpe?g/i,
        icon: '//img.alicdn.com/tfs/TB1wrT5r9BYBeNjy0FeXXbnmFXa-200-200.png',
    },
    {
        ext: /\.pdf/i,
        icon: '//img.alicdn.com/tfs/TB1GwD8r9BYBeNjy0FeXXbnmFXa-200-200.png',
    },
    {
        ext: /\.png/i,
        icon: '//img.alicdn.com/tfs/TB1BHT5r9BYBeNjy0FeXXbnmFXa-200-200.png',
    },
    {
        ext: /\.eps/i,
        icon: '//img.alicdn.com/tfs/TB1G_iGrVOWBuNjy0FiXXXFxVXa-200-200.png',
    },
    {
        ext: /\.ai/i,
        icon: '//img.alicdn.com/tfs/TB1B2cVr_tYBeNjy1XdXXXXyVXa-200-200.png',
    },
    {
        ext: /\.gif/i,
        icon: '//img.alicdn.com/tfs/TB1DTiGrVOWBuNjy0FiXXXFxVXa-200-200.png',
    },
    {
        ext: /\.svg/i,
        icon: '//img.alicdn.com/tfs/TB1uUm9rY9YBuNjy0FgXXcxcXXa-200-200.png',
    },
    {
        ext: /\.xlsx?/i,
        icon: '//img.alicdn.com/tfs/TB1any1r1OSBuNjy0FdXXbDnVXa-200-200.png',
    },
    {
        ext: /\.psd?/i,
        icon: '//img.alicdn.com/tfs/TB1_nu1r1OSBuNjy0FdXXbDnVXa-200-200.png',
    },
    {
        ext: /\.(wav|aif|aiff|au|mp1|mp2|mp3|ra|rm|ram|mid|rmi)/i,
        icon: '//img.alicdn.com/tfs/TB1jPvwr49YBuNjy0FfXXXIsVXa-200-200.png',
    },
    {
        ext: /\.(avi|wmv|mpg|mpeg|vob|dat|3gp|mp4|mkv|rm|rmvb|mov|flv)/i,
        icon: '//img.alicdn.com/tfs/TB1FrT5r9BYBeNjy0FeXXbnmFXa-200-200.png',
    },
    {
        ext: /\.(zip|rar|arj|z|gz|iso|jar|ace|tar|uue|dmg|pkg|lzh|cab)/i,
        icon: '//img.alicdn.com/tfs/TB10jmfr29TBuNjy0FcXXbeiFXa-200-200.png',
    },
    {
        ext: /\.[^.]+/i,
        icon: '//img.alicdn.com/tfs/TB10.R4r3mTBuNjy1XbXXaMrVXa-200-200.png',
    },
];
//# sourceMappingURL=placeholder.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/upload/index.js
var upload_assign = (undefined && undefined.__assign) || function () {
    upload_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return upload_assign.apply(this, arguments);
};
var upload_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var upload_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var upload_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};








var testOpts = function (ext, options) {
    if (options && checkers_isArr(options.include)) {
        return options.include.some(function (url) { return ext.test(url); });
    }
    if (options && checkers_isArr(options.exclude)) {
        return !options.exclude.some(function (url) { return ext.test(url); });
    }
    return true;
};
var getImageByUrl = function (url, options) {
    for (var i = 0; i < UPLOAD_PLACEHOLDER.length; i++) {
        if (UPLOAD_PLACEHOLDER[i].ext.test(url) &&
            testOpts(UPLOAD_PLACEHOLDER[i].ext, options)) {
            return UPLOAD_PLACEHOLDER[i].icon || url;
        }
    }
    return url;
};
var getURL = function (target) {
    return (target === null || target === void 0 ? void 0 : target['url']) || (target === null || target === void 0 ? void 0 : target['downloadURL']) || (target === null || target === void 0 ? void 0 : target['imgURL']);
};
var getThumbURL = function (target) {
    return ((target === null || target === void 0 ? void 0 : target['thumbUrl']) ||
        (target === null || target === void 0 ? void 0 : target['url']) ||
        (target === null || target === void 0 ? void 0 : target['downloadURL']) ||
        (target === null || target === void 0 ? void 0 : target['imgURL']));
};
var getErrorMessage = function (target) {
    return ((target === null || target === void 0 ? void 0 : target.errorMessage) ||
        (target === null || target === void 0 ? void 0 : target.errMsg) ||
        (target === null || target === void 0 ? void 0 : target.errorMsg) ||
        (target === null || target === void 0 ? void 0 : target.message) ||
        (typeof (target === null || target === void 0 ? void 0 : target.error) === 'string' ? target.error : ''));
};
var getState = function (target) {
    if ((target === null || target === void 0 ? void 0 : target.success) === false)
        return 'error';
    if ((target === null || target === void 0 ? void 0 : target.failed) === true)
        return 'error';
    if (target === null || target === void 0 ? void 0 : target.error)
        return 'error';
    return (target === null || target === void 0 ? void 0 : target.state) || (target === null || target === void 0 ? void 0 : target.status);
};
var normalizeFileList = function (fileList) {
    if (fileList && fileList.length) {
        return fileList.map(function (file, index) {
            return upload_assign(upload_assign({}, file), { uid: file.uid || "".concat(index), status: getState(file.response) || getState(file), url: getURL(file) || getURL(file === null || file === void 0 ? void 0 : file.response), thumbUrl: getImageByUrl(getThumbURL(file) || getThumbURL(file === null || file === void 0 ? void 0 : file.response), {
                    exclude: ['.png', '.jpg', '.jpeg', '.gif'],
                }) });
        });
    }
    return [];
};
var useValidator = function (validator) {
    var field = useField();
    (0,external_React_namespaceObject.useEffect)(function () {
        var dispose = reaction(function () { return field.value; }, function (value) {
            var message = validator(value);
            field.setFeedback({
                type: 'error',
                code: 'UploadError',
                messages: message ? [message] : [],
            });
        });
        return function () {
            dispose();
        };
    }, []);
};
var useUploadValidator = function (serviceErrorMessage) {
    if (serviceErrorMessage === void 0) { serviceErrorMessage = 'Upload Service Error'; }
    useValidator(function (value) {
        var _a, _b;
        var list = toArr(value);
        for (var i = 0; i < list.length; i++) {
            if (((_a = list[i]) === null || _a === void 0 ? void 0 : _a.status) === 'error') {
                return (getErrorMessage((_b = list[i]) === null || _b === void 0 ? void 0 : _b.response) ||
                    getErrorMessage(list[i]) ||
                    serviceErrorMessage);
            }
        }
    });
};
function useUploadProps(_a) {
    var serviceErrorMessage = _a.serviceErrorMessage, props = upload_rest(_a, ["serviceErrorMessage"]);
    useUploadValidator(serviceErrorMessage);
    var onChange = function (param) {
        var _a;
        (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, normalizeFileList(upload_spreadArray([], upload_read(param.fileList), false)));
    };
    return upload_assign(upload_assign({}, props), { fileList: normalizeFileList(props.fileList), onChange: onChange });
}
var getPlaceholder = function (props) {
    if (props.listType !== 'picture-card') {
        return (external_React_default().createElement(external_antd_namespaceObject.Button, null,
            external_React_default().createElement(external_icons_namespaceObject.UploadOutlined, null),
            props.textContent));
    }
    return null;
};
var Upload = connect(function (props) {
    return (external_React_default().createElement(external_antd_namespaceObject.Upload, upload_assign({}, useUploadProps(props)), props.children || getPlaceholder(props)));
}, mapProps({
    value: 'fileList',
}));
var Dragger = connect(function (props) {
    return (external_React_default().createElement("div", { className: usePrefixCls('upload-dragger') },
        external_React_default().createElement(external_antd_namespaceObject.Upload.Dragger, upload_assign({}, useUploadProps(props)), props.children || (external_React_default().createElement((external_React_default()).Fragment, null,
            external_React_default().createElement("p", { className: "ant-upload-drag-icon" },
                external_React_default().createElement(external_icons_namespaceObject.InboxOutlined, null)),
            props.textContent && (external_React_default().createElement("p", { className: "ant-upload-text" }, props.textContent)))))));
}, mapProps({
    value: 'fileList',
}));
Upload.Dragger = Dragger;
/* harmony default export */ const upload = ((/* unused pure expression or super */ null && (Upload)));
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/.pnpm/@formily+antd-v5@1.2.0_@types+react-dom@18.3.0_@types+react@18.3.3_antd@5.17.3_react-dom@18.3_xzhpduymzw4ezlsanglpuwkjna/node_modules/@formily/antd-v5/esm/index.js



































//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./pre-bundle/entries/formily.ts




})();

var __webpack_exports__AntdV5 = __webpack_exports__.JV;
var __webpack_exports__Core = __webpack_exports__.iJ;
var __webpack_exports__React = __webpack_exports__.q_;
export { __webpack_exports__AntdV5 as AntdV5, __webpack_exports__Core as Core, __webpack_exports__React as React };
